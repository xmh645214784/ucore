diff -ruP /home/xmh/origin/ucore_os_lab/labcodes/lab5/.badarg.log lab5/.badarg.log
--- /home/xmh/origin/ucore_os_lab/labcodes/lab5/.badarg.log	1970-01-01 00:00:00.000000000 +0000
+++ lab5/.badarg.log	2020-05-24 07:22:41.194056683 +0000
@@ -0,0 +1,111 @@
+(THU.CST) os is loading ...
+
+Special kernel symbols:
+  entry  0xc0100036 (phys)
+  etext  0xc010c002 (phys)
+  edata  0xc019f000 (phys)
+  end    0xc01a21b8 (phys)
+Kernel executable memory footprint: 649KB
+ebp:0xc012af38   eip:0xc0100ba9 arg :0x00010094 0x00010094 0xc012af68 0xc01000df
+    kern/debug/kdebug.c:351: print_stackframe+22
+ebp:0xc012af48   eip:0xc0100e9d arg :0x00000000 0x00000000 0x00000000 0xc012afb8
+    kern/debug/kmonitor.c:129: mon_backtrace+10
+ebp:0xc012af68   eip:0xc01000df arg :0x00000000 0xc012af90 0xffff0000 0xc012af94
+    kern/init/init.c:58: grade_backtrace2+33
+ebp:0xc012af88   eip:0xc0100109 arg :0x00000000 0xffff0000 0xc012afb4 0x0000002a
+    kern/init/init.c:63: grade_backtrace1+38
+ebp:0xc012afa8   eip:0xc0100128 arg :0x00000000 0xc0100036 0xffff0000 0x0000001d
+    kern/init/init.c:68: grade_backtrace0+23
+ebp:0xc012afc8   eip:0xc010014e arg :0xc010c03c 0xc010c020 0x000031b8 0x00000000
+    kern/init/init.c:73: grade_backtrace+34
+ebp:0xc012aff8   eip:0xc010008b arg :0xc010c234 0xc010c23c 0xc0100e25 0xc010c25b
+    kern/init/init.c:33: kern_init+84
+memory management: default_pmm_manager
+e820map:
+  memory: 0009fc00, [00000000, 0009fbff], type = 1.
+  memory: 00000400, [0009fc00, 0009ffff], type = 2.
+  memory: 00010000, [000f0000, 000fffff], type = 2.
+  memory: 07ee0000, [00100000, 07fdffff], type = 1.
+  memory: 00020000, [07fe0000, 07ffffff], type = 2.
+  memory: 00040000, [fffc0000, ffffffff], type = 2.
+check_alloc_page() succeeded!
+check_pgdir() succeeded!
+check_boot_pgdir() succeeded!
+-------------------- BEGIN --------------------
+PDE(0e0) c0000000-f8000000 38000000 urw
+  |-- PTE(38000) c0000000-f8000000 38000000 -rw
+PDE(001) fac00000-fb000000 00400000 -rw
+  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw
+  |-- PTE(00001) fafeb000-fafec000 00001000 -rw
+--------------------- END ---------------------
+use SLOB allocator
+kmalloc_init() succeeded!
+check_vma_struct() succeeded!
+page fault at 0x00000100: K/W [no page found].
+check_pgfault() succeeded!
+check_vmm() succeeded.
+ide 0:      10000(sectors), 'QEMU HARDDISK'.
+ide 1:     262144(sectors), 'QEMU HARDDISK'.
+SWAP: manager = fifo swap manager
+BEGIN check_swap: count 1, total 31835
+setup Page Table for vaddr 0X1000, so alloc a page
+setup Page Table vaddr 0~4MB OVER!
+set up init env for check_swap begin!
+page fault at 0x00001000: K/W [no page found].
+page fault at 0x00002000: K/W [no page found].
+page fault at 0x00003000: K/W [no page found].
+page fault at 0x00004000: K/W [no page found].
+set up init env for check_swap over!
+write Virt Page c in fifo_check_swap
+write Virt Page a in fifo_check_swap
+write Virt Page d in fifo_check_swap
+write Virt Page b in fifo_check_swap
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+write Virt Page b in fifo_check_swap
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+write Virt Page b in fifo_check_swap
+page fault at 0x00002000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x3000 to disk swap entry 4
+swap_in: load disk swap entry 3 with swap_page in vadr 0x2000
+write Virt Page c in fifo_check_swap
+page fault at 0x00003000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x4000 to disk swap entry 5
+swap_in: load disk swap entry 4 with swap_page in vadr 0x3000
+write Virt Page d in fifo_check_swap
+page fault at 0x00004000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x5000 to disk swap entry 6
+swap_in: load disk swap entry 5 with swap_page in vadr 0x4000
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+swap_in: load disk swap entry 6 with swap_page in vadr 0x5000
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/R [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+count is 0, total is 5
+check_swap() succeeded!
+++ setup timer interrupts
+kernel_execve: pid = 2, name = "badarg".
+fork ok.
+badarg pass.
+all user-mode processes have quit.
+init check memory pass.
+kernel panic at kern/process/proc.c:525:
+    initproc exit.
+
+stack trackback:
+ebp:0xc0384f88   eip:0xc0100ba9 arg :0xc010c0e8 0xc0384fcc 0x0000020d 0xc0384fb8
+    kern/debug/kdebug.c:351: print_stackframe+22
+ebp:0xc0384fb8   eip:0xc0100468 arg :0xc010e0cc 0x0000020d 0xc010e11e 0x00000000
+    kern/debug/panic.c:27: __panic+103
+ebp:0xc0384fe8   eip:0xc010a151 arg :0x00000000 0x00000000 0x00000000 0x00000010
+    kern/process/proc.c:525: do_exit+91
+Welcome to the kernel debug monitor!!
+Type 'help' for a list of commands.
+K> 
\ 文件尾没有换行符
diff -ruP /home/xmh/origin/ucore_os_lab/labcodes/lab5/.badsegment.log lab5/.badsegment.log
--- /home/xmh/origin/ucore_os_lab/labcodes/lab5/.badsegment.log	1970-01-01 00:00:00.000000000 +0000
+++ lab5/.badsegment.log	2020-05-24 07:22:24.645789727 +0000
@@ -0,0 +1,130 @@
+(THU.CST) os is loading ...
+
+Special kernel symbols:
+  entry  0xc0100036 (phys)
+  etext  0xc010c002 (phys)
+  edata  0xc019f000 (phys)
+  end    0xc01a21b8 (phys)
+Kernel executable memory footprint: 649KB
+ebp:0xc012af38   eip:0xc0100ba9 arg :0x00010094 0x00010094 0xc012af68 0xc01000df
+    kern/debug/kdebug.c:351: print_stackframe+22
+ebp:0xc012af48   eip:0xc0100e9d arg :0x00000000 0x00000000 0x00000000 0xc012afb8
+    kern/debug/kmonitor.c:129: mon_backtrace+10
+ebp:0xc012af68   eip:0xc01000df arg :0x00000000 0xc012af90 0xffff0000 0xc012af94
+    kern/init/init.c:58: grade_backtrace2+33
+ebp:0xc012af88   eip:0xc0100109 arg :0x00000000 0xffff0000 0xc012afb4 0x0000002a
+    kern/init/init.c:63: grade_backtrace1+38
+ebp:0xc012afa8   eip:0xc0100128 arg :0x00000000 0xc0100036 0xffff0000 0x0000001d
+    kern/init/init.c:68: grade_backtrace0+23
+ebp:0xc012afc8   eip:0xc010014e arg :0xc010c03c 0xc010c020 0x000031b8 0x00000000
+    kern/init/init.c:73: grade_backtrace+34
+ebp:0xc012aff8   eip:0xc010008b arg :0xc010c234 0xc010c23c 0xc0100e25 0xc010c25b
+    kern/init/init.c:33: kern_init+84
+memory management: default_pmm_manager
+e820map:
+  memory: 0009fc00, [00000000, 0009fbff], type = 1.
+  memory: 00000400, [0009fc00, 0009ffff], type = 2.
+  memory: 00010000, [000f0000, 000fffff], type = 2.
+  memory: 07ee0000, [00100000, 07fdffff], type = 1.
+  memory: 00020000, [07fe0000, 07ffffff], type = 2.
+  memory: 00040000, [fffc0000, ffffffff], type = 2.
+check_alloc_page() succeeded!
+check_pgdir() succeeded!
+check_boot_pgdir() succeeded!
+-------------------- BEGIN --------------------
+PDE(0e0) c0000000-f8000000 38000000 urw
+  |-- PTE(38000) c0000000-f8000000 38000000 -rw
+PDE(001) fac00000-fb000000 00400000 -rw
+  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw
+  |-- PTE(00001) fafeb000-fafec000 00001000 -rw
+--------------------- END ---------------------
+use SLOB allocator
+kmalloc_init() succeeded!
+check_vma_struct() succeeded!
+page fault at 0x00000100: K/W [no page found].
+check_pgfault() succeeded!
+check_vmm() succeeded.
+ide 0:      10000(sectors), 'QEMU HARDDISK'.
+ide 1:     262144(sectors), 'QEMU HARDDISK'.
+SWAP: manager = fifo swap manager
+BEGIN check_swap: count 1, total 31835
+setup Page Table for vaddr 0X1000, so alloc a page
+setup Page Table vaddr 0~4MB OVER!
+set up init env for check_swap begin!
+page fault at 0x00001000: K/W [no page found].
+page fault at 0x00002000: K/W [no page found].
+page fault at 0x00003000: K/W [no page found].
+page fault at 0x00004000: K/W [no page found].
+set up init env for check_swap over!
+write Virt Page c in fifo_check_swap
+write Virt Page a in fifo_check_swap
+write Virt Page d in fifo_check_swap
+write Virt Page b in fifo_check_swap
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+write Virt Page b in fifo_check_swap
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+write Virt Page b in fifo_check_swap
+page fault at 0x00002000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x3000 to disk swap entry 4
+swap_in: load disk swap entry 3 with swap_page in vadr 0x2000
+write Virt Page c in fifo_check_swap
+page fault at 0x00003000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x4000 to disk swap entry 5
+swap_in: load disk swap entry 4 with swap_page in vadr 0x3000
+write Virt Page d in fifo_check_swap
+page fault at 0x00004000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x5000 to disk swap entry 6
+swap_in: load disk swap entry 5 with swap_page in vadr 0x4000
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+swap_in: load disk swap entry 6 with swap_page in vadr 0x5000
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/R [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+count is 0, total is 5
+check_swap() succeeded!
+++ setup timer interrupts
+kernel_execve: pid = 2, name = "badsegment".
+trapframe at 0xc038bfb4
+  edi  0x00000000
+  esi  0x00000000
+  ebp  0xafffffa8
+  oesp 0xc038bfd4
+  ebx  0x00000000
+  edx  0x00000000
+  ecx  0x00000000
+  eax  0x00000028
+  ds   0x----0023
+  es   0x----0023
+  fs   0x----0000
+  gs   0x----0000
+  trap 0x0000000d General Protection
+  err  0x00000028
+  eip  0x00800f87
+  cs   0x----001b
+  flag 0x00000286 PF,SF,IF,IOPL=0
+  esp  0xafffff90
+  ss   0x----0023
+unhandled trap.
+all user-mode processes have quit.
+init check memory pass.
+kernel panic at kern/process/proc.c:525:
+    initproc exit.
+
+stack trackback:
+ebp:0xc0384f88   eip:0xc0100ba9 arg :0xc010c0e8 0xc0384fcc 0x0000020d 0xc0384fb8
+    kern/debug/kdebug.c:351: print_stackframe+22
+ebp:0xc0384fb8   eip:0xc0100468 arg :0xc010e0cc 0x0000020d 0xc010e11e 0x00000000
+    kern/debug/panic.c:27: __panic+103
+ebp:0xc0384fe8   eip:0xc010a151 arg :0x00000000 0x00000000 0x00000000 0x00000010
+    kern/process/proc.c:525: do_exit+91
+Welcome to the kernel debug monitor!!
+Type 'help' for a list of commands.
+K> 
\ 文件尾没有换行符
diff -ruP /home/xmh/origin/ucore_os_lab/labcodes/lab5/.check_vmm.log lab5/.check_vmm.log
--- /home/xmh/origin/ucore_os_lab/labcodes/lab5/.check_vmm.log	1970-01-01 00:00:00.000000000 +0000
+++ lab5/.check_vmm.log	2020-05-24 04:46:26.057832502 +0000
@@ -0,0 +1,109 @@
+(THU.CST) os is loading ...
+
+Special kernel symbols:
+  entry  0xc0100036 (phys)
+  etext  0xc0109fb9 (phys)
+  edata  0xc0128000 (phys)
+  end    0xc012b1b8 (phys)
+Kernel executable memory footprint: 173KB
+ebp:0xc0124f38   eip:0xc0100ab1 arg :0x00010094 0x00010094 0xc0124f68 0xc01000df
+    kern/debug/kdebug.c:309: print_stackframe+22
+ebp:0xc0124f48   eip:0xc0100da5 arg :0x00000000 0x00000000 0x00000000 0xc0124fb8
+    kern/debug/kmonitor.c:129: mon_backtrace+10
+ebp:0xc0124f68   eip:0xc01000df arg :0x00000000 0xc0124f90 0xffff0000 0xc0124f94
+    kern/init/init.c:58: grade_backtrace2+33
+ebp:0xc0124f88   eip:0xc0100109 arg :0x00000000 0xffff0000 0xc0124fb4 0x0000002a
+    kern/init/init.c:63: grade_backtrace1+38
+ebp:0xc0124fa8   eip:0xc0100128 arg :0x00000000 0xc0100036 0xffff0000 0x0000001d
+    kern/init/init.c:68: grade_backtrace0+23
+ebp:0xc0124fc8   eip:0xc010014e arg :0xc0109fdc 0xc0109fc0 0x000031b8 0x00000000
+    kern/init/init.c:73: grade_backtrace+34
+ebp:0xc0124ff8   eip:0xc010008b arg :0xc010a1d4 0xc010a1dc 0xc0100d2d 0xc010a1fb
+    kern/init/init.c:33: kern_init+84
+memory management: default_pmm_manager
+e820map:
+  memory: 0009fc00, [00000000, 0009fbff], type = 1.
+  memory: 00000400, [0009fc00, 0009ffff], type = 2.
+  memory: 00010000, [000f0000, 000fffff], type = 2.
+  memory: 07ee0000, [00100000, 07fdffff], type = 1.
+  memory: 00020000, [07fe0000, 07ffffff], type = 2.
+  memory: 00040000, [fffc0000, ffffffff], type = 2.
+check_alloc_page() succeeded!
+check_pgdir() succeeded!
+check_boot_pgdir() succeeded!
+-------------------- BEGIN --------------------
+PDE(0e0) c0000000-f8000000 38000000 urw
+  |-- PTE(38000) c0000000-f8000000 38000000 -rw
+PDE(001) fac00000-fb000000 00400000 -rw
+  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw
+  |-- PTE(00001) fafeb000-fafec000 00001000 -rw
+--------------------- END ---------------------
+use SLOB allocator
+kmalloc_init() succeeded!
+check_vma_struct() succeeded!
+page fault at 0x00000100: K/W [no page found].
+check_pgfault() succeeded!
+check_vmm() succeeded.
+ide 0:      10000(sectors), 'QEMU HARDDISK'.
+ide 1:     262144(sectors), 'QEMU HARDDISK'.
+SWAP: manager = fifo swap manager
+BEGIN check_swap: count 1, total 31954
+setup Page Table for vaddr 0X1000, so alloc a page
+setup Page Table vaddr 0~4MB OVER!
+set up init env for check_swap begin!
+page fault at 0x00001000: K/W [no page found].
+page fault at 0x00002000: K/W [no page found].
+page fault at 0x00003000: K/W [no page found].
+page fault at 0x00004000: K/W [no page found].
+set up init env for check_swap over!
+write Virt Page c in fifo_check_swap
+write Virt Page a in fifo_check_swap
+write Virt Page d in fifo_check_swap
+write Virt Page b in fifo_check_swap
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+write Virt Page b in fifo_check_swap
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+write Virt Page b in fifo_check_swap
+page fault at 0x00002000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x3000 to disk swap entry 4
+swap_in: load disk swap entry 3 with swap_page in vadr 0x2000
+write Virt Page c in fifo_check_swap
+page fault at 0x00003000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x4000 to disk swap entry 5
+swap_in: load disk swap entry 4 with swap_page in vadr 0x3000
+write Virt Page d in fifo_check_swap
+page fault at 0x00004000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x5000 to disk swap entry 6
+swap_in: load disk swap entry 5 with swap_page in vadr 0x4000
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+swap_in: load disk swap entry 6 with swap_page in vadr 0x5000
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/R [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+count is 0, total is 5
+check_swap() succeeded!
+++ setup timer interrupts
+this initproc, pid = 1, name = "init"
+To U: "Hello world!!".
+To U: "en.., Bye, Bye. :)"
+kernel panic at kern/process/proc.c:387:
+    process exit!!.
+
+stack trackback:
+ebp:0xc030df98   eip:0xc0100ab1 arg :0xc010a088 0xc030dfdc 0x00000183 0xc030dfcc
+    kern/debug/kdebug.c:309: print_stackframe+22
+ebp:0xc030dfc8   eip:0xc0100468 arg :0xc010bef9 0x00000183 0xc010bf0d 0xc012b044
+    kern/debug/panic.c:27: __panic+103
+ebp:0xc030dfe8   eip:0xc0109020 arg :0x00000000 0xc010bf8c 0x00000000 0x00000010
+    kern/process/proc.c:387: do_exit+33
+Welcome to the kernel debug monitor!!
+Type 'help' for a list of commands.
+K> 
\ 文件尾没有换行符
diff -ruP /home/xmh/origin/ucore_os_lab/labcodes/lab5/.divzero.log lab5/.divzero.log
--- /home/xmh/origin/ucore_os_lab/labcodes/lab5/.divzero.log	1970-01-01 00:00:00.000000000 +0000
+++ lab5/.divzero.log	2020-05-24 07:22:26.505819739 +0000
@@ -0,0 +1,130 @@
+(THU.CST) os is loading ...
+
+Special kernel symbols:
+  entry  0xc0100036 (phys)
+  etext  0xc010c002 (phys)
+  edata  0xc019f000 (phys)
+  end    0xc01a21b8 (phys)
+Kernel executable memory footprint: 649KB
+ebp:0xc012af38   eip:0xc0100ba9 arg :0x00010094 0x00010094 0xc012af68 0xc01000df
+    kern/debug/kdebug.c:351: print_stackframe+22
+ebp:0xc012af48   eip:0xc0100e9d arg :0x00000000 0x00000000 0x00000000 0xc012afb8
+    kern/debug/kmonitor.c:129: mon_backtrace+10
+ebp:0xc012af68   eip:0xc01000df arg :0x00000000 0xc012af90 0xffff0000 0xc012af94
+    kern/init/init.c:58: grade_backtrace2+33
+ebp:0xc012af88   eip:0xc0100109 arg :0x00000000 0xffff0000 0xc012afb4 0x0000002a
+    kern/init/init.c:63: grade_backtrace1+38
+ebp:0xc012afa8   eip:0xc0100128 arg :0x00000000 0xc0100036 0xffff0000 0x0000001d
+    kern/init/init.c:68: grade_backtrace0+23
+ebp:0xc012afc8   eip:0xc010014e arg :0xc010c03c 0xc010c020 0x000031b8 0x00000000
+    kern/init/init.c:73: grade_backtrace+34
+ebp:0xc012aff8   eip:0xc010008b arg :0xc010c234 0xc010c23c 0xc0100e25 0xc010c25b
+    kern/init/init.c:33: kern_init+84
+memory management: default_pmm_manager
+e820map:
+  memory: 0009fc00, [00000000, 0009fbff], type = 1.
+  memory: 00000400, [0009fc00, 0009ffff], type = 2.
+  memory: 00010000, [000f0000, 000fffff], type = 2.
+  memory: 07ee0000, [00100000, 07fdffff], type = 1.
+  memory: 00020000, [07fe0000, 07ffffff], type = 2.
+  memory: 00040000, [fffc0000, ffffffff], type = 2.
+check_alloc_page() succeeded!
+check_pgdir() succeeded!
+check_boot_pgdir() succeeded!
+-------------------- BEGIN --------------------
+PDE(0e0) c0000000-f8000000 38000000 urw
+  |-- PTE(38000) c0000000-f8000000 38000000 -rw
+PDE(001) fac00000-fb000000 00400000 -rw
+  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw
+  |-- PTE(00001) fafeb000-fafec000 00001000 -rw
+--------------------- END ---------------------
+use SLOB allocator
+kmalloc_init() succeeded!
+check_vma_struct() succeeded!
+page fault at 0x00000100: K/W [no page found].
+check_pgfault() succeeded!
+check_vmm() succeeded.
+ide 0:      10000(sectors), 'QEMU HARDDISK'.
+ide 1:     262144(sectors), 'QEMU HARDDISK'.
+SWAP: manager = fifo swap manager
+BEGIN check_swap: count 1, total 31835
+setup Page Table for vaddr 0X1000, so alloc a page
+setup Page Table vaddr 0~4MB OVER!
+set up init env for check_swap begin!
+page fault at 0x00001000: K/W [no page found].
+page fault at 0x00002000: K/W [no page found].
+page fault at 0x00003000: K/W [no page found].
+page fault at 0x00004000: K/W [no page found].
+set up init env for check_swap over!
+write Virt Page c in fifo_check_swap
+write Virt Page a in fifo_check_swap
+write Virt Page d in fifo_check_swap
+write Virt Page b in fifo_check_swap
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+write Virt Page b in fifo_check_swap
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+write Virt Page b in fifo_check_swap
+page fault at 0x00002000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x3000 to disk swap entry 4
+swap_in: load disk swap entry 3 with swap_page in vadr 0x2000
+write Virt Page c in fifo_check_swap
+page fault at 0x00003000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x4000 to disk swap entry 5
+swap_in: load disk swap entry 4 with swap_page in vadr 0x3000
+write Virt Page d in fifo_check_swap
+page fault at 0x00004000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x5000 to disk swap entry 6
+swap_in: load disk swap entry 5 with swap_page in vadr 0x4000
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+swap_in: load disk swap entry 6 with swap_page in vadr 0x5000
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/R [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+count is 0, total is 5
+check_swap() succeeded!
+++ setup timer interrupts
+kernel_execve: pid = 2, name = "divzero".
+trapframe at 0xc038bfb4
+  edi  0x00000000
+  esi  0x00000000
+  ebp  0xafffffa8
+  oesp 0xc038bfd4
+  ebx  0x00000000
+  edx  0x00000000
+  ecx  0x00000000
+  eax  0x00000001
+  ds   0x----0023
+  es   0x----0023
+  fs   0x----0000
+  gs   0x----0000
+  trap 0x00000000 Divide error
+  err  0x00000000
+  eip  0x00800f8f
+  cs   0x----001b
+  flag 0x00000286 PF,SF,IF,IOPL=0
+  esp  0xafffff90
+  ss   0x----0023
+unhandled trap.
+all user-mode processes have quit.
+init check memory pass.
+kernel panic at kern/process/proc.c:525:
+    initproc exit.
+
+stack trackback:
+ebp:0xc0384f88   eip:0xc0100ba9 arg :0xc010c0e8 0xc0384fcc 0x0000020d 0xc0384fb8
+    kern/debug/kdebug.c:351: print_stackframe+22
+ebp:0xc0384fb8   eip:0xc0100468 arg :0xc010e0cc 0x0000020d 0xc010e11e 0x00000000
+    kern/debug/panic.c:27: __panic+103
+ebp:0xc0384fe8   eip:0xc010a151 arg :0x00000000 0x00000000 0x00000000 0x00000010
+    kern/process/proc.c:525: do_exit+91
+Welcome to the kernel debug monitor!!
+Type 'help' for a list of commands.
+K> 
\ 文件尾没有换行符
diff -ruP /home/xmh/origin/ucore_os_lab/labcodes/lab5/.exit.log lab5/.exit.log
--- /home/xmh/origin/ucore_os_lab/labcodes/lab5/.exit.log	1970-01-01 00:00:00.000000000 +0000
+++ lab5/.exit.log	2020-05-24 07:22:43.042086489 +0000
@@ -0,0 +1,115 @@
+(THU.CST) os is loading ...
+
+Special kernel symbols:
+  entry  0xc0100036 (phys)
+  etext  0xc010c002 (phys)
+  edata  0xc019f000 (phys)
+  end    0xc01a21b8 (phys)
+Kernel executable memory footprint: 649KB
+ebp:0xc012af38   eip:0xc0100ba9 arg :0x00010094 0x00010094 0xc012af68 0xc01000df
+    kern/debug/kdebug.c:351: print_stackframe+22
+ebp:0xc012af48   eip:0xc0100e9d arg :0x00000000 0x00000000 0x00000000 0xc012afb8
+    kern/debug/kmonitor.c:129: mon_backtrace+10
+ebp:0xc012af68   eip:0xc01000df arg :0x00000000 0xc012af90 0xffff0000 0xc012af94
+    kern/init/init.c:58: grade_backtrace2+33
+ebp:0xc012af88   eip:0xc0100109 arg :0x00000000 0xffff0000 0xc012afb4 0x0000002a
+    kern/init/init.c:63: grade_backtrace1+38
+ebp:0xc012afa8   eip:0xc0100128 arg :0x00000000 0xc0100036 0xffff0000 0x0000001d
+    kern/init/init.c:68: grade_backtrace0+23
+ebp:0xc012afc8   eip:0xc010014e arg :0xc010c03c 0xc010c020 0x000031b8 0x00000000
+    kern/init/init.c:73: grade_backtrace+34
+ebp:0xc012aff8   eip:0xc010008b arg :0xc010c234 0xc010c23c 0xc0100e25 0xc010c25b
+    kern/init/init.c:33: kern_init+84
+memory management: default_pmm_manager
+e820map:
+  memory: 0009fc00, [00000000, 0009fbff], type = 1.
+  memory: 00000400, [0009fc00, 0009ffff], type = 2.
+  memory: 00010000, [000f0000, 000fffff], type = 2.
+  memory: 07ee0000, [00100000, 07fdffff], type = 1.
+  memory: 00020000, [07fe0000, 07ffffff], type = 2.
+  memory: 00040000, [fffc0000, ffffffff], type = 2.
+check_alloc_page() succeeded!
+check_pgdir() succeeded!
+check_boot_pgdir() succeeded!
+-------------------- BEGIN --------------------
+PDE(0e0) c0000000-f8000000 38000000 urw
+  |-- PTE(38000) c0000000-f8000000 38000000 -rw
+PDE(001) fac00000-fb000000 00400000 -rw
+  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw
+  |-- PTE(00001) fafeb000-fafec000 00001000 -rw
+--------------------- END ---------------------
+use SLOB allocator
+kmalloc_init() succeeded!
+check_vma_struct() succeeded!
+page fault at 0x00000100: K/W [no page found].
+check_pgfault() succeeded!
+check_vmm() succeeded.
+ide 0:      10000(sectors), 'QEMU HARDDISK'.
+ide 1:     262144(sectors), 'QEMU HARDDISK'.
+SWAP: manager = fifo swap manager
+BEGIN check_swap: count 1, total 31835
+setup Page Table for vaddr 0X1000, so alloc a page
+setup Page Table vaddr 0~4MB OVER!
+set up init env for check_swap begin!
+page fault at 0x00001000: K/W [no page found].
+page fault at 0x00002000: K/W [no page found].
+page fault at 0x00003000: K/W [no page found].
+page fault at 0x00004000: K/W [no page found].
+set up init env for check_swap over!
+write Virt Page c in fifo_check_swap
+write Virt Page a in fifo_check_swap
+write Virt Page d in fifo_check_swap
+write Virt Page b in fifo_check_swap
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+write Virt Page b in fifo_check_swap
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+write Virt Page b in fifo_check_swap
+page fault at 0x00002000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x3000 to disk swap entry 4
+swap_in: load disk swap entry 3 with swap_page in vadr 0x2000
+write Virt Page c in fifo_check_swap
+page fault at 0x00003000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x4000 to disk swap entry 5
+swap_in: load disk swap entry 4 with swap_page in vadr 0x3000
+write Virt Page d in fifo_check_swap
+page fault at 0x00004000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x5000 to disk swap entry 6
+swap_in: load disk swap entry 5 with swap_page in vadr 0x4000
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+swap_in: load disk swap entry 6 with swap_page in vadr 0x5000
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/R [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+count is 0, total is 5
+check_swap() succeeded!
+++ setup timer interrupts
+kernel_execve: pid = 2, name = "exit".
+I am the parent. Forking the child...
+I am parent, fork a child pid 3
+I am the parent, waiting now..
+I am the child.
+waitpid 3 ok.
+exit pass.
+all user-mode processes have quit.
+init check memory pass.
+kernel panic at kern/process/proc.c:525:
+    initproc exit.
+
+stack trackback:
+ebp:0xc0384f88   eip:0xc0100ba9 arg :0xc010c0e8 0xc0384fcc 0x0000020d 0xc0384fb8
+    kern/debug/kdebug.c:351: print_stackframe+22
+ebp:0xc0384fb8   eip:0xc0100468 arg :0xc010e0cc 0x0000020d 0xc010e11e 0x00000000
+    kern/debug/panic.c:27: __panic+103
+ebp:0xc0384fe8   eip:0xc010a151 arg :0x00000000 0x00000000 0x00000000 0x00000010
+    kern/process/proc.c:525: do_exit+91
+Welcome to the kernel debug monitor!!
+Type 'help' for a list of commands.
+K> 
\ 文件尾没有换行符
diff -ruP /home/xmh/origin/ucore_os_lab/labcodes/lab5/.faultreadkernel.log lab5/.faultreadkernel.log
--- /home/xmh/origin/ucore_os_lab/labcodes/lab5/.faultreadkernel.log	1970-01-01 00:00:00.000000000 +0000
+++ lab5/.faultreadkernel.log	2020-05-24 07:22:31.997908343 +0000
@@ -0,0 +1,135 @@
+(THU.CST) os is loading ...
+
+Special kernel symbols:
+  entry  0xc0100036 (phys)
+  etext  0xc010c002 (phys)
+  edata  0xc019f000 (phys)
+  end    0xc01a21b8 (phys)
+Kernel executable memory footprint: 649KB
+ebp:0xc012af38   eip:0xc0100ba9 arg :0x00010094 0x00010094 0xc012af68 0xc01000df
+    kern/debug/kdebug.c:351: print_stackframe+22
+ebp:0xc012af48   eip:0xc0100e9d arg :0x00000000 0x00000000 0x00000000 0xc012afb8
+    kern/debug/kmonitor.c:129: mon_backtrace+10
+ebp:0xc012af68   eip:0xc01000df arg :0x00000000 0xc012af90 0xffff0000 0xc012af94
+    kern/init/init.c:58: grade_backtrace2+33
+ebp:0xc012af88   eip:0xc0100109 arg :0x00000000 0xffff0000 0xc012afb4 0x0000002a
+    kern/init/init.c:63: grade_backtrace1+38
+ebp:0xc012afa8   eip:0xc0100128 arg :0x00000000 0xc0100036 0xffff0000 0x0000001d
+    kern/init/init.c:68: grade_backtrace0+23
+ebp:0xc012afc8   eip:0xc010014e arg :0xc010c03c 0xc010c020 0x000031b8 0x00000000
+    kern/init/init.c:73: grade_backtrace+34
+ebp:0xc012aff8   eip:0xc010008b arg :0xc010c234 0xc010c23c 0xc0100e25 0xc010c25b
+    kern/init/init.c:33: kern_init+84
+memory management: default_pmm_manager
+e820map:
+  memory: 0009fc00, [00000000, 0009fbff], type = 1.
+  memory: 00000400, [0009fc00, 0009ffff], type = 2.
+  memory: 00010000, [000f0000, 000fffff], type = 2.
+  memory: 07ee0000, [00100000, 07fdffff], type = 1.
+  memory: 00020000, [07fe0000, 07ffffff], type = 2.
+  memory: 00040000, [fffc0000, ffffffff], type = 2.
+check_alloc_page() succeeded!
+check_pgdir() succeeded!
+check_boot_pgdir() succeeded!
+-------------------- BEGIN --------------------
+PDE(0e0) c0000000-f8000000 38000000 urw
+  |-- PTE(38000) c0000000-f8000000 38000000 -rw
+PDE(001) fac00000-fb000000 00400000 -rw
+  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw
+  |-- PTE(00001) fafeb000-fafec000 00001000 -rw
+--------------------- END ---------------------
+use SLOB allocator
+kmalloc_init() succeeded!
+check_vma_struct() succeeded!
+page fault at 0x00000100: K/W [no page found].
+check_pgfault() succeeded!
+check_vmm() succeeded.
+ide 0:      10000(sectors), 'QEMU HARDDISK'.
+ide 1:     262144(sectors), 'QEMU HARDDISK'.
+SWAP: manager = fifo swap manager
+BEGIN check_swap: count 1, total 31835
+setup Page Table for vaddr 0X1000, so alloc a page
+setup Page Table vaddr 0~4MB OVER!
+set up init env for check_swap begin!
+page fault at 0x00001000: K/W [no page found].
+page fault at 0x00002000: K/W [no page found].
+page fault at 0x00003000: K/W [no page found].
+page fault at 0x00004000: K/W [no page found].
+set up init env for check_swap over!
+write Virt Page c in fifo_check_swap
+write Virt Page a in fifo_check_swap
+write Virt Page d in fifo_check_swap
+write Virt Page b in fifo_check_swap
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+write Virt Page b in fifo_check_swap
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+write Virt Page b in fifo_check_swap
+page fault at 0x00002000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x3000 to disk swap entry 4
+swap_in: load disk swap entry 3 with swap_page in vadr 0x2000
+write Virt Page c in fifo_check_swap
+page fault at 0x00003000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x4000 to disk swap entry 5
+swap_in: load disk swap entry 4 with swap_page in vadr 0x3000
+write Virt Page d in fifo_check_swap
+page fault at 0x00004000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x5000 to disk swap entry 6
+swap_in: load disk swap entry 5 with swap_page in vadr 0x4000
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+swap_in: load disk swap entry 6 with swap_page in vadr 0x5000
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/R [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+count is 0, total is 5
+check_swap() succeeded!
+++ setup timer interrupts
+kernel_execve: pid = 2, name = "faultreadkernel".
+not valid addr fac00000, and  can not find it in vma
+trapframe at 0xc038bfb4
+  edi  0x00000000
+  esi  0x00000000
+  ebp  0xafffffa8
+  oesp 0xc038bfd4
+  ebx  0x00000000
+  edx  0x00000000
+  ecx  0x00000000
+  eax  0xfac00000
+  ds   0x----0023
+  es   0x----0023
+  fs   0x----0000
+  gs   0x----0000
+  trap 0x0000000e Page Fault
+  err  0x00000005
+  eip  0x00800f88
+  cs   0x----001b
+  flag 0x00000286 PF,SF,IF,IOPL=0
+  esp  0xafffff90
+  ss   0x----0023
+killed by kernel.
+kernel panic at kern/trap/trap.c:253:
+    handle user mode pgfault failed. ret=-3
+
+stack trackback:
+ebp:0xc038bf08   eip:0xc0100ba9 arg :0xc010c0e8 0xc038bf4c 0x000000fd 0xc038bf50
+    kern/debug/kdebug.c:351: print_stackframe+22
+ebp:0xc038bf38   eip:0xc0100468 arg :0xc010c4ce 0x000000fd 0xc010c770 0xfffffffd
+    kern/debug/panic.c:27: __panic+103
+ebp:0xc038bf78   eip:0xc010293f arg :0xc038bfb4 0x00000000 0x0080026d 0x0000001b
+    kern/trap/trap.c:253: trap_dispatch+292
+ebp:0xc038bfa8   eip:0xc0102c12 arg :0xc038bfb4 0x00000000 0x00000000 0xafffffa8
+    kern/trap/trap.c:356: trap+74
+ebp:0xafffffa8   eip:0xc01036da arg :0x00000000 0x00000000 0x00000000 0x00000000
+    kern/trap/trapentry.S:24: <unknown>+0
+ebp:0xafffffd8   eip:0x00800350 arg :0x00000000 0x00000000 0x00000000 0x00000000
+    user/libs/umain.c:7: umain+10
+Welcome to the kernel debug monitor!!
+Type 'help' for a list of commands.
+K> 
\ 文件尾没有换行符
diff -ruP /home/xmh/origin/ucore_os_lab/labcodes/lab5/.faultread.log lab5/.faultread.log
--- /home/xmh/origin/ucore_os_lab/labcodes/lab5/.faultread.log	1970-01-01 00:00:00.000000000 +0000
+++ lab5/.faultread.log	2020-05-24 07:22:30.137878336 +0000
@@ -0,0 +1,135 @@
+(THU.CST) os is loading ...
+
+Special kernel symbols:
+  entry  0xc0100036 (phys)
+  etext  0xc010c002 (phys)
+  edata  0xc019f000 (phys)
+  end    0xc01a21b8 (phys)
+Kernel executable memory footprint: 649KB
+ebp:0xc012af38   eip:0xc0100ba9 arg :0x00010094 0x00010094 0xc012af68 0xc01000df
+    kern/debug/kdebug.c:351: print_stackframe+22
+ebp:0xc012af48   eip:0xc0100e9d arg :0x00000000 0x00000000 0x00000000 0xc012afb8
+    kern/debug/kmonitor.c:129: mon_backtrace+10
+ebp:0xc012af68   eip:0xc01000df arg :0x00000000 0xc012af90 0xffff0000 0xc012af94
+    kern/init/init.c:58: grade_backtrace2+33
+ebp:0xc012af88   eip:0xc0100109 arg :0x00000000 0xffff0000 0xc012afb4 0x0000002a
+    kern/init/init.c:63: grade_backtrace1+38
+ebp:0xc012afa8   eip:0xc0100128 arg :0x00000000 0xc0100036 0xffff0000 0x0000001d
+    kern/init/init.c:68: grade_backtrace0+23
+ebp:0xc012afc8   eip:0xc010014e arg :0xc010c03c 0xc010c020 0x000031b8 0x00000000
+    kern/init/init.c:73: grade_backtrace+34
+ebp:0xc012aff8   eip:0xc010008b arg :0xc010c234 0xc010c23c 0xc0100e25 0xc010c25b
+    kern/init/init.c:33: kern_init+84
+memory management: default_pmm_manager
+e820map:
+  memory: 0009fc00, [00000000, 0009fbff], type = 1.
+  memory: 00000400, [0009fc00, 0009ffff], type = 2.
+  memory: 00010000, [000f0000, 000fffff], type = 2.
+  memory: 07ee0000, [00100000, 07fdffff], type = 1.
+  memory: 00020000, [07fe0000, 07ffffff], type = 2.
+  memory: 00040000, [fffc0000, ffffffff], type = 2.
+check_alloc_page() succeeded!
+check_pgdir() succeeded!
+check_boot_pgdir() succeeded!
+-------------------- BEGIN --------------------
+PDE(0e0) c0000000-f8000000 38000000 urw
+  |-- PTE(38000) c0000000-f8000000 38000000 -rw
+PDE(001) fac00000-fb000000 00400000 -rw
+  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw
+  |-- PTE(00001) fafeb000-fafec000 00001000 -rw
+--------------------- END ---------------------
+use SLOB allocator
+kmalloc_init() succeeded!
+check_vma_struct() succeeded!
+page fault at 0x00000100: K/W [no page found].
+check_pgfault() succeeded!
+check_vmm() succeeded.
+ide 0:      10000(sectors), 'QEMU HARDDISK'.
+ide 1:     262144(sectors), 'QEMU HARDDISK'.
+SWAP: manager = fifo swap manager
+BEGIN check_swap: count 1, total 31835
+setup Page Table for vaddr 0X1000, so alloc a page
+setup Page Table vaddr 0~4MB OVER!
+set up init env for check_swap begin!
+page fault at 0x00001000: K/W [no page found].
+page fault at 0x00002000: K/W [no page found].
+page fault at 0x00003000: K/W [no page found].
+page fault at 0x00004000: K/W [no page found].
+set up init env for check_swap over!
+write Virt Page c in fifo_check_swap
+write Virt Page a in fifo_check_swap
+write Virt Page d in fifo_check_swap
+write Virt Page b in fifo_check_swap
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+write Virt Page b in fifo_check_swap
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+write Virt Page b in fifo_check_swap
+page fault at 0x00002000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x3000 to disk swap entry 4
+swap_in: load disk swap entry 3 with swap_page in vadr 0x2000
+write Virt Page c in fifo_check_swap
+page fault at 0x00003000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x4000 to disk swap entry 5
+swap_in: load disk swap entry 4 with swap_page in vadr 0x3000
+write Virt Page d in fifo_check_swap
+page fault at 0x00004000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x5000 to disk swap entry 6
+swap_in: load disk swap entry 5 with swap_page in vadr 0x4000
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+swap_in: load disk swap entry 6 with swap_page in vadr 0x5000
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/R [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+count is 0, total is 5
+check_swap() succeeded!
+++ setup timer interrupts
+kernel_execve: pid = 2, name = "faultread".
+not valid addr 0, and  can not find it in vma
+trapframe at 0xc038bfb4
+  edi  0x00000000
+  esi  0x00000000
+  ebp  0xafffffa8
+  oesp 0xc038bfd4
+  ebx  0x00000000
+  edx  0x00000000
+  ecx  0x00000000
+  eax  0x00000000
+  ds   0x----0023
+  es   0x----0023
+  fs   0x----0000
+  gs   0x----0000
+  trap 0x0000000e Page Fault
+  err  0x00000004
+  eip  0x00800f88
+  cs   0x----001b
+  flag 0x00000286 PF,SF,IF,IOPL=0
+  esp  0xafffff90
+  ss   0x----0023
+killed by kernel.
+kernel panic at kern/trap/trap.c:253:
+    handle user mode pgfault failed. ret=-3
+
+stack trackback:
+ebp:0xc038bf08   eip:0xc0100ba9 arg :0xc010c0e8 0xc038bf4c 0x000000fd 0xc038bf50
+    kern/debug/kdebug.c:351: print_stackframe+22
+ebp:0xc038bf38   eip:0xc0100468 arg :0xc010c4ce 0x000000fd 0xc010c770 0xfffffffd
+    kern/debug/panic.c:27: __panic+103
+ebp:0xc038bf78   eip:0xc010293f arg :0xc038bfb4 0x00000000 0x0080026d 0x0000001b
+    kern/trap/trap.c:253: trap_dispatch+292
+ebp:0xc038bfa8   eip:0xc0102c12 arg :0xc038bfb4 0x00000000 0x00000000 0xafffffa8
+    kern/trap/trap.c:356: trap+74
+ebp:0xafffffa8   eip:0xc01036da arg :0x00000000 0x00000000 0x00000000 0x00000000
+    kern/trap/trapentry.S:24: <unknown>+0
+ebp:0xafffffd8   eip:0x00800350 arg :0x00000000 0x00000000 0x00000000 0x00000000
+    user/libs/umain.c:7: umain+10
+Welcome to the kernel debug monitor!!
+Type 'help' for a list of commands.
+K> 
\ 文件尾没有换行符
diff -ruP /home/xmh/origin/ucore_os_lab/labcodes/lab5/.forktest.log lab5/.forktest.log
--- /home/xmh/origin/ucore_os_lab/labcodes/lab5/.forktest.log	1970-01-01 00:00:00.000000000 +0000
+++ lab5/.forktest.log	2020-05-24 07:23:03.562417373 +0000
@@ -0,0 +1,142 @@
+(THU.CST) os is loading ...
+
+Special kernel symbols:
+  entry  0xc0100036 (phys)
+  etext  0xc010c002 (phys)
+  edata  0xc019f000 (phys)
+  end    0xc01a21b8 (phys)
+Kernel executable memory footprint: 649KB
+ebp:0xc012af38   eip:0xc0100ba9 arg :0x00010094 0x00010094 0xc012af68 0xc01000df
+    kern/debug/kdebug.c:351: print_stackframe+22
+ebp:0xc012af48   eip:0xc0100e9d arg :0x00000000 0x00000000 0x00000000 0xc012afb8
+    kern/debug/kmonitor.c:129: mon_backtrace+10
+ebp:0xc012af68   eip:0xc01000df arg :0x00000000 0xc012af90 0xffff0000 0xc012af94
+    kern/init/init.c:58: grade_backtrace2+33
+ebp:0xc012af88   eip:0xc0100109 arg :0x00000000 0xffff0000 0xc012afb4 0x0000002a
+    kern/init/init.c:63: grade_backtrace1+38
+ebp:0xc012afa8   eip:0xc0100128 arg :0x00000000 0xc0100036 0xffff0000 0x0000001d
+    kern/init/init.c:68: grade_backtrace0+23
+ebp:0xc012afc8   eip:0xc010014e arg :0xc010c03c 0xc010c020 0x000031b8 0x00000000
+    kern/init/init.c:73: grade_backtrace+34
+ebp:0xc012aff8   eip:0xc010008b arg :0xc010c234 0xc010c23c 0xc0100e25 0xc010c25b
+    kern/init/init.c:33: kern_init+84
+memory management: default_pmm_manager
+e820map:
+  memory: 0009fc00, [00000000, 0009fbff], type = 1.
+  memory: 00000400, [0009fc00, 0009ffff], type = 2.
+  memory: 00010000, [000f0000, 000fffff], type = 2.
+  memory: 07ee0000, [00100000, 07fdffff], type = 1.
+  memory: 00020000, [07fe0000, 07ffffff], type = 2.
+  memory: 00040000, [fffc0000, ffffffff], type = 2.
+check_alloc_page() succeeded!
+check_pgdir() succeeded!
+check_boot_pgdir() succeeded!
+-------------------- BEGIN --------------------
+PDE(0e0) c0000000-f8000000 38000000 urw
+  |-- PTE(38000) c0000000-f8000000 38000000 -rw
+PDE(001) fac00000-fb000000 00400000 -rw
+  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw
+  |-- PTE(00001) fafeb000-fafec000 00001000 -rw
+--------------------- END ---------------------
+use SLOB allocator
+kmalloc_init() succeeded!
+check_vma_struct() succeeded!
+page fault at 0x00000100: K/W [no page found].
+check_pgfault() succeeded!
+check_vmm() succeeded.
+ide 0:      10000(sectors), 'QEMU HARDDISK'.
+ide 1:     262144(sectors), 'QEMU HARDDISK'.
+SWAP: manager = fifo swap manager
+BEGIN check_swap: count 1, total 31835
+setup Page Table for vaddr 0X1000, so alloc a page
+setup Page Table vaddr 0~4MB OVER!
+set up init env for check_swap begin!
+page fault at 0x00001000: K/W [no page found].
+page fault at 0x00002000: K/W [no page found].
+page fault at 0x00003000: K/W [no page found].
+page fault at 0x00004000: K/W [no page found].
+set up init env for check_swap over!
+write Virt Page c in fifo_check_swap
+write Virt Page a in fifo_check_swap
+write Virt Page d in fifo_check_swap
+write Virt Page b in fifo_check_swap
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+write Virt Page b in fifo_check_swap
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+write Virt Page b in fifo_check_swap
+page fault at 0x00002000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x3000 to disk swap entry 4
+swap_in: load disk swap entry 3 with swap_page in vadr 0x2000
+write Virt Page c in fifo_check_swap
+page fault at 0x00003000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x4000 to disk swap entry 5
+swap_in: load disk swap entry 4 with swap_page in vadr 0x3000
+write Virt Page d in fifo_check_swap
+page fault at 0x00004000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x5000 to disk swap entry 6
+swap_in: load disk swap entry 5 with swap_page in vadr 0x4000
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+swap_in: load disk swap entry 6 with swap_page in vadr 0x5000
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/R [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+count is 0, total is 5
+check_swap() succeeded!
+++ setup timer interrupts
+kernel_execve: pid = 2, name = "forktest".
+I am child 31
+I am child 30
+I am child 29
+I am child 28
+I am child 27
+I am child 26
+I am child 25
+I am child 24
+I am child 23
+I am child 22
+I am child 21
+I am child 20
+I am child 19
+I am child 18
+I am child 17
+I am child 16
+I am child 15
+I am child 14
+I am child 13
+I am child 12
+I am child 11
+I am child 10
+I am child 9
+I am child 8
+I am child 7
+I am child 6
+I am child 5
+I am child 4
+I am child 3
+I am child 2
+I am child 1
+I am child 0
+forktest pass.
+all user-mode processes have quit.
+init check memory pass.
+kernel panic at kern/process/proc.c:525:
+    initproc exit.
+
+stack trackback:
+ebp:0xc0384f88   eip:0xc0100ba9 arg :0xc010c0e8 0xc0384fcc 0x0000020d 0xc0384fb8
+    kern/debug/kdebug.c:351: print_stackframe+22
+ebp:0xc0384fb8   eip:0xc0100468 arg :0xc010e0cc 0x0000020d 0xc010e11e 0x00000000
+    kern/debug/panic.c:27: __panic+103
+ebp:0xc0384fe8   eip:0xc010a151 arg :0x00000000 0x00000000 0x00000000 0x00000010
+    kern/process/proc.c:525: do_exit+91
+Welcome to the kernel debug monitor!!
+Type 'help' for a list of commands.
+K> 
\ 文件尾没有换行符
diff -ruP /home/xmh/origin/ucore_os_lab/labcodes/lab5/.forktree.log lab5/.forktree.log
--- /home/xmh/origin/ucore_os_lab/labcodes/lab5/.forktree.log	1970-01-01 00:00:00.000000000 +0000
+++ lab5/.forktree.log	2020-05-24 07:23:05.422447358 +0000
@@ -0,0 +1,140 @@
+(THU.CST) os is loading ...
+
+Special kernel symbols:
+  entry  0xc0100036 (phys)
+  etext  0xc010c002 (phys)
+  edata  0xc019f000 (phys)
+  end    0xc01a21b8 (phys)
+Kernel executable memory footprint: 649KB
+ebp:0xc012af38   eip:0xc0100ba9 arg :0x00010094 0x00010094 0xc012af68 0xc01000df
+    kern/debug/kdebug.c:351: print_stackframe+22
+ebp:0xc012af48   eip:0xc0100e9d arg :0x00000000 0x00000000 0x00000000 0xc012afb8
+    kern/debug/kmonitor.c:129: mon_backtrace+10
+ebp:0xc012af68   eip:0xc01000df arg :0x00000000 0xc012af90 0xffff0000 0xc012af94
+    kern/init/init.c:58: grade_backtrace2+33
+ebp:0xc012af88   eip:0xc0100109 arg :0x00000000 0xffff0000 0xc012afb4 0x0000002a
+    kern/init/init.c:63: grade_backtrace1+38
+ebp:0xc012afa8   eip:0xc0100128 arg :0x00000000 0xc0100036 0xffff0000 0x0000001d
+    kern/init/init.c:68: grade_backtrace0+23
+ebp:0xc012afc8   eip:0xc010014e arg :0xc010c03c 0xc010c020 0x000031b8 0x00000000
+    kern/init/init.c:73: grade_backtrace+34
+ebp:0xc012aff8   eip:0xc010008b arg :0xc010c234 0xc010c23c 0xc0100e25 0xc010c25b
+    kern/init/init.c:33: kern_init+84
+memory management: default_pmm_manager
+e820map:
+  memory: 0009fc00, [00000000, 0009fbff], type = 1.
+  memory: 00000400, [0009fc00, 0009ffff], type = 2.
+  memory: 00010000, [000f0000, 000fffff], type = 2.
+  memory: 07ee0000, [00100000, 07fdffff], type = 1.
+  memory: 00020000, [07fe0000, 07ffffff], type = 2.
+  memory: 00040000, [fffc0000, ffffffff], type = 2.
+check_alloc_page() succeeded!
+check_pgdir() succeeded!
+check_boot_pgdir() succeeded!
+-------------------- BEGIN --------------------
+PDE(0e0) c0000000-f8000000 38000000 urw
+  |-- PTE(38000) c0000000-f8000000 38000000 -rw
+PDE(001) fac00000-fb000000 00400000 -rw
+  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw
+  |-- PTE(00001) fafeb000-fafec000 00001000 -rw
+--------------------- END ---------------------
+use SLOB allocator
+kmalloc_init() succeeded!
+check_vma_struct() succeeded!
+page fault at 0x00000100: K/W [no page found].
+check_pgfault() succeeded!
+check_vmm() succeeded.
+ide 0:      10000(sectors), 'QEMU HARDDISK'.
+ide 1:     262144(sectors), 'QEMU HARDDISK'.
+SWAP: manager = fifo swap manager
+BEGIN check_swap: count 1, total 31835
+setup Page Table for vaddr 0X1000, so alloc a page
+setup Page Table vaddr 0~4MB OVER!
+set up init env for check_swap begin!
+page fault at 0x00001000: K/W [no page found].
+page fault at 0x00002000: K/W [no page found].
+page fault at 0x00003000: K/W [no page found].
+page fault at 0x00004000: K/W [no page found].
+set up init env for check_swap over!
+write Virt Page c in fifo_check_swap
+write Virt Page a in fifo_check_swap
+write Virt Page d in fifo_check_swap
+write Virt Page b in fifo_check_swap
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+write Virt Page b in fifo_check_swap
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+write Virt Page b in fifo_check_swap
+page fault at 0x00002000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x3000 to disk swap entry 4
+swap_in: load disk swap entry 3 with swap_page in vadr 0x2000
+write Virt Page c in fifo_check_swap
+page fault at 0x00003000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x4000 to disk swap entry 5
+swap_in: load disk swap entry 4 with swap_page in vadr 0x3000
+write Virt Page d in fifo_check_swap
+page fault at 0x00004000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x5000 to disk swap entry 6
+swap_in: load disk swap entry 5 with swap_page in vadr 0x4000
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+swap_in: load disk swap entry 6 with swap_page in vadr 0x5000
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/R [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+count is 0, total is 5
+check_swap() succeeded!
+++ setup timer interrupts
+kernel_execve: pid = 2, name = "forktree".
+0002: I am ''
+0004: I am '1'
+0003: I am '0'
+0008: I am '01'
+0007: I am '00'
+0006: I am '11'
+0005: I am '10'
+0010: I am '101'
+000f: I am '100'
+000e: I am '111'
+000d: I am '110'
+000c: I am '001'
+000b: I am '000'
+000a: I am '011'
+0009: I am '010'
+0020: I am '0101'
+001f: I am '0100'
+001e: I am '0111'
+001d: I am '0110'
+001c: I am '0001'
+001b: I am '0000'
+001a: I am '0011'
+0019: I am '0010'
+0018: I am '1101'
+0017: I am '1100'
+0016: I am '1111'
+0015: I am '1110'
+0014: I am '1001'
+0013: I am '1000'
+0012: I am '1011'
+0011: I am '1010'
+all user-mode processes have quit.
+init check memory pass.
+kernel panic at kern/process/proc.c:525:
+    initproc exit.
+
+stack trackback:
+ebp:0xc0384f88   eip:0xc0100ba9 arg :0xc010c0e8 0xc0384fcc 0x0000020d 0xc0384fb8
+    kern/debug/kdebug.c:351: print_stackframe+22
+ebp:0xc0384fb8   eip:0xc0100468 arg :0xc010e0cc 0x0000020d 0xc010e11e 0x00000000
+    kern/debug/panic.c:27: __panic+103
+ebp:0xc0384fe8   eip:0xc010a151 arg :0x00000000 0x00000000 0x00000000 0x00000010
+    kern/process/proc.c:525: do_exit+91
+Welcome to the kernel debug monitor!!
+Type 'help' for a list of commands.
+K> 
\ 文件尾没有换行符
diff -ruP /home/xmh/origin/ucore_os_lab/labcodes/lab5/.hello.log lab5/.hello.log
--- /home/xmh/origin/ucore_os_lab/labcodes/lab5/.hello.log	1970-01-01 00:00:00.000000000 +0000
+++ lab5/.hello.log	2020-05-24 07:22:33.805937510 +0000
@@ -0,0 +1,112 @@
+(THU.CST) os is loading ...
+
+Special kernel symbols:
+  entry  0xc0100036 (phys)
+  etext  0xc010c002 (phys)
+  edata  0xc019f000 (phys)
+  end    0xc01a21b8 (phys)
+Kernel executable memory footprint: 649KB
+ebp:0xc012af38   eip:0xc0100ba9 arg :0x00010094 0x00010094 0xc012af68 0xc01000df
+    kern/debug/kdebug.c:351: print_stackframe+22
+ebp:0xc012af48   eip:0xc0100e9d arg :0x00000000 0x00000000 0x00000000 0xc012afb8
+    kern/debug/kmonitor.c:129: mon_backtrace+10
+ebp:0xc012af68   eip:0xc01000df arg :0x00000000 0xc012af90 0xffff0000 0xc012af94
+    kern/init/init.c:58: grade_backtrace2+33
+ebp:0xc012af88   eip:0xc0100109 arg :0x00000000 0xffff0000 0xc012afb4 0x0000002a
+    kern/init/init.c:63: grade_backtrace1+38
+ebp:0xc012afa8   eip:0xc0100128 arg :0x00000000 0xc0100036 0xffff0000 0x0000001d
+    kern/init/init.c:68: grade_backtrace0+23
+ebp:0xc012afc8   eip:0xc010014e arg :0xc010c03c 0xc010c020 0x000031b8 0x00000000
+    kern/init/init.c:73: grade_backtrace+34
+ebp:0xc012aff8   eip:0xc010008b arg :0xc010c234 0xc010c23c 0xc0100e25 0xc010c25b
+    kern/init/init.c:33: kern_init+84
+memory management: default_pmm_manager
+e820map:
+  memory: 0009fc00, [00000000, 0009fbff], type = 1.
+  memory: 00000400, [0009fc00, 0009ffff], type = 2.
+  memory: 00010000, [000f0000, 000fffff], type = 2.
+  memory: 07ee0000, [00100000, 07fdffff], type = 1.
+  memory: 00020000, [07fe0000, 07ffffff], type = 2.
+  memory: 00040000, [fffc0000, ffffffff], type = 2.
+check_alloc_page() succeeded!
+check_pgdir() succeeded!
+check_boot_pgdir() succeeded!
+-------------------- BEGIN --------------------
+PDE(0e0) c0000000-f8000000 38000000 urw
+  |-- PTE(38000) c0000000-f8000000 38000000 -rw
+PDE(001) fac00000-fb000000 00400000 -rw
+  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw
+  |-- PTE(00001) fafeb000-fafec000 00001000 -rw
+--------------------- END ---------------------
+use SLOB allocator
+kmalloc_init() succeeded!
+check_vma_struct() succeeded!
+page fault at 0x00000100: K/W [no page found].
+check_pgfault() succeeded!
+check_vmm() succeeded.
+ide 0:      10000(sectors), 'QEMU HARDDISK'.
+ide 1:     262144(sectors), 'QEMU HARDDISK'.
+SWAP: manager = fifo swap manager
+BEGIN check_swap: count 1, total 31835
+setup Page Table for vaddr 0X1000, so alloc a page
+setup Page Table vaddr 0~4MB OVER!
+set up init env for check_swap begin!
+page fault at 0x00001000: K/W [no page found].
+page fault at 0x00002000: K/W [no page found].
+page fault at 0x00003000: K/W [no page found].
+page fault at 0x00004000: K/W [no page found].
+set up init env for check_swap over!
+write Virt Page c in fifo_check_swap
+write Virt Page a in fifo_check_swap
+write Virt Page d in fifo_check_swap
+write Virt Page b in fifo_check_swap
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+write Virt Page b in fifo_check_swap
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+write Virt Page b in fifo_check_swap
+page fault at 0x00002000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x3000 to disk swap entry 4
+swap_in: load disk swap entry 3 with swap_page in vadr 0x2000
+write Virt Page c in fifo_check_swap
+page fault at 0x00003000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x4000 to disk swap entry 5
+swap_in: load disk swap entry 4 with swap_page in vadr 0x3000
+write Virt Page d in fifo_check_swap
+page fault at 0x00004000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x5000 to disk swap entry 6
+swap_in: load disk swap entry 5 with swap_page in vadr 0x4000
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+swap_in: load disk swap entry 6 with swap_page in vadr 0x5000
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/R [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+count is 0, total is 5
+check_swap() succeeded!
+++ setup timer interrupts
+kernel_execve: pid = 2, name = "hello".
+Hello world!!.
+I am process 2.
+hello pass.
+all user-mode processes have quit.
+init check memory pass.
+kernel panic at kern/process/proc.c:525:
+    initproc exit.
+
+stack trackback:
+ebp:0xc0384f88   eip:0xc0100ba9 arg :0xc010c0e8 0xc0384fcc 0x0000020d 0xc0384fb8
+    kern/debug/kdebug.c:351: print_stackframe+22
+ebp:0xc0384fb8   eip:0xc0100468 arg :0xc010e0cc 0x0000020d 0xc010e11e 0x00000000
+    kern/debug/panic.c:27: __panic+103
+ebp:0xc0384fe8   eip:0xc010a151 arg :0x00000000 0x00000000 0x00000000 0x00000010
+    kern/process/proc.c:525: do_exit+91
+Welcome to the kernel debug monitor!!
+Type 'help' for a list of commands.
+K> 
\ 文件尾没有换行符
diff -ruP /home/xmh/origin/ucore_os_lab/labcodes/lab5/kern/debug/kdebug.c lab5/kern/debug/kdebug.c
--- /home/xmh/origin/ucore_os_lab/labcodes/lab5/kern/debug/kdebug.c	2020-05-24 07:28:36.514368823 +0000
+++ lab5/kern/debug/kdebug.c	2020-05-24 04:46:26.057832502 +0000
@@ -347,5 +347,18 @@
       *           NOTICE: the calling funciton's return addr eip  = ss:[ebp+4]
       *                   the calling funciton's ebp = ss:[ebp]
       */
+    uint32_t ebp = read_ebp();
+    uint32_t eip = read_eip();
+    for (int i = 0; i < STACKFRAME_DEPTH && ebp != 0; i++)
+    {
+        cprintf("ebp:0x%08x   eip:0x%08x ", ebp, eip);
+        uint32_t *tmp = (uint32_t *)ebp + 2;
+        cprintf("arg :0x%08x 0x%08x 0x%08x 0x%08x", *(tmp + 0), *(tmp + 1), *(tmp + 2), *(tmp + 3));
+        cprintf("\n");
+        print_debuginfo(eip - 1);
+        eip = ((uint32_t *)ebp)[1];
+        ebp = ((uint32_t *)ebp)[0];
+    }
 }
 
+
diff -ruP /home/xmh/origin/ucore_os_lab/labcodes/lab5/kern/mm/default_pmm.c lab5/kern/mm/default_pmm.c
--- /home/xmh/origin/ucore_os_lab/labcodes/lab5/kern/mm/default_pmm.c	2020-05-24 07:28:36.514368823 +0000
+++ lab5/kern/mm/default_pmm.c	2020-05-24 04:46:26.061832571 +0000
@@ -99,16 +99,19 @@
 #define nr_free (free_area.nr_free)
 
 static void
-default_init(void) {
+default_init(void)
+{
     list_init(&free_list);
     nr_free = 0;
 }
 
 static void
-default_init_memmap(struct Page *base, size_t n) {
+default_init_memmap(struct Page *base, size_t n)
+{
     assert(n > 0);
     struct Page *p = base;
-    for (; p != base + n; p ++) {
+    for (; p != base + n; p++)
+    {
         assert(PageReserved(p));
         p->flags = p->property = 0;
         set_page_ref(p, 0);
@@ -120,27 +123,34 @@
 }
 
 static struct Page *
-default_alloc_pages(size_t n) {
+default_alloc_pages(size_t n)
+{
     assert(n > 0);
-    if (n > nr_free) {
+    if (n > nr_free)
+    {
         return NULL;
     }
     struct Page *page = NULL;
     list_entry_t *le = &free_list;
-    while ((le = list_next(le)) != &free_list) {
+    while ((le = list_next(le)) != &free_list)
+    {
         struct Page *p = le2page(le, page_link);
-        if (p->property >= n) {
+        if (p->property >= n)
+        {
             page = p;
             break;
         }
     }
-    if (page != NULL) {
-        list_del(&(page->page_link));
-        if (page->property > n) {
+    if (page != NULL)
+    {
+        if (page->property > n)
+        {
             struct Page *p = page + n;
             p->property = page->property - n;
-            list_add(&free_list, &(p->page_link));
-    }
+            SetPageProperty(p);
+            list_add_after(&(page->page_link), &(p->page_link));
+        }
+        list_del(&(page->page_link));
         nr_free -= n;
         ClearPageProperty(page);
     }
@@ -148,10 +158,12 @@
 }
 
 static void
-default_free_pages(struct Page *base, size_t n) {
+default_free_pages(struct Page *base, size_t n)
+{
     assert(n > 0);
     struct Page *p = base;
-    for (; p != base + n; p ++) {
+    for (; p != base + n; p++)
+    {
         assert(!PageReserved(p) && !PageProperty(p));
         p->flags = 0;
         set_page_ref(p, 0);
@@ -159,15 +171,18 @@
     base->property = n;
     SetPageProperty(base);
     list_entry_t *le = list_next(&free_list);
-    while (le != &free_list) {
+    while (le != &free_list)
+    {
         p = le2page(le, page_link);
         le = list_next(le);
-        if (base + base->property == p) {
+        if (base + base->property == p)
+        {
             base->property += p->property;
             ClearPageProperty(p);
             list_del(&(p->page_link));
         }
-        else if (p + p->property == base) {
+        else if (p + p->property == base)
+        {
             p->property += base->property;
             ClearPageProperty(base);
             base = p;
@@ -175,16 +190,24 @@
         }
     }
     nr_free += n;
-    list_add(&free_list, &(base->page_link));
+    for (le = list_next(&free_list); le != &free_list; le = list_next(le))
+    {
+        p = le2page(le, page_link);
+        if (base + base->property <= p)
+            break;
+    }
+    list_add_before(le, &(base->page_link));
 }
 
 static size_t
-default_nr_free_pages(void) {
+default_nr_free_pages(void)
+{
     return nr_free;
 }
 
 static void
-basic_check(void) {
+basic_check(void)
+{
     struct Page *p0, *p1, *p2;
     p0 = p1 = p2 = NULL;
     assert((p0 = alloc_page()) != NULL);
@@ -234,16 +257,18 @@
     free_page(p2);
 }
 
-// LAB2: below code is used to check the first fit allocation algorithm (your EXERCISE 1) 
+// LAB2: below code is used to check the first fit allocation algorithm (your EXERCISE 1)
 // NOTICE: You SHOULD NOT CHANGE basic_check, default_check functions!
 static void
-default_check(void) {
+default_check(void)
+{
     int count = 0, total = 0;
     list_entry_t *le = &free_list;
-    while ((le = list_next(le)) != &free_list) {
+    while ((le = list_next(le)) != &free_list)
+    {
         struct Page *p = le2page(le, page_link);
         assert(PageProperty(p));
-        count ++, total += p->property;
+        count++, total += p->property;
     }
     assert(total == nr_free_pages());
 
@@ -291,9 +316,10 @@
     free_pages(p0, 5);
 
     le = &free_list;
-    while ((le = list_next(le)) != &free_list) {
+    while ((le = list_next(le)) != &free_list)
+    {
         struct Page *p = le2page(le, page_link);
-        count --, total -= p->property;
+        count--, total -= p->property;
     }
     assert(count == 0);
     assert(total == 0);
@@ -308,4 +334,3 @@
     .nr_free_pages = default_nr_free_pages,
     .check = default_check,
 };
-
diff -ruP /home/xmh/origin/ucore_os_lab/labcodes/lab5/kern/mm/pmm.c lab5/kern/mm/pmm.c
--- /home/xmh/origin/ucore_os_lab/labcodes/lab5/kern/mm/pmm.c	2020-05-24 07:28:36.514368823 +0000
+++ lab5/kern/mm/pmm.c	2020-05-24 05:38:39.119806961 +0000
@@ -61,8 +61,8 @@
  * always available at virtual address PGADDR(PDX(VPT), PDX(VPT), 0), to which
  * vpd is set bellow.
  * */
-pte_t * const vpt = (pte_t *)VPT;
-pde_t * const vpd = (pde_t *)PGADDR(PDX(VPT), PDX(VPT), 0);
+pte_t *const vpt = (pte_t *)VPT;
+pde_t *const vpd = (pde_t *)PGADDR(PDX(VPT), PDX(VPT), 0);
 
 /* *
  * Global Descriptor Table:
@@ -83,12 +83,11 @@
     [SEG_KDATA] = SEG(STA_W, 0x0, 0xFFFFFFFF, DPL_KERNEL),
     [SEG_UTEXT] = SEG(STA_X | STA_R, 0x0, 0xFFFFFFFF, DPL_USER),
     [SEG_UDATA] = SEG(STA_W, 0x0, 0xFFFFFFFF, DPL_USER),
-    [SEG_TSS]   = SEG_NULL,
+    [SEG_TSS] = SEG_NULL,
 };
 
 static struct pseudodesc gdt_pd = {
-    sizeof(gdt) - 1, (uintptr_t)gdt
-};
+    sizeof(gdt) - 1, (uintptr_t)gdt};
 
 static void check_alloc_page(void);
 static void check_pgdir(void);
@@ -99,15 +98,16 @@
  * data/code segement registers for kernel.
  * */
 static inline void
-lgdt(struct pseudodesc *pd) {
-    asm volatile ("lgdt (%0)" :: "r" (pd));
-    asm volatile ("movw %%ax, %%gs" :: "a" (USER_DS));
-    asm volatile ("movw %%ax, %%fs" :: "a" (USER_DS));
-    asm volatile ("movw %%ax, %%es" :: "a" (KERNEL_DS));
-    asm volatile ("movw %%ax, %%ds" :: "a" (KERNEL_DS));
-    asm volatile ("movw %%ax, %%ss" :: "a" (KERNEL_DS));
+lgdt(struct pseudodesc *pd)
+{
+    asm volatile("lgdt (%0)" ::"r"(pd));
+    asm volatile("movw %%ax, %%gs" ::"a"(USER_DS));
+    asm volatile("movw %%ax, %%fs" ::"a"(USER_DS));
+    asm volatile("movw %%ax, %%es" ::"a"(KERNEL_DS));
+    asm volatile("movw %%ax, %%ds" ::"a"(KERNEL_DS));
+    asm volatile("movw %%ax, %%ss" ::"a"(KERNEL_DS));
     // reload cs
-    asm volatile ("ljmp %0, $1f\n 1:\n" :: "i" (KERNEL_CS));
+    asm volatile("ljmp %0, $1f\n 1:\n" ::"i"(KERNEL_CS));
 }
 
 /* *
@@ -115,14 +115,15 @@
  * so that we can use different kernel stack when we trap frame
  * user to kernel.
  * */
-void
-load_esp0(uintptr_t esp0) {
+void load_esp0(uintptr_t esp0)
+{
     ts.ts_esp0 = esp0;
 }
 
 /* gdt_init - initialize the default GDT and TSS */
 static void
-gdt_init(void) {
+gdt_init(void)
+{
     // set boot kernel stack and default SS0
     load_esp0((uintptr_t)bootstacktop);
     ts.ts_ss0 = KERNEL_DS;
@@ -139,45 +140,49 @@
 
 //init_pmm_manager - initialize a pmm_manager instance
 static void
-init_pmm_manager(void) {
+init_pmm_manager(void)
+{
     pmm_manager = &default_pmm_manager;
     cprintf("memory management: %s\n", pmm_manager->name);
     pmm_manager->init();
 }
 
-//init_memmap - call pmm->init_memmap to build Page struct for free memory  
+//init_memmap - call pmm->init_memmap to build Page struct for free memory
 static void
-init_memmap(struct Page *base, size_t n) {
+init_memmap(struct Page *base, size_t n)
+{
     pmm_manager->init_memmap(base, n);
 }
 
-//alloc_pages - call pmm->alloc_pages to allocate a continuous n*PAGESIZE memory 
+//alloc_pages - call pmm->alloc_pages to allocate a continuous n*PAGESIZE memory
 struct Page *
-alloc_pages(size_t n) {
-    struct Page *page=NULL;
+alloc_pages(size_t n)
+{
+    struct Page *page = NULL;
     bool intr_flag;
-    
+
     while (1)
     {
-         local_intr_save(intr_flag);
-         {
-              page = pmm_manager->alloc_pages(n);
-         }
-         local_intr_restore(intr_flag);
-
-         if (page != NULL || n > 1 || swap_init_ok == 0) break;
-         
-         extern struct mm_struct *check_mm_struct;
-         //cprintf("page %x, call swap_out in alloc_pages %d\n",page, n);
-         swap_out(check_mm_struct, n, 0);
+        local_intr_save(intr_flag);
+        {
+            page = pmm_manager->alloc_pages(n);
+        }
+        local_intr_restore(intr_flag);
+
+        if (page != NULL || n > 1 || swap_init_ok == 0)
+            break;
+
+        extern struct mm_struct *check_mm_struct;
+        //cprintf("page %x, call swap_out in alloc_pages %d\n",page, n);
+        swap_out(check_mm_struct, n, 0);
     }
     //cprintf("n %d,get page %x, No %d in alloc_pages\n",n,page,(page-pages));
     return page;
 }
 
-//free_pages - call pmm->free_pages to free a continuous n*PAGESIZE memory 
-void
-free_pages(struct Page *base, size_t n) {
+//free_pages - call pmm->free_pages to free a continuous n*PAGESIZE memory
+void free_pages(struct Page *base, size_t n)
+{
     bool intr_flag;
     local_intr_save(intr_flag);
     {
@@ -186,10 +191,11 @@
     local_intr_restore(intr_flag);
 }
 
-//nr_free_pages - call pmm->nr_free_pages to get the size (nr*PAGESIZE) 
+//nr_free_pages - call pmm->nr_free_pages to get the size (nr*PAGESIZE)
 //of current free memory
 size_t
-nr_free_pages(void) {
+nr_free_pages(void)
+{
     size_t ret;
     bool intr_flag;
     local_intr_save(intr_flag);
@@ -202,23 +208,28 @@
 
 /* pmm_init - initialize the physical memory management */
 static void
-page_init(void) {
+page_init(void)
+{
     struct e820map *memmap = (struct e820map *)(0x8000 + KERNBASE);
     uint64_t maxpa = 0;
 
     cprintf("e820map:\n");
     int i;
-    for (i = 0; i < memmap->nr_map; i ++) {
+    for (i = 0; i < memmap->nr_map; i++)
+    {
         uint64_t begin = memmap->map[i].addr, end = begin + memmap->map[i].size;
         cprintf("  memory: %08llx, [%08llx, %08llx], type = %d.\n",
                 memmap->map[i].size, begin, end - 1, memmap->map[i].type);
-        if (memmap->map[i].type == E820_ARM) {
-            if (maxpa < end && begin < KMEMSIZE) {
+        if (memmap->map[i].type == E820_ARM)
+        {
+            if (maxpa < end && begin < KMEMSIZE)
+            {
                 maxpa = end;
             }
         }
     }
-    if (maxpa > KMEMSIZE) {
+    if (maxpa > KMEMSIZE)
+    {
         maxpa = KMEMSIZE;
     }
 
@@ -227,25 +238,32 @@
     npage = maxpa / PGSIZE;
     pages = (struct Page *)ROUNDUP((void *)end, PGSIZE);
 
-    for (i = 0; i < npage; i ++) {
+    for (i = 0; i < npage; i++)
+    {
         SetPageReserved(pages + i);
     }
 
     uintptr_t freemem = PADDR((uintptr_t)pages + sizeof(struct Page) * npage);
 
-    for (i = 0; i < memmap->nr_map; i ++) {
+    for (i = 0; i < memmap->nr_map; i++)
+    {
         uint64_t begin = memmap->map[i].addr, end = begin + memmap->map[i].size;
-        if (memmap->map[i].type == E820_ARM) {
-            if (begin < freemem) {
+        if (memmap->map[i].type == E820_ARM)
+        {
+            if (begin < freemem)
+            {
                 begin = freemem;
             }
-            if (end > KMEMSIZE) {
+            if (end > KMEMSIZE)
+            {
                 end = KMEMSIZE;
             }
-            if (begin < end) {
+            if (begin < end)
+            {
                 begin = ROUNDUP(begin, PGSIZE);
                 end = ROUNDDOWN(end, PGSIZE);
-                if (begin < end) {
+                if (begin < end)
+                {
                     init_memmap(pa2page(begin), (end - begin) / PGSIZE);
                 }
             }
@@ -258,43 +276,47 @@
 //  la:   linear address of this memory need to map (after x86 segment map)
 //  size: memory size
 //  pa:   physical address of this memory
-//  perm: permission of this memory  
+//  perm: permission of this memory
 static void
-boot_map_segment(pde_t *pgdir, uintptr_t la, size_t size, uintptr_t pa, uint32_t perm) {
+boot_map_segment(pde_t *pgdir, uintptr_t la, size_t size, uintptr_t pa, uint32_t perm)
+{
     assert(PGOFF(la) == PGOFF(pa));
     size_t n = ROUNDUP(size + PGOFF(la), PGSIZE) / PGSIZE;
     la = ROUNDDOWN(la, PGSIZE);
     pa = ROUNDDOWN(pa, PGSIZE);
-    for (; n > 0; n --, la += PGSIZE, pa += PGSIZE) {
+    for (; n > 0; n--, la += PGSIZE, pa += PGSIZE)
+    {
         pte_t *ptep = get_pte(pgdir, la, 1);
         assert(ptep != NULL);
         *ptep = pa | PTE_P | perm;
     }
 }
 
-//boot_alloc_page - allocate one page using pmm->alloc_pages(1) 
+//boot_alloc_page - allocate one page using pmm->alloc_pages(1)
 // return value: the kernel virtual address of this allocated page
 //note: this function is used to get the memory for PDT(Page Directory Table)&PT(Page Table)
 static void *
-boot_alloc_page(void) {
+boot_alloc_page(void)
+{
     struct Page *p = alloc_page();
-    if (p == NULL) {
+    if (p == NULL)
+    {
         panic("boot_alloc_page failed.\n");
     }
     return page2kva(p);
 }
 
-//pmm_init - setup a pmm to manage physical memory, build PDT&PT to setup paging mechanism 
+//pmm_init - setup a pmm to manage physical memory, build PDT&PT to setup paging mechanism
 //         - check the correctness of pmm & paging mechanism, print PDT&PT
-void
-pmm_init(void) {
+void pmm_init(void)
+{
     // We've already enabled paging
     boot_cr3 = PADDR(boot_pgdir);
 
-    //We need to alloc/free the physical memory (granularity is 4KB or other size). 
+    //We need to alloc/free the physical memory (granularity is 4KB or other size).
     //So a framework of physical memory manager (struct pmm_manager)is defined in pmm.h
     //First we should init a physical memory manager(pmm) based on the framework.
-    //Then pmm can alloc/free the physical memory. 
+    //Then pmm can alloc/free the physical memory.
     //Now the first_fit/best_fit/worst_fit/buddy_system pmm are available.
     init_pmm_manager();
 
@@ -328,9 +350,8 @@
     check_boot_pgdir();
 
     print_pgdir();
-    
-    kmalloc_init();
 
+    kmalloc_init();
 }
 
 //get_pte - get pte and return the kernel virtual address of this pte for la
@@ -341,7 +362,8 @@
 //  create: a logical value to decide if alloc a page for PT
 // return vaule: the kernel virtual address of this pte
 pte_t *
-get_pte(pde_t *pgdir, uintptr_t la, bool create) {
+get_pte(pde_t *pgdir, uintptr_t la, bool create)
+{
     /* LAB2 EXERCISE 2: YOUR CODE
      *
      * If you need to visit a physical address, please use KADDR()
@@ -375,16 +397,33 @@
     }
     return NULL;          // (8) return page table entry
 #endif
+    pde_t *pdep = &pgdir[PDX(la)];
+    if (!(*pdep & PTE_P))
+    {
+        struct Page *page;
+        if (!create || (page = alloc_page()) == NULL)
+        {
+            return NULL;
+        }
+        set_page_ref(page, 1);
+        uintptr_t pa = page2pa(page);
+        memset(KADDR(pa), 0, PGSIZE);
+        *pdep = pa | PTE_U | PTE_W | PTE_P;
+    }
+    return &((pte_t *)KADDR(PDE_ADDR(*pdep)))[PTX(la)];
 }
 
 //get_page - get related Page struct for linear address la using PDT pgdir
 struct Page *
-get_page(pde_t *pgdir, uintptr_t la, pte_t **ptep_store) {
+get_page(pde_t *pgdir, uintptr_t la, pte_t **ptep_store)
+{
     pte_t *ptep = get_pte(pgdir, la, 0);
-    if (ptep_store != NULL) {
+    if (ptep_store != NULL)
+    {
         *ptep_store = ptep;
     }
-    if (ptep != NULL && *ptep & PTE_P) {
+    if (ptep != NULL && *ptep & PTE_P)
+    {
         return pte2page(*ptep);
     }
     return NULL;
@@ -392,9 +431,10 @@
 
 //page_remove_pte - free an Page sturct which is related linear address la
 //                - and clean(invalidate) pte which is related linear address la
-//note: PT is changed, so the TLB need to be invalidate 
+//note: PT is changed, so the TLB need to be invalidate
 static inline void
-page_remove_pte(pde_t *pgdir, uintptr_t la, pte_t *ptep) {
+page_remove_pte(pde_t *pgdir, uintptr_t la, pte_t *ptep)
+{
     /* LAB2 EXERCISE 3: YOUR CODE
      *
      * Please check if ptep is valid, and tlb must be manually updated if mapping is updated
@@ -420,35 +460,50 @@
                                   //(6) flush tlb
     }
 #endif
+    if (*ptep & PTE_P)
+    {
+        struct Page *page = pte2page(*ptep);
+        if (page_ref_dec(page) == 0)
+        {
+            free_page(page);
+        }
+        *ptep = 0;
+        tlb_invalidate(pgdir, la);
+    }
 }
 
-void
-unmap_range(pde_t *pgdir, uintptr_t start, uintptr_t end) {
+void unmap_range(pde_t *pgdir, uintptr_t start, uintptr_t end)
+{
     assert(start % PGSIZE == 0 && end % PGSIZE == 0);
     assert(USER_ACCESS(start, end));
 
-    do {
+    do
+    {
         pte_t *ptep = get_pte(pgdir, start, 0);
-        if (ptep == NULL) {
+        if (ptep == NULL)
+        {
             start = ROUNDDOWN(start + PTSIZE, PTSIZE);
-            continue ;
+            continue;
         }
-        if (*ptep != 0) {
+        if (*ptep != 0)
+        {
             page_remove_pte(pgdir, start, ptep);
         }
         start += PGSIZE;
     } while (start != 0 && start < end);
 }
 
-void
-exit_range(pde_t *pgdir, uintptr_t start, uintptr_t end) {
+void exit_range(pde_t *pgdir, uintptr_t start, uintptr_t end)
+{
     assert(start % PGSIZE == 0 && end % PGSIZE == 0);
     assert(USER_ACCESS(start, end));
 
     start = ROUNDDOWN(start, PTSIZE);
-    do {
+    do
+    {
         int pde_idx = PDX(start);
-        if (pgdir[pde_idx] & PTE_P) {
+        if (pgdir[pde_idx] & PTE_P)
+        {
             free_page(pde2page(pgdir[pde_idx]));
             pgdir[pde_idx] = 0;
         }
@@ -462,32 +517,36 @@
  *
  * CALL GRAPH: copy_mm-->dup_mmap-->copy_range
  */
-int
-copy_range(pde_t *to, pde_t *from, uintptr_t start, uintptr_t end, bool share) {
+int copy_range(pde_t *to, pde_t *from, uintptr_t start, uintptr_t end, bool share)
+{
     assert(start % PGSIZE == 0 && end % PGSIZE == 0);
     assert(USER_ACCESS(start, end));
     // copy content by page unit.
-    do {
+    do
+    {
         //call get_pte to find process A's pte according to the addr start
         pte_t *ptep = get_pte(from, start, 0), *nptep;
-        if (ptep == NULL) {
+        if (ptep == NULL)
+        {
             start = ROUNDDOWN(start + PTSIZE, PTSIZE);
-            continue ;
+            continue;
         }
         //call get_pte to find process B's pte according to the addr start. If pte is NULL, just alloc a PT
-        if (*ptep & PTE_P) {
-            if ((nptep = get_pte(to, start, 1)) == NULL) {
+        if (*ptep & PTE_P)
+        {
+            if ((nptep = get_pte(to, start, 1)) == NULL)
+            {
                 return -E_NO_MEM;
             }
-        uint32_t perm = (*ptep & PTE_USER);
-        //get page from ptep
-        struct Page *page = pte2page(*ptep);
-        // alloc a page for process B
-        struct Page *npage=alloc_page();
-        assert(page!=NULL);
-        assert(npage!=NULL);
-        int ret=0;
-        /* LAB5:EXERCISE2 YOUR CODE
+            uint32_t perm = (*ptep & PTE_USER);
+            //get page from ptep
+            struct Page *page = pte2page(*ptep);
+            // alloc a page for process B
+            struct Page *npage = alloc_page();
+            assert(page != NULL);
+            assert(npage != NULL);
+            int ret = 0;
+            /* LAB5:EXERCISE2 YOUR CODE
          * replicate content of page to npage, build the map of phy addr of nage with the linear addr start
          *
          * Some Useful MACROs and DEFINEs, you can use them in below implementation.
@@ -501,7 +560,9 @@
          * (3) memory copy from src_kvaddr to dst_kvaddr, size is PGSIZE
          * (4) build the map of phy addr of  nage with the linear addr start
          */
-        assert(ret == 0);
+            memcpy(page2kva(npage), page2kva(page), PGSIZE);
+            ret = page_insert(to, npage, start, perm);
+            assert(ret == 0);
         }
         start += PGSIZE;
     } while (start != 0 && start < end);
@@ -509,10 +570,11 @@
 }
 
 //page_remove - free an Page which is related linear address la and has an validated pte
-void
-page_remove(pde_t *pgdir, uintptr_t la) {
+void page_remove(pde_t *pgdir, uintptr_t la)
+{
     pte_t *ptep = get_pte(pgdir, la, 0);
-    if (ptep != NULL) {
+    if (ptep != NULL)
+    {
         page_remove_pte(pgdir, la, ptep);
     }
 }
@@ -524,20 +586,24 @@
 //  la:    the linear address need to map
 //  perm:  the permission of this Page which is setted in related pte
 // return value: always 0
-//note: PT is changed, so the TLB need to be invalidate 
-int
-page_insert(pde_t *pgdir, struct Page *page, uintptr_t la, uint32_t perm) {
+//note: PT is changed, so the TLB need to be invalidate
+int page_insert(pde_t *pgdir, struct Page *page, uintptr_t la, uint32_t perm)
+{
     pte_t *ptep = get_pte(pgdir, la, 1);
-    if (ptep == NULL) {
+    if (ptep == NULL)
+    {
         return -E_NO_MEM;
     }
     page_ref_inc(page);
-    if (*ptep & PTE_P) {
+    if (*ptep & PTE_P)
+    {
         struct Page *p = pte2page(*ptep);
-        if (p == page) {
+        if (p == page)
+        {
             page_ref_dec(page);
         }
-        else {
+        else
+        {
             page_remove_pte(pgdir, la, ptep);
         }
     }
@@ -548,52 +614,60 @@
 
 // invalidate a TLB entry, but only if the page tables being
 // edited are the ones currently in use by the processor.
-void
-tlb_invalidate(pde_t *pgdir, uintptr_t la) {
-    if (rcr3() == PADDR(pgdir)) {
+void tlb_invalidate(pde_t *pgdir, uintptr_t la)
+{
+    if (rcr3() == PADDR(pgdir))
+    {
         invlpg((void *)la);
     }
 }
 
-// pgdir_alloc_page - call alloc_page & page_insert functions to 
+// pgdir_alloc_page - call alloc_page & page_insert functions to
 //                  - allocate a page size memory & setup an addr map
 //                  - pa<->la with linear address la and the PDT pgdir
 struct Page *
-pgdir_alloc_page(pde_t *pgdir, uintptr_t la, uint32_t perm) {
+pgdir_alloc_page(pde_t *pgdir, uintptr_t la, uint32_t perm)
+{
     struct Page *page = alloc_page();
-    if (page != NULL) {
-        if (page_insert(pgdir, page, la, perm) != 0) {
+    if (page != NULL)
+    {
+        if (page_insert(pgdir, page, la, perm) != 0)
+        {
             free_page(page);
             return NULL;
         }
-        if (swap_init_ok){
-            if(check_mm_struct!=NULL) {
+        if (swap_init_ok)
+        {
+            if (check_mm_struct != NULL)
+            {
                 swap_map_swappable(check_mm_struct, la, page, 0);
-                page->pra_vaddr=la;
+                page->pra_vaddr = la;
                 assert(page_ref(page) == 1);
                 //cprintf("get No. %d  page: pra_vaddr %x, pra_link.prev %x, pra_link_next %x in pgdir_alloc_page\n", (page-pages), page->pra_vaddr,page->pra_page_link.prev, page->pra_page_link.next);
-            } 
-            else  {  //now current is existed, should fix it in the future
+            }
+            else
+            { //now current is existed, should fix it in the future
                 //swap_map_swappable(current->mm, la, page, 0);
                 //page->pra_vaddr=la;
                 //assert(page_ref(page) == 1);
                 //panic("pgdir_alloc_page: no pages. now current is existed, should fix it in the future\n");
             }
         }
-
     }
 
     return page;
 }
 
 static void
-check_alloc_page(void) {
+check_alloc_page(void)
+{
     pmm_manager->check();
     cprintf("check_alloc_page() succeeded!\n");
 }
 
 static void
-check_pgdir(void) {
+check_pgdir(void)
+{
     assert(npage <= KMEMSIZE / PGSIZE);
     assert(boot_pgdir != NULL && (uint32_t)PGOFF(boot_pgdir) == 0);
     assert(get_page(boot_pgdir, 0x0, NULL) == NULL);
@@ -641,10 +715,12 @@
 }
 
 static void
-check_boot_pgdir(void) {
+check_boot_pgdir(void)
+{
     pte_t *ptep;
     int i;
-    for (i = 0; i < npage; i += PGSIZE) {
+    for (i = 0; i < npage; i += PGSIZE)
+    {
         assert((ptep = get_pte(boot_pgdir, (uintptr_t)KADDR(i), 0)) != NULL);
         assert(PTE_ADDR(*ptep) == i);
     }
@@ -676,7 +752,8 @@
 
 //perm2str - use string 'u,r,w,-' to present the permission
 static const char *
-perm2str(int perm) {
+perm2str(int perm)
+{
     static char str[4];
     str[0] = (perm & PTE_U) ? 'u' : '-';
     str[1] = 'r';
@@ -695,24 +772,31 @@
 //  table:       the beginning addr of table
 //  left_store:  the pointer of the high side of table's next range
 //  right_store: the pointer of the low side of table's next range
-// return value: 0 - not a invalid item range, perm - a valid item range with perm permission 
+// return value: 0 - not a invalid item range, perm - a valid item range with perm permission
 static int
-get_pgtable_items(size_t left, size_t right, size_t start, uintptr_t *table, size_t *left_store, size_t *right_store) {
-    if (start >= right) {
+get_pgtable_items(size_t left, size_t right, size_t start, uintptr_t *table, size_t *left_store, size_t *right_store)
+{
+    if (start >= right)
+    {
         return 0;
     }
-    while (start < right && !(table[start] & PTE_P)) {
-        start ++;
+    while (start < right && !(table[start] & PTE_P))
+    {
+        start++;
     }
-    if (start < right) {
-        if (left_store != NULL) {
+    if (start < right)
+    {
+        if (left_store != NULL)
+        {
             *left_store = start;
         }
-        int perm = (table[start ++] & PTE_USER);
-        while (start < right && (table[start] & PTE_USER) == perm) {
-            start ++;
+        int perm = (table[start++] & PTE_USER);
+        while (start < right && (table[start] & PTE_USER) == perm)
+        {
+            start++;
         }
-        if (right_store != NULL) {
+        if (right_store != NULL)
+        {
             *right_store = start;
         }
         return perm;
@@ -721,15 +805,17 @@
 }
 
 //print_pgdir - print the PDT&PT
-void
-print_pgdir(void) {
+void print_pgdir(void)
+{
     cprintf("-------------------- BEGIN --------------------\n");
     size_t left, right = 0, perm;
-    while ((perm = get_pgtable_items(0, NPDEENTRY, right, vpd, &left, &right)) != 0) {
+    while ((perm = get_pgtable_items(0, NPDEENTRY, right, vpd, &left, &right)) != 0)
+    {
         cprintf("PDE(%03x) %08x-%08x %08x %s\n", right - left,
                 left * PTSIZE, right * PTSIZE, (right - left) * PTSIZE, perm2str(perm));
         size_t l, r = left * NPTEENTRY;
-        while ((perm = get_pgtable_items(left * NPTEENTRY, right * NPTEENTRY, r, vpt, &l, &r)) != 0) {
+        while ((perm = get_pgtable_items(left * NPTEENTRY, right * NPTEENTRY, r, vpt, &l, &r)) != 0)
+        {
             cprintf("  |-- PTE(%05x) %08x-%08x %08x %s\n", r - l,
                     l * PGSIZE, r * PGSIZE, (r - l) * PGSIZE, perm2str(perm));
         }
diff -ruP /home/xmh/origin/ucore_os_lab/labcodes/lab5/kern/mm/swap_fifo.c lab5/kern/mm/swap_fifo.c
--- /home/xmh/origin/ucore_os_lab/labcodes/lab5/kern/mm/swap_fifo.c	2020-05-24 07:28:36.518368873 +0000
+++ lab5/kern/mm/swap_fifo.c	2020-05-24 04:46:26.061832571 +0000
@@ -32,11 +32,11 @@
  */
 static int
 _fifo_init_mm(struct mm_struct *mm)
-{     
-     list_init(&pra_list_head);
-     mm->sm_priv = &pra_list_head;
-     //cprintf(" mm->sm_priv %x in fifo_init_mm\n",mm->sm_priv);
-     return 0;
+{
+    list_init(&pra_list_head);
+    mm->sm_priv = &pra_list_head;
+    //cprintf(" mm->sm_priv %x in fifo_init_mm\n",mm->sm_priv);
+    return 0;
 }
 /*
  * (3)_fifo_map_swappable: According FIFO PRA, we should link the most recent arrival page at the back of pra_list_head qeueue
@@ -44,13 +44,14 @@
 static int
 _fifo_map_swappable(struct mm_struct *mm, uintptr_t addr, struct Page *page, int swap_in)
 {
-    list_entry_t *head=(list_entry_t*) mm->sm_priv;
-    list_entry_t *entry=&(page->pra_page_link);
- 
+    list_entry_t *head = (list_entry_t *)mm->sm_priv;
+    list_entry_t *entry = &(page->pra_page_link);
+
     assert(entry != NULL && head != NULL);
     //record the page access situlation
-    /*LAB3 EXERCISE 2: YOUR CODE*/ 
+    /*LAB3 EXERCISE 2: YOUR CODE*/
     //(1)link the most recent arrival page at the back of the pra_list_head qeueue.
+    list_add(head, entry);
     return 0;
 }
 /*
@@ -58,61 +59,65 @@
  *                            then assign the value of *ptr_page to the addr of this page.
  */
 static int
-_fifo_swap_out_victim(struct mm_struct *mm, struct Page ** ptr_page, int in_tick)
+_fifo_swap_out_victim(struct mm_struct *mm, struct Page **ptr_page, int in_tick)
 {
-     list_entry_t *head=(list_entry_t*) mm->sm_priv;
-         assert(head != NULL);
-     assert(in_tick==0);
-     /* Select the victim */
-     /*LAB3 EXERCISE 2: YOUR CODE*/ 
-     //(1)  unlink the  earliest arrival page in front of pra_list_head qeueue
-     //(2)  assign the value of *ptr_page to the addr of this page
-     return 0;
+    list_entry_t *head = (list_entry_t *)mm->sm_priv;
+    assert(head != NULL);
+    assert(in_tick == 0);
+    /* Select the victim */
+    /*LAB3 EXERCISE 2: YOUR CODE*/
+    //(1)  unlink the  earliest arrival page in front of pra_list_head qeueue
+    //(2)  assign the value of *ptr_page to the addr of this page
+    list_entry_t *le = head->prev;
+    struct Page *p = le2page(le, pra_page_link);
+    list_del(le);
+    *ptr_page = p;
+    return 0;
 }
 
 static int
-_fifo_check_swap(void) {
+_fifo_check_swap(void)
+{
     cprintf("write Virt Page c in fifo_check_swap\n");
     *(unsigned char *)0x3000 = 0x0c;
-    assert(pgfault_num==4);
+    assert(pgfault_num == 4);
     cprintf("write Virt Page a in fifo_check_swap\n");
     *(unsigned char *)0x1000 = 0x0a;
-    assert(pgfault_num==4);
+    assert(pgfault_num == 4);
     cprintf("write Virt Page d in fifo_check_swap\n");
     *(unsigned char *)0x4000 = 0x0d;
-    assert(pgfault_num==4);
+    assert(pgfault_num == 4);
     cprintf("write Virt Page b in fifo_check_swap\n");
     *(unsigned char *)0x2000 = 0x0b;
-    assert(pgfault_num==4);
+    assert(pgfault_num == 4);
     cprintf("write Virt Page e in fifo_check_swap\n");
     *(unsigned char *)0x5000 = 0x0e;
-    assert(pgfault_num==5);
+    assert(pgfault_num == 5);
     cprintf("write Virt Page b in fifo_check_swap\n");
     *(unsigned char *)0x2000 = 0x0b;
-    assert(pgfault_num==5);
+    assert(pgfault_num == 5);
     cprintf("write Virt Page a in fifo_check_swap\n");
     *(unsigned char *)0x1000 = 0x0a;
-    assert(pgfault_num==6);
+    assert(pgfault_num == 6);
     cprintf("write Virt Page b in fifo_check_swap\n");
     *(unsigned char *)0x2000 = 0x0b;
-    assert(pgfault_num==7);
+    assert(pgfault_num == 7);
     cprintf("write Virt Page c in fifo_check_swap\n");
     *(unsigned char *)0x3000 = 0x0c;
-    assert(pgfault_num==8);
+    assert(pgfault_num == 8);
     cprintf("write Virt Page d in fifo_check_swap\n");
     *(unsigned char *)0x4000 = 0x0d;
-    assert(pgfault_num==9);
+    assert(pgfault_num == 9);
     cprintf("write Virt Page e in fifo_check_swap\n");
     *(unsigned char *)0x5000 = 0x0e;
-    assert(pgfault_num==10);
+    assert(pgfault_num == 10);
     cprintf("write Virt Page a in fifo_check_swap\n");
     assert(*(unsigned char *)0x1000 == 0x0a);
     *(unsigned char *)0x1000 = 0x0a;
-    assert(pgfault_num==11);
+    assert(pgfault_num == 11);
     return 0;
 }
 
-
 static int
 _fifo_init(void)
 {
@@ -127,17 +132,18 @@
 
 static int
 _fifo_tick_event(struct mm_struct *mm)
-{ return 0; }
-
+{
+    return 0;
+}
 
 struct swap_manager swap_manager_fifo =
-{
-     .name            = "fifo swap manager",
-     .init            = &_fifo_init,
-     .init_mm         = &_fifo_init_mm,
-     .tick_event      = &_fifo_tick_event,
-     .map_swappable   = &_fifo_map_swappable,
-     .set_unswappable = &_fifo_set_unswappable,
-     .swap_out_victim = &_fifo_swap_out_victim,
-     .check_swap      = &_fifo_check_swap,
+    {
+        .name = "fifo swap manager",
+        .init = &_fifo_init,
+        .init_mm = &_fifo_init_mm,
+        .tick_event = &_fifo_tick_event,
+        .map_swappable = &_fifo_map_swappable,
+        .set_unswappable = &_fifo_set_unswappable,
+        .swap_out_victim = &_fifo_swap_out_victim,
+        .check_swap = &_fifo_check_swap,
 };
diff -ruP /home/xmh/origin/ucore_os_lab/labcodes/lab5/kern/mm/vmm.c lab5/kern/mm/vmm.c
--- /home/xmh/origin/ucore_os_lab/labcodes/lab5/kern/mm/vmm.c	2020-05-24 07:28:36.518368873 +0000
+++ lab5/kern/mm/vmm.c	2020-05-24 04:52:28.783821225 +0000
@@ -41,30 +41,36 @@
 
 // mm_create -  alloc a mm_struct & initialize it.
 struct mm_struct *
-mm_create(void) {
+mm_create(void)
+{
     struct mm_struct *mm = kmalloc(sizeof(struct mm_struct));
 
-    if (mm != NULL) {
+    if (mm != NULL)
+    {
         list_init(&(mm->mmap_list));
         mm->mmap_cache = NULL;
         mm->pgdir = NULL;
         mm->map_count = 0;
 
-        if (swap_init_ok) swap_init_mm(mm);
-        else mm->sm_priv = NULL;
-        
+        if (swap_init_ok)
+            swap_init_mm(mm);
+        else
+            mm->sm_priv = NULL;
+
         set_mm_count(mm, 0);
         lock_init(&(mm->mm_lock));
-    }    
+    }
     return mm;
 }
 
 // vma_create - alloc a vma_struct & initialize it. (addr range: vm_start~vm_end)
 struct vma_struct *
-vma_create(uintptr_t vm_start, uintptr_t vm_end, uint32_t vm_flags) {
+vma_create(uintptr_t vm_start, uintptr_t vm_end, uint32_t vm_flags)
+{
     struct vma_struct *vma = kmalloc(sizeof(struct vma_struct));
 
-    if (vma != NULL) {
+    if (vma != NULL)
+    {
         vma->vm_start = vm_start;
         vma->vm_end = vm_end;
         vma->vm_flags = vm_flags;
@@ -72,95 +78,106 @@
     return vma;
 }
 
-
 // find_vma - find a vma  (vma->vm_start <= addr <= vma_vm_end)
 struct vma_struct *
-find_vma(struct mm_struct *mm, uintptr_t addr) {
+find_vma(struct mm_struct *mm, uintptr_t addr)
+{
     struct vma_struct *vma = NULL;
-    if (mm != NULL) {
+    if (mm != NULL)
+    {
         vma = mm->mmap_cache;
-        if (!(vma != NULL && vma->vm_start <= addr && vma->vm_end > addr)) {
-                bool found = 0;
-                list_entry_t *list = &(mm->mmap_list), *le = list;
-                while ((le = list_next(le)) != list) {
-                    vma = le2vma(le, list_link);
-                    if (vma->vm_start<=addr && addr < vma->vm_end) {
-                        found = 1;
-                        break;
-                    }
-                }
-                if (!found) {
-                    vma = NULL;
+        if (!(vma != NULL && vma->vm_start <= addr && vma->vm_end > addr))
+        {
+            bool found = 0;
+            list_entry_t *list = &(mm->mmap_list), *le = list;
+            while ((le = list_next(le)) != list)
+            {
+                vma = le2vma(le, list_link);
+                if (vma->vm_start <= addr && addr < vma->vm_end)
+                {
+                    found = 1;
+                    break;
                 }
+            }
+            if (!found)
+            {
+                vma = NULL;
+            }
         }
-        if (vma != NULL) {
+        if (vma != NULL)
+        {
             mm->mmap_cache = vma;
         }
     }
     return vma;
 }
 
-
 // check_vma_overlap - check if vma1 overlaps vma2 ?
 static inline void
-check_vma_overlap(struct vma_struct *prev, struct vma_struct *next) {
+check_vma_overlap(struct vma_struct *prev, struct vma_struct *next)
+{
     assert(prev->vm_start < prev->vm_end);
     assert(prev->vm_end <= next->vm_start);
     assert(next->vm_start < next->vm_end);
 }
 
-
 // insert_vma_struct -insert vma in mm's list link
-void
-insert_vma_struct(struct mm_struct *mm, struct vma_struct *vma) {
+void insert_vma_struct(struct mm_struct *mm, struct vma_struct *vma)
+{
     assert(vma->vm_start < vma->vm_end);
     list_entry_t *list = &(mm->mmap_list);
     list_entry_t *le_prev = list, *le_next;
 
-        list_entry_t *le = list;
-        while ((le = list_next(le)) != list) {
-            struct vma_struct *mmap_prev = le2vma(le, list_link);
-            if (mmap_prev->vm_start > vma->vm_start) {
-                break;
-            }
-            le_prev = le;
+    list_entry_t *le = list;
+    while ((le = list_next(le)) != list)
+    {
+        struct vma_struct *mmap_prev = le2vma(le, list_link);
+        if (mmap_prev->vm_start > vma->vm_start)
+        {
+            break;
         }
+        le_prev = le;
+    }
 
     le_next = list_next(le_prev);
 
     /* check overlap */
-    if (le_prev != list) {
+    if (le_prev != list)
+    {
         check_vma_overlap(le2vma(le_prev, list_link), vma);
     }
-    if (le_next != list) {
+    if (le_next != list)
+    {
         check_vma_overlap(vma, le2vma(le_next, list_link));
     }
 
     vma->vm_mm = mm;
     list_add_after(le_prev, &(vma->list_link));
 
-    mm->map_count ++;
+    mm->map_count++;
 }
 
 // mm_destroy - free mm and mm internal fields
-void
-mm_destroy(struct mm_struct *mm) {
+void mm_destroy(struct mm_struct *mm)
+{
     assert(mm_count(mm) == 0);
 
     list_entry_t *list = &(mm->mmap_list), *le;
-    while ((le = list_next(list)) != list) {
+    while ((le = list_next(list)) != list)
+    {
         list_del(le);
-        kfree(le2vma(le, list_link));  //kfree vma        
+        kfree(le2vma(le, list_link)); //kfree vma
     }
     kfree(mm); //kfree mm
-    mm=NULL;
+    mm = NULL;
 }
 
-int
-mm_map(struct mm_struct *mm, uintptr_t addr, size_t len, uint32_t vm_flags,
-       struct vma_struct **vma_store) {
+int mm_map(struct mm_struct *mm, uintptr_t addr, size_t len, uint32_t vm_flags,
+           struct vma_struct **vma_store)
+{
     uintptr_t start = ROUNDDOWN(addr, PGSIZE), end = ROUNDUP(addr + len, PGSIZE);
-    if (!USER_ACCESS(start, end)) {
+    if (!USER_ACCESS(start, end))
+    {
         return -E_INVAL;
     }
 
@@ -169,16 +186,19 @@
     int ret = -E_INVAL;
 
     struct vma_struct *vma;
-    if ((vma = find_vma(mm, start)) != NULL && end > vma->vm_start) {
+    if ((vma = find_vma(mm, start)) != NULL && end > vma->vm_start)
+    {
         goto out;
     }
     ret = -E_NO_MEM;
 
-    if ((vma = vma_create(start, end, vm_flags)) == NULL) {
+    if ((vma = vma_create(start, end, vm_flags)) == NULL)
+    {
         goto out;
     }
     insert_vma_struct(mm, vma);
-    if (vma_store != NULL) {
+    if (vma_store != NULL)
+    {
         *vma_store = vma;
     }
     ret = 0;
@@ -187,55 +207,62 @@
     return ret;
 }
 
-int
-dup_mmap(struct mm_struct *to, struct mm_struct *from) {
+int dup_mmap(struct mm_struct *to, struct mm_struct *from)
+{
     assert(to != NULL && from != NULL);
     list_entry_t *list = &(from->mmap_list), *le = list;
-    while ((le = list_prev(le)) != list) {
+    while ((le = list_prev(le)) != list)
+    {
         struct vma_struct *vma, *nvma;
         vma = le2vma(le, list_link);
         nvma = vma_create(vma->vm_start, vma->vm_end, vma->vm_flags);
-        if (nvma == NULL) {
+        if (nvma == NULL)
+        {
             return -E_NO_MEM;
         }
 
         insert_vma_struct(to, nvma);
 
         bool share = 0;
-        if (copy_range(to->pgdir, from->pgdir, vma->vm_start, vma->vm_end, share) != 0) {
+        if (copy_range(to->pgdir, from->pgdir, vma->vm_start, vma->vm_end, share) != 0)
+        {
             return -E_NO_MEM;
         }
     }
     return 0;
 }
 
-void
-exit_mmap(struct mm_struct *mm) {
+void exit_mmap(struct mm_struct *mm)
+{
     assert(mm != NULL && mm_count(mm) == 0);
     pde_t *pgdir = mm->pgdir;
     list_entry_t *list = &(mm->mmap_list), *le = list;
-    while ((le = list_next(le)) != list) {
+    while ((le = list_next(le)) != list)
+    {
         struct vma_struct *vma = le2vma(le, list_link);
         unmap_range(pgdir, vma->vm_start, vma->vm_end);
     }
-    while ((le = list_next(le)) != list) {
+    while ((le = list_next(le)) != list)
+    {
         struct vma_struct *vma = le2vma(le, list_link);
         exit_range(pgdir, vma->vm_start, vma->vm_end);
     }
 }
 
-bool
-copy_from_user(struct mm_struct *mm, void *dst, const void *src, size_t len, bool writable) {
-    if (!user_mem_check(mm, (uintptr_t)src, len, writable)) {
+bool copy_from_user(struct mm_struct *mm, void *dst, const void *src, size_t len, bool writable)
+{
+    if (!user_mem_check(mm, (uintptr_t)src, len, writable))
+    {
         return 0;
     }
     memcpy(dst, src, len);
     return 1;
 }
 
-bool
-copy_to_user(struct mm_struct *mm, void *dst, const void *src, size_t len) {
-    if (!user_mem_check(mm, (uintptr_t)dst, len, 1)) {
+bool copy_to_user(struct mm_struct *mm, void *dst, const void *src, size_t len)
+{
+    if (!user_mem_check(mm, (uintptr_t)dst, len, 1))
+    {
         return 0;
     }
     memcpy(dst, src, len);
@@ -244,16 +271,17 @@
 
 // vmm_init - initialize virtual memory management
 //          - now just call check_vmm to check correctness of vmm
-void
-vmm_init(void) {
+void vmm_init(void)
+{
     check_vmm();
 }
 
 // check_vmm - check correctness of vmm
 static void
-check_vmm(void) {
+check_vmm(void)
+{
     size_t nr_free_pages_store = nr_free_pages();
-    
+
     check_vma_struct();
     check_pgfault();
 
@@ -261,7 +289,8 @@
 }
 
 static void
-check_vma_struct(void) {
+check_vma_struct(void)
+{
     size_t nr_free_pages_store = nr_free_pages();
 
     struct mm_struct *mm = mm_create();
@@ -270,13 +299,15 @@
     int step1 = 10, step2 = step1 * 10;
 
     int i;
-    for (i = step1; i >= 1; i --) {
+    for (i = step1; i >= 1; i--)
+    {
         struct vma_struct *vma = vma_create(i * 5, i * 5 + 2, 0);
         assert(vma != NULL);
         insert_vma_struct(mm, vma);
     }
 
-    for (i = step1 + 1; i <= step2; i ++) {
+    for (i = step1 + 1; i <= step2; i++)
+    {
         struct vma_struct *vma = vma_create(i * 5, i * 5 + 2, 0);
         assert(vma != NULL);
         insert_vma_struct(mm, vma);
@@ -284,33 +315,37 @@
 
     list_entry_t *le = list_next(&(mm->mmap_list));
 
-    for (i = 1; i <= step2; i ++) {
+    for (i = 1; i <= step2; i++)
+    {
         assert(le != &(mm->mmap_list));
         struct vma_struct *mmap = le2vma(le, list_link);
         assert(mmap->vm_start == i * 5 && mmap->vm_end == i * 5 + 2);
         le = list_next(le);
     }
 
-    for (i = 5; i <= 5 * step2; i +=5) {
+    for (i = 5; i <= 5 * step2; i += 5)
+    {
         struct vma_struct *vma1 = find_vma(mm, i);
         assert(vma1 != NULL);
-        struct vma_struct *vma2 = find_vma(mm, i+1);
+        struct vma_struct *vma2 = find_vma(mm, i + 1);
         assert(vma2 != NULL);
-        struct vma_struct *vma3 = find_vma(mm, i+2);
+        struct vma_struct *vma3 = find_vma(mm, i + 2);
         assert(vma3 == NULL);
-        struct vma_struct *vma4 = find_vma(mm, i+3);
+        struct vma_struct *vma4 = find_vma(mm, i + 3);
         assert(vma4 == NULL);
-        struct vma_struct *vma5 = find_vma(mm, i+4);
+        struct vma_struct *vma5 = find_vma(mm, i + 4);
         assert(vma5 == NULL);
 
-        assert(vma1->vm_start == i  && vma1->vm_end == i  + 2);
-        assert(vma2->vm_start == i  && vma2->vm_end == i  + 2);
+        assert(vma1->vm_start == i && vma1->vm_end == i + 2);
+        assert(vma2->vm_start == i && vma2->vm_end == i + 2);
     }
 
-    for (i =4; i>=0; i--) {
-        struct vma_struct *vma_below_5= find_vma(mm,i);
-        if (vma_below_5 != NULL ) {
-           cprintf("vma_below_5: i %x, start %x, end %x\n",i, vma_below_5->vm_start, vma_below_5->vm_end); 
+    for (i = 4; i >= 0; i--)
+    {
+        struct vma_struct *vma_below_5 = find_vma(mm, i);
+        if (vma_below_5 != NULL)
+        {
+            cprintf("vma_below_5: i %x, start %x, end %x\n", i, vma_below_5->vm_start, vma_below_5->vm_end);
         }
         assert(vma_below_5 == NULL);
     }
@@ -324,7 +359,8 @@
 
 // check_pgfault - check correctness of pgfault handler
 static void
-check_pgfault(void) {
+check_pgfault(void)
+{
     size_t nr_free_pages_store = nr_free_pages();
 
     check_mm_struct = mm_create();
@@ -343,11 +379,13 @@
     assert(find_vma(mm, addr) == vma);
 
     int i, sum = 0;
-    for (i = 0; i < 100; i ++) {
+    for (i = 0; i < 100; i++)
+    {
         *(char *)(addr + i) = i;
         sum += i;
     }
-    for (i = 0; i < 100; i ++) {
+    for (i = 0; i < 100; i++)
+    {
         sum -= *(char *)(addr + i);
     }
     assert(sum == 0);
@@ -365,7 +403,7 @@
     cprintf("check_pgfault() succeeded!\n");
 }
 //page fault number
-volatile unsigned int pgfault_num=0;
+volatile unsigned int pgfault_num = 0;
 
 /* do_pgfault - interrupt handler to process the page fault execption
  * @mm         : the control struct for a set of vma using the same PDT
@@ -388,24 +426,27 @@
  *         -- The U/S flag (bit 2) indicates whether the processor was executing at user mode (1)
  *            or supervisor mode (0) at the time of the exception.
  */
-int
-do_pgfault(struct mm_struct *mm, uint32_t error_code, uintptr_t addr) {
+int do_pgfault(struct mm_struct *mm, uint32_t error_code, uintptr_t addr)
+{
     int ret = -E_INVAL;
     //try to find a vma which include addr
     struct vma_struct *vma = find_vma(mm, addr);
 
     pgfault_num++;
     //If the addr is in the range of a mm's vma?
-    if (vma == NULL || vma->vm_start > addr) {
+    if (vma == NULL || vma->vm_start > addr)
+    {
         cprintf("not valid addr %x, and  can not find it in vma\n", addr);
         goto failed;
     }
     //check the error_code
-    switch (error_code & 3) {
+    switch (error_code & 3)
+    {
     default:
-            /* error code flag : default is 3 ( W/R=1, P=1): write, present */
+        /* error code flag : default is 3 ( W/R=1, P=1): write, present */
     case 2: /* error code flag : (W/R=1, P=0): write, not present */
-        if (!(vma->vm_flags & VM_WRITE)) {
+        if (!(vma->vm_flags & VM_WRITE))
+        {
             cprintf("do_pgfault failed: error code flag = write AND not present, but the addr's vma cannot write\n");
             goto failed;
         }
@@ -414,7 +455,8 @@
         cprintf("do_pgfault failed: error code flag = read AND present\n");
         goto failed;
     case 0: /* error code flag : (W/R=0, P=0): read, not present */
-        if (!(vma->vm_flags & (VM_READ | VM_EXEC))) {
+        if (!(vma->vm_flags & (VM_READ | VM_EXEC)))
+        {
             cprintf("do_pgfault failed: error code flag = read AND not present, but the addr's vma cannot read or exec\n");
             goto failed;
         }
@@ -426,14 +468,15 @@
      *    continue process
      */
     uint32_t perm = PTE_U;
-    if (vma->vm_flags & VM_WRITE) {
+    if (vma->vm_flags & VM_WRITE)
+    {
         perm |= PTE_W;
     }
     addr = ROUNDDOWN(addr, PGSIZE);
 
     ret = -E_NO_MEM;
 
-    pte_t *ptep=NULL;
+    pte_t *ptep = NULL;
     /*LAB3 EXERCISE 1: YOUR CODE
     * Maybe you want help comment, BELOW comments can help you finish the code
     *
@@ -493,28 +536,71 @@
         }
    }
 #endif
-   ret = 0;
+    ptep = get_pte(mm->pgdir, addr, 1);
+    if (ptep == NULL)
+    {
+        cprintf("get_pte failed\n");
+        goto failed;
+    }
+
+    if (*ptep == 0)
+    {
+        struct Page *page = pgdir_alloc_page(mm->pgdir, addr, perm);
+        if (page == NULL)
+        {
+            cprintf("pgdir_alloc_page failed\n");
+            goto failed;
+        }
+    }
+    else
+    {
+        if (swap_init_ok)
+        {
+            struct Page *page = NULL;
+            if ((ret = swap_in(mm, addr, &page)) != 0)
+            {
+                cprintf("swap_in failed\n");
+                goto failed;
+            }
+            page_insert(mm->pgdir, page, addr, perm);
+            swap_map_swappable(mm, addr, page, 1);
+            page->pra_vaddr = addr;
+        }
+        else
+        {
+            cprintf("no swap_init_ok but ptep is %x, failed\n", *ptep);
+            goto failed;
+        }
+    }
+    ret = 0;
 failed:
     return ret;
 }
 
-bool
-user_mem_check(struct mm_struct *mm, uintptr_t addr, size_t len, bool write) {
-    if (mm != NULL) {
-        if (!USER_ACCESS(addr, addr + len)) {
+bool user_mem_check(struct mm_struct *mm, uintptr_t addr, size_t len, bool write)
+{
+    if (mm != NULL)
+    {
+        if (!USER_ACCESS(addr, addr + len))
+        {
             return 0;
         }
         struct vma_struct *vma;
         uintptr_t start = addr, end = addr + len;
-        while (start < end) {
-            if ((vma = find_vma(mm, start)) == NULL || start < vma->vm_start) {
+        while (start < end)
+        {
+            if ((vma = find_vma(mm, start)) == NULL || start < vma->vm_start)
+            {
                 return 0;
             }
-            if (!(vma->vm_flags & ((write) ? VM_WRITE : VM_READ))) {
+            if (!(vma->vm_flags & ((write) ? VM_WRITE : VM_READ)))
+            {
                 return 0;
             }
-            if (write && (vma->vm_flags & VM_STACK)) {
-                if (start < vma->vm_start + PGSIZE) { //check stack start & size
+            if (write && (vma->vm_flags & VM_STACK))
+            {
+                if (start < vma->vm_start + PGSIZE)
+                { //check stack start & size
                     return 0;
                 }
             }
@@ -524,4 +610,3 @@
     }
     return KERN_ACCESS(addr, addr + len);
 }
-
diff -ruP /home/xmh/origin/ucore_os_lab/labcodes/lab5/kern/process/proc.c lab5/kern/process/proc.c
--- /home/xmh/origin/ucore_os_lab/labcodes/lab5/kern/process/proc.c	2020-05-24 07:28:36.518368873 +0000
+++ lab5/kern/process/proc.c	2020-05-24 07:24:32.915468575 +0000
@@ -59,12 +59,23 @@
 
 */
 
+#define __Lock(lock)                            \
+    do                                          \
+    {                                           \
+        if (__sync_lock_test_and_set(&lock, 1)) \
+            continue;
+
+#define __UnLock(lock)             \
+    __sync_lock_release(&lock, 0); \
+    }                              \
+    while (0)
+
 // the process set's list
 list_entry_t proc_list;
 
-#define HASH_SHIFT          10
-#define HASH_LIST_SIZE      (1 << HASH_SHIFT)
-#define pid_hashfn(x)       (hash32(x, HASH_SHIFT))
+#define HASH_SHIFT 10
+#define HASH_LIST_SIZE (1 << HASH_SHIFT)
+#define pid_hashfn(x) (hash32(x, HASH_SHIFT))
 
 // has list for process set based on pid
 static list_entry_t hash_list[HASH_LIST_SIZE];
@@ -84,11 +95,13 @@
 
 // alloc_proc - alloc a proc_struct and init all fields of proc_struct
 static struct proc_struct *
-alloc_proc(void) {
+alloc_proc(void)
+{
     struct proc_struct *proc = kmalloc(sizeof(struct proc_struct));
-    if (proc != NULL) {
-    //LAB4:EXERCISE1 YOUR CODE
-    /*
+    if (proc != NULL)
+    {
+        //LAB4:EXERCISE1 YOUR CODE
+        /*
      * below fields in proc_struct need to be initialized
      *       enum proc_state state;                      // Process state
      *       int pid;                                    // Process ID
@@ -103,26 +116,44 @@
      *       uint32_t flags;                             // Process flag
      *       char name[PROC_NAME_LEN + 1];               // Process name
      */
-     //LAB5 YOUR CODE : (update LAB4 steps)
-    /*
+        proc->state = PROC_UNINIT;
+        proc->pid = -1;
+        proc->runs = 0;
+        proc->kstack = 0;
+        proc->need_resched = 0;
+        proc->parent = NULL;
+        proc->mm = NULL;
+        memset(&(proc->context), 0, sizeof(struct context));
+        proc->tf = NULL;
+        proc->cr3 = boot_cr3;
+        proc->flags = 0;
+        memset(proc->name, 0, PROC_NAME_LEN);
+        //LAB5 YOUR CODE : (update LAB4 steps)
+        /*
      * below fields(add in LAB5) in proc_struct need to be initialized	
      *       uint32_t wait_state;                        // waiting state
      *       struct proc_struct *cptr, *yptr, *optr;     // relations between processes
 	 */
+        proc->wait_state = 0;
+        proc->cptr = NULL;
+        proc->optr = NULL;
+        proc->yptr = NULL;
     }
     return proc;
 }
 
 // set_proc_name - set the name of proc
 char *
-set_proc_name(struct proc_struct *proc, const char *name) {
+set_proc_name(struct proc_struct *proc, const char *name)
+{
     memset(proc->name, 0, sizeof(proc->name));
     return memcpy(proc->name, name, PROC_NAME_LEN);
 }
 
 // get_proc_name - get the name of proc
 char *
-get_proc_name(struct proc_struct *proc) {
+get_proc_name(struct proc_struct *proc)
+{
     static char name[PROC_NAME_LEN + 1];
     memset(name, 0, sizeof(name));
     return memcpy(name, proc->name, PROC_NAME_LEN);
@@ -130,60 +161,74 @@
 
 // set_links - set the relation links of process
 static void
-set_links(struct proc_struct *proc) {
+set_links(struct proc_struct *proc)
+{
     list_add(&proc_list, &(proc->list_link));
     proc->yptr = NULL;
-    if ((proc->optr = proc->parent->cptr) != NULL) {
+    if ((proc->optr = proc->parent->cptr) != NULL)
+    {
         proc->optr->yptr = proc;
     }
     proc->parent->cptr = proc;
-    nr_process ++;
+    nr_process++;
 }
 
 // remove_links - clean the relation links of process
 static void
-remove_links(struct proc_struct *proc) {
+remove_links(struct proc_struct *proc)
+{
     list_del(&(proc->list_link));
-    if (proc->optr != NULL) {
+    if (proc->optr != NULL)
+    {
         proc->optr->yptr = proc->yptr;
     }
-    if (proc->yptr != NULL) {
+    if (proc->yptr != NULL)
+    {
         proc->yptr->optr = proc->optr;
     }
-    else {
-       proc->parent->cptr = proc->optr;
+    else
+    {
+        proc->parent->cptr = proc->optr;
     }
-    nr_process --;
+    nr_process--;
 }
 
 // get_pid - alloc a unique pid for process
 static int
-get_pid(void) {
+get_pid(void)
+{
     static_assert(MAX_PID > MAX_PROCESS);
     struct proc_struct *proc;
     list_entry_t *list = &proc_list, *le;
     static int next_safe = MAX_PID, last_pid = MAX_PID;
-    if (++ last_pid >= MAX_PID) {
+    if (++last_pid >= MAX_PID)
+    {
         last_pid = 1;
         goto inside;
     }
-    if (last_pid >= next_safe) {
+    if (last_pid >= next_safe)
+    {
     inside:
         next_safe = MAX_PID;
     repeat:
         le = list;
-        while ((le = list_next(le)) != list) {
+        while ((le = list_next(le)) != list)
+        {
             proc = le2proc(le, list_link);
-            if (proc->pid == last_pid) {
-                if (++ last_pid >= next_safe) {
-                    if (last_pid >= MAX_PID) {
+            if (proc->pid == last_pid)
+            {
+                if (++last_pid >= next_safe)
+                {
+                    if (last_pid >= MAX_PID)
+                    {
                         last_pid = 1;
                     }
                     next_safe = MAX_PID;
                     goto repeat;
                 }
             }
-            else if (proc->pid > last_pid && next_safe > proc->pid) {
+            else if (proc->pid > last_pid && next_safe > proc->pid)
+            {
                 next_safe = proc->pid;
             }
         }
@@ -193,9 +238,10 @@
 
 // proc_run - make process "proc" running on cpu
 // NOTE: before call switch_to, should load  base addr of "proc"'s new PDT
-void
-proc_run(struct proc_struct *proc) {
-    if (proc != current) {
+void proc_run(struct proc_struct *proc)
+{
+    if (proc != current)
+    {
         bool intr_flag;
         struct proc_struct *prev = current, *next = proc;
         local_intr_save(intr_flag);
@@ -213,30 +259,37 @@
 // NOTE: the addr of forkret is setted in copy_thread function
 //       after switch_to, the current proc will execute here.
 static void
-forkret(void) {
+forkret(void)
+{
     forkrets(current->tf);
 }
 
 // hash_proc - add proc into proc hash_list
 static void
-hash_proc(struct proc_struct *proc) {
+hash_proc(struct proc_struct *proc)
+{
     list_add(hash_list + pid_hashfn(proc->pid), &(proc->hash_link));
 }
 
 // unhash_proc - delete proc from proc hash_list
 static void
-unhash_proc(struct proc_struct *proc) {
+unhash_proc(struct proc_struct *proc)
+{
     list_del(&(proc->hash_link));
 }
 
 // find_proc - find proc frome proc hash_list according to pid
 struct proc_struct *
-find_proc(int pid) {
-    if (0 < pid && pid < MAX_PID) {
+find_proc(int pid)
+{
+    if (0 < pid && pid < MAX_PID)
+    {
         list_entry_t *list = hash_list + pid_hashfn(pid), *le = list;
-        while ((le = list_next(le)) != list) {
+        while ((le = list_next(le)) != list)
+        {
             struct proc_struct *proc = le2proc(le, hash_link);
-            if (proc->pid == pid) {
+            if (proc->pid == pid)
+            {
                 return proc;
             }
         }
@@ -245,10 +298,10 @@
 }
 
 // kernel_thread - create a kernel thread using "fn" function
-// NOTE: the contents of temp trapframe tf will be copied to 
+// NOTE: the contents of temp trapframe tf will be copied to
 //       proc->tf in do_fork-->copy_thread function
-int
-kernel_thread(int (*fn)(void *), void *arg, uint32_t clone_flags) {
+int kernel_thread(int (*fn)(void *), void *arg, uint32_t clone_flags)
+{
     struct trapframe tf;
     memset(&tf, 0, sizeof(struct trapframe));
     tf.tf_cs = KERNEL_CS;
@@ -261,9 +314,11 @@
 
 // setup_kstack - alloc pages with size KSTACKPAGE as process kernel stack
 static int
-setup_kstack(struct proc_struct *proc) {
+setup_kstack(struct proc_struct *proc)
+{
     struct Page *page = alloc_pages(KSTACKPAGE);
-    if (page != NULL) {
+    if (page != NULL)
+    {
         proc->kstack = (uintptr_t)page2kva(page);
         return 0;
     }
@@ -272,15 +327,18 @@
 
 // put_kstack - free the memory space of process kernel stack
 static void
-put_kstack(struct proc_struct *proc) {
+put_kstack(struct proc_struct *proc)
+{
     free_pages(kva2page((void *)(proc->kstack)), KSTACKPAGE);
 }
 
 // setup_pgdir - alloc one page as PDT
 static int
-setup_pgdir(struct mm_struct *mm) {
+setup_pgdir(struct mm_struct *mm)
+{
     struct Page *page;
-    if ((page = alloc_page()) == NULL) {
+    if ((page = alloc_page()) == NULL)
+    {
         return -E_NO_MEM;
     }
     pde_t *pgdir = page2kva(page);
@@ -292,30 +350,36 @@
 
 // put_pgdir - free the memory space of PDT
 static void
-put_pgdir(struct mm_struct *mm) {
+put_pgdir(struct mm_struct *mm)
+{
     free_page(kva2page(mm->pgdir));
 }
 
 // copy_mm - process "proc" duplicate OR share process "current"'s mm according clone_flags
 //         - if clone_flags & CLONE_VM, then "share" ; else "duplicate"
 static int
-copy_mm(uint32_t clone_flags, struct proc_struct *proc) {
+copy_mm(uint32_t clone_flags, struct proc_struct *proc)
+{
     struct mm_struct *mm, *oldmm = current->mm;
 
     /* current is a kernel thread */
-    if (oldmm == NULL) {
+    if (oldmm == NULL)
+    {
         return 0;
     }
-    if (clone_flags & CLONE_VM) {
+    if (clone_flags & CLONE_VM)
+    {
         mm = oldmm;
         goto good_mm;
     }
 
     int ret = -E_NO_MEM;
-    if ((mm = mm_create()) == NULL) {
+    if ((mm = mm_create()) == NULL)
+    {
         goto bad_mm;
     }
-    if (setup_pgdir(mm) != 0) {
+    if (setup_pgdir(mm) != 0)
+    {
         goto bad_pgdir_cleanup_mm;
     }
 
@@ -325,7 +389,8 @@
     }
     unlock_mm(oldmm);
 
-    if (ret != 0) {
+    if (ret != 0)
+    {
         goto bad_dup_cleanup_mmap;
     }
 
@@ -346,7 +411,8 @@
 // copy_thread - setup the trapframe on the  process's kernel stack top and
 //             - setup the kernel entry point and stack of process
 static void
-copy_thread(struct proc_struct *proc, uintptr_t esp, struct trapframe *tf) {
+copy_thread(struct proc_struct *proc, uintptr_t esp, struct trapframe *tf)
+{
     proc->tf = (struct trapframe *)(proc->kstack + KSTACKSIZE) - 1;
     *(proc->tf) = *tf;
     proc->tf->tf_regs.reg_eax = 0;
@@ -362,11 +428,12 @@
  * @stack:       the parent's user stack pointer. if stack==0, It means to fork a kernel thread.
  * @tf:          the trapframe info, which will be copied to child process's proc->tf
  */
-int
-do_fork(uint32_t clone_flags, uintptr_t stack, struct trapframe *tf) {
+int do_fork(uint32_t clone_flags, uintptr_t stack, struct trapframe *tf)
+{
     int ret = -E_NO_FREE_PROC;
     struct proc_struct *proc;
-    if (nr_process >= MAX_PROCESS) {
+    if (nr_process >= MAX_PROCESS)
+    {
         goto fork_out;
     }
     ret = -E_NO_MEM;
@@ -395,15 +462,44 @@
     //    5. insert proc_struct into hash_list && proc_list
     //    6. call wakeup_proc to make the new child process RUNNABLE
     //    7. set ret vaule using child proc's pid
+    if ((proc = alloc_proc()) == NULL)
+    {
+        goto fork_out;
+    }
+    proc->parent = current;
+    // *    update step 1: set child proc's parent to current process, make sure current process's wait_state is 0
+    assert(current->wait_state == 0);
+    if (setup_kstack(proc) != 0)
+    {
+        goto bad_fork_cleanup_proc;
+    }
+    if (copy_mm(clone_flags, proc) != 0)
+    {
+        goto bad_fork_cleanup_kstack;
+    }
+    copy_thread(proc, stack, tf);
 
-	//LAB5 YOUR CODE : (update LAB4 steps)
-   /* Some Functions
+    bool intr_flag;
+    local_intr_save(intr_flag);
+    static int lock = 0;
+    // __Lock(lock);
+    {
+        proc->pid = get_pid();
+        hash_proc(proc);
+        // *    update step 5: insert proc_struct into hash_list && proc_list, set the relation links of process
+        set_links(proc);
+    }
+    // __UnLock(lock);
+    local_intr_restore(intr_flag);
+    wakeup_proc(proc);
+    ret = proc->pid;
+
+    //LAB5 YOUR CODE : (update LAB4 steps)
+    /* Some Functions
     *    set_links:  set the relation links of process.  ALSO SEE: remove_links:  lean the relation links of process 
     *    -------------------
-	*    update step 1: set child proc's parent to current process, make sure current process's wait_state is 0
-	*    update step 5: insert proc_struct into hash_list && proc_list, set the relation links of process
     */
-	
+
 fork_out:
     return ret;
 
@@ -418,19 +514,23 @@
 //   1. call exit_mmap & put_pgdir & mm_destroy to free the almost all memory space of process
 //   2. set process' state as PROC_ZOMBIE, then call wakeup_proc(parent) to ask parent reclaim itself.
 //   3. call scheduler to switch to other process
-int
-do_exit(int error_code) {
-    if (current == idleproc) {
+int do_exit(int error_code)
+{
+    if (current == idleproc)
+    {
         panic("idleproc exit.\n");
     }
-    if (current == initproc) {
+    if (current == initproc)
+    {
         panic("initproc exit.\n");
     }
-    
+
     struct mm_struct *mm = current->mm;
-    if (mm != NULL) {
+    if (mm != NULL)
+    {
         lcr3(boot_cr3);
-        if (mm_count_dec(mm) == 0) {
+        if (mm_count_dec(mm) == 0)
+        {
             exit_mmap(mm);
             put_pgdir(mm);
             mm_destroy(mm);
@@ -439,34 +539,39 @@
     }
     current->state = PROC_ZOMBIE;
     current->exit_code = error_code;
-    
+
     bool intr_flag;
     struct proc_struct *proc;
     local_intr_save(intr_flag);
     {
         proc = current->parent;
-        if (proc->wait_state == WT_CHILD) {
+        if (proc->wait_state == WT_CHILD)
+        {
             wakeup_proc(proc);
         }
-        while (current->cptr != NULL) {
+        while (current->cptr != NULL)
+        {
             proc = current->cptr;
             current->cptr = proc->optr;
-    
+
             proc->yptr = NULL;
-            if ((proc->optr = initproc->cptr) != NULL) {
+            if ((proc->optr = initproc->cptr) != NULL)
+            {
                 initproc->cptr->yptr = proc;
             }
             proc->parent = initproc;
             initproc->cptr = proc;
-            if (proc->state == PROC_ZOMBIE) {
-                if (initproc->wait_state == WT_CHILD) {
+            if (proc->state == PROC_ZOMBIE)
+            {
+                if (initproc->wait_state == WT_CHILD)
+                {
                     wakeup_proc(initproc);
                 }
             }
         }
     }
     local_intr_restore(intr_flag);
-    
+
     schedule();
     panic("do_exit will not return!! %d.\n", current->pid);
 }
@@ -476,19 +581,23 @@
  * @size:  the size of the content of binary program
  */
 static int
-load_icode(unsigned char *binary, size_t size) {
-    if (current->mm != NULL) {
+load_icode(unsigned char *binary, size_t size)
+{
+    if (current->mm != NULL)
+    {
         panic("load_icode: current->mm must be empty.\n");
     }
 
     int ret = -E_NO_MEM;
     struct mm_struct *mm;
     //(1) create a new mm for current process
-    if ((mm = mm_create()) == NULL) {
+    if ((mm = mm_create()) == NULL)
+    {
         goto bad_mm;
     }
     //(2) create a new PDT, and mm->pgdir= kernel virtual addr of PDT
-    if (setup_pgdir(mm) != 0) {
+    if (setup_pgdir(mm) != 0)
+    {
         goto bad_pgdir_cleanup_mm;
     }
     //(3) copy TEXT/DATA section, build BSS parts in binary to memory space of process
@@ -498,32 +607,42 @@
     //(3.2) get the entry of the program section headers of the bianry program (ELF format)
     struct proghdr *ph = (struct proghdr *)(binary + elf->e_phoff);
     //(3.3) This program is valid?
-    if (elf->e_magic != ELF_MAGIC) {
+    if (elf->e_magic != ELF_MAGIC)
+    {
         ret = -E_INVAL_ELF;
         goto bad_elf_cleanup_pgdir;
     }
 
     uint32_t vm_flags, perm;
     struct proghdr *ph_end = ph + elf->e_phnum;
-    for (; ph < ph_end; ph ++) {
-    //(3.4) find every program section headers
-        if (ph->p_type != ELF_PT_LOAD) {
-            continue ;
+    for (; ph < ph_end; ph++)
+    {
+        //(3.4) find every program section headers
+        if (ph->p_type != ELF_PT_LOAD)
+        {
+            continue;
         }
-        if (ph->p_filesz > ph->p_memsz) {
+        if (ph->p_filesz > ph->p_memsz)
+        {
             ret = -E_INVAL_ELF;
             goto bad_cleanup_mmap;
         }
-        if (ph->p_filesz == 0) {
-            continue ;
+        if (ph->p_filesz == 0)
+        {
+            continue;
         }
-    //(3.5) call mm_map fun to setup the new vma ( ph->p_va, ph->p_memsz)
+        //(3.5) call mm_map fun to setup the new vma ( ph->p_va, ph->p_memsz)
         vm_flags = 0, perm = PTE_U;
-        if (ph->p_flags & ELF_PF_X) vm_flags |= VM_EXEC;
-        if (ph->p_flags & ELF_PF_W) vm_flags |= VM_WRITE;
-        if (ph->p_flags & ELF_PF_R) vm_flags |= VM_READ;
-        if (vm_flags & VM_WRITE) perm |= PTE_W;
-        if ((ret = mm_map(mm, ph->p_va, ph->p_memsz, vm_flags, NULL)) != 0) {
+        if (ph->p_flags & ELF_PF_X)
+            vm_flags |= VM_EXEC;
+        if (ph->p_flags & ELF_PF_W)
+            vm_flags |= VM_WRITE;
+        if (ph->p_flags & ELF_PF_R)
+            vm_flags |= VM_READ;
+        if (vm_flags & VM_WRITE)
+            perm |= PTE_W;
+        if ((ret = mm_map(mm, ph->p_va, ph->p_memsz, vm_flags, NULL)) != 0)
+        {
             goto bad_cleanup_mmap;
         }
         unsigned char *from = binary + ph->p_offset;
@@ -532,42 +651,51 @@
 
         ret = -E_NO_MEM;
 
-     //(3.6) alloc memory, and  copy the contents of every program section (from, from+end) to process's memory (la, la+end)
+        //(3.6) alloc memory, and  copy the contents of every program section (from, from+end) to process's memory (la, la+end)
         end = ph->p_va + ph->p_filesz;
-     //(3.6.1) copy TEXT/DATA section of bianry program
-        while (start < end) {
-            if ((page = pgdir_alloc_page(mm->pgdir, la, perm)) == NULL) {
+        //(3.6.1) copy TEXT/DATA section of bianry program
+        while (start < end)
+        {
+            if ((page = pgdir_alloc_page(mm->pgdir, la, perm)) == NULL)
+            {
                 goto bad_cleanup_mmap;
             }
             off = start - la, size = PGSIZE - off, la += PGSIZE;
-            if (end < la) {
+            if (end < la)
+            {
                 size -= la - end;
             }
             memcpy(page2kva(page) + off, from, size);
             start += size, from += size;
         }
 
-      //(3.6.2) build BSS section of binary program
+        //(3.6.2) build BSS section of binary program
         end = ph->p_va + ph->p_memsz;
-        if (start < la) {
+        if (start < la)
+        {
             /* ph->p_memsz == ph->p_filesz */
-            if (start == end) {
-                continue ;
+            if (start == end)
+            {
+                continue;
             }
             off = start + PGSIZE - la, size = PGSIZE - off;
-            if (end < la) {
+            if (end < la)
+            {
                 size -= la - end;
             }
             memset(page2kva(page) + off, 0, size);
             start += size;
             assert((end < la && start == end) || (end >= la && start == la));
         }
-        while (start < end) {
-            if ((page = pgdir_alloc_page(mm->pgdir, la, perm)) == NULL) {
+        while (start < end)
+        {
+            if ((page = pgdir_alloc_page(mm->pgdir, la, perm)) == NULL)
+            {
                 goto bad_cleanup_mmap;
             }
             off = start - la, size = PGSIZE - off, la += PGSIZE;
-            if (end < la) {
+            if (end < la)
+            {
                 size -= la - end;
             }
             memset(page2kva(page) + off, 0, size);
@@ -576,14 +704,15 @@
     }
     //(4) build user stack memory
     vm_flags = VM_READ | VM_WRITE | VM_STACK;
-    if ((ret = mm_map(mm, USTACKTOP - USTACKSIZE, USTACKSIZE, vm_flags, NULL)) != 0) {
+    if ((ret = mm_map(mm, USTACKTOP - USTACKSIZE, USTACKSIZE, vm_flags, NULL)) != 0)
+    {
         goto bad_cleanup_mmap;
     }
-    assert(pgdir_alloc_page(mm->pgdir, USTACKTOP-PGSIZE , PTE_USER) != NULL);
-    assert(pgdir_alloc_page(mm->pgdir, USTACKTOP-2*PGSIZE , PTE_USER) != NULL);
-    assert(pgdir_alloc_page(mm->pgdir, USTACKTOP-3*PGSIZE , PTE_USER) != NULL);
-    assert(pgdir_alloc_page(mm->pgdir, USTACKTOP-4*PGSIZE , PTE_USER) != NULL);
-    
+    assert(pgdir_alloc_page(mm->pgdir, USTACKTOP - PGSIZE, PTE_USER) != NULL);
+    assert(pgdir_alloc_page(mm->pgdir, USTACKTOP - 2 * PGSIZE, PTE_USER) != NULL);
+    assert(pgdir_alloc_page(mm->pgdir, USTACKTOP - 3 * PGSIZE, PTE_USER) != NULL);
+    assert(pgdir_alloc_page(mm->pgdir, USTACKTOP - 4 * PGSIZE, PTE_USER) != NULL);
+
     //(5) set current process's mm, sr3, and set CR3 reg = physical addr of Page Directory
     mm_count_inc(mm);
     current->mm = mm;
@@ -602,6 +731,12 @@
      *          tf_eip should be the entry point of this binary program (elf->e_entry)
      *          tf_eflags should be set to enable computer to produce Interrupt
      */
+    tf->tf_cs = USER_CS;
+    tf->tf_ds = tf->tf_es = tf->tf_ss = USER_DS;
+    tf->tf_esp = USTACKTOP;
+    tf->tf_eip = elf->e_entry;
+    tf->tf_eflags |= FL_IF;
+    tf->tf_eflags |= 0x2;
     ret = 0;
 out:
     return ret;
@@ -617,13 +752,15 @@
 
 // do_execve - call exit_mmap(mm)&put_pgdir(mm) to reclaim memory space of current process
 //           - call load_icode to setup new memory space accroding binary prog.
-int
-do_execve(const char *name, size_t len, unsigned char *binary, size_t size) {
+int do_execve(const char *name, size_t len, unsigned char *binary, size_t size)
+{
     struct mm_struct *mm = current->mm;
-    if (!user_mem_check(mm, (uintptr_t)name, len, 0)) {
+    if (!user_mem_check(mm, (uintptr_t)name, len, 0))
+    {
         return -E_INVAL;
     }
-    if (len > PROC_NAME_LEN) {
+    if (len > PROC_NAME_LEN)
+    {
         len = PROC_NAME_LEN;
     }
 
@@ -631,9 +768,11 @@
     memset(local_name, 0, sizeof(local_name));
     memcpy(local_name, name, len);
 
-    if (mm != NULL) {
+    if (mm != NULL)
+    {
         lcr3(boot_cr3);
-        if (mm_count_dec(mm) == 0) {
+        if (mm_count_dec(mm) == 0)
+        {
             exit_mmap(mm);
             put_pgdir(mm);
             mm_destroy(mm);
@@ -641,7 +780,8 @@
         current->mm = NULL;
     }
     int ret;
-    if ((ret = load_icode(binary, size)) != 0) {
+    if ((ret = load_icode(binary, size)) != 0)
+    {
         goto execve_exit;
     }
     set_proc_name(current, local_name);
@@ -653,8 +793,8 @@
 }
 
 // do_yield - ask the scheduler to reschedule
-int
-do_yield(void) {
+int do_yield(void)
+{
     current->need_resched = 1;
     return 0;
 }
@@ -662,11 +802,13 @@
 // do_wait - wait one OR any children with PROC_ZOMBIE state, and free memory space of kernel stack
 //         - proc struct of this child.
 // NOTE: only after do_wait function, all resources of the child proces are free.
-int
-do_wait(int pid, int *code_store) {
+int do_wait(int pid, int *code_store)
+{
     struct mm_struct *mm = current->mm;
-    if (code_store != NULL) {
-        if (!user_mem_check(mm, (uintptr_t)code_store, sizeof(int), 1)) {
+    if (code_store != NULL)
+    {
+        if (!user_mem_check(mm, (uintptr_t)code_store, sizeof(int), 1))
+        {
             return -E_INVAL;
         }
     }
@@ -675,29 +817,37 @@
     bool intr_flag, haskid;
 repeat:
     haskid = 0;
-    if (pid != 0) {
+    if (pid != 0)
+    {
         proc = find_proc(pid);
-        if (proc != NULL && proc->parent == current) {
+        if (proc != NULL && proc->parent == current)
+        {
             haskid = 1;
-            if (proc->state == PROC_ZOMBIE) {
+            if (proc->state == PROC_ZOMBIE)
+            {
                 goto found;
             }
         }
     }
-    else {
+    else
+    {
         proc = current->cptr;
-        for (; proc != NULL; proc = proc->optr) {
+        for (; proc != NULL; proc = proc->optr)
+        {
             haskid = 1;
-            if (proc->state == PROC_ZOMBIE) {
+            if (proc->state == PROC_ZOMBIE)
+            {
                 goto found;
             }
         }
     }
-    if (haskid) {
+    if (haskid)
+    {
         current->state = PROC_SLEEPING;
         current->wait_state = WT_CHILD;
         schedule();
-        if (current->flags & PF_EXITING) {
+        if (current->flags & PF_EXITING)
+        {
             do_exit(-E_KILLED);
         }
         goto repeat;
@@ -705,10 +855,12 @@
     return -E_BAD_PROC;
 
 found:
-    if (proc == idleproc || proc == initproc) {
+    if (proc == idleproc || proc == initproc)
+    {
         panic("wait idleproc or initproc.\n");
     }
-    if (code_store != NULL) {
+    if (code_store != NULL)
+    {
         *code_store = proc->exit_code;
     }
     local_intr_save(intr_flag);
@@ -723,13 +875,16 @@
 }
 
 // do_kill - kill process with pid by set this process's flags with PF_EXITING
-int
-do_kill(int pid) {
+int do_kill(int pid)
+{
     struct proc_struct *proc;
-    if ((proc = find_proc(pid)) != NULL) {
-        if (!(proc->flags & PF_EXITING)) {
+    if ((proc = find_proc(pid)) != NULL)
+    {
+        if (!(proc->flags & PF_EXITING))
+        {
             proc->flags |= PF_EXITING;
-            if (proc->wait_state & WT_INTERRUPTED) {
+            if (proc->wait_state & WT_INTERRUPTED)
+            {
                 wakeup_proc(proc);
             }
             return 0;
@@ -741,39 +896,41 @@
 
 // kernel_execve - do SYS_exec syscall to exec a user program called by user_main kernel_thread
 static int
-kernel_execve(const char *name, unsigned char *binary, size_t size) {
+kernel_execve(const char *name, unsigned char *binary, size_t size)
+{
     int ret, len = strlen(name);
-    asm volatile (
+    asm volatile(
         "int %1;"
-        : "=a" (ret)
-        : "i" (T_SYSCALL), "0" (SYS_exec), "d" (name), "c" (len), "b" (binary), "D" (size)
+        : "=a"(ret)
+        : "i"(T_SYSCALL), "0"(SYS_exec), "d"(name), "c"(len), "b"(binary), "D"(size)
         : "memory");
     return ret;
 }
 
-#define __KERNEL_EXECVE(name, binary, size) ({                          \
-            cprintf("kernel_execve: pid = %d, name = \"%s\".\n",        \
-                    current->pid, name);                                \
-            kernel_execve(name, binary, (size_t)(size));                \
-        })
-
-#define KERNEL_EXECVE(x) ({                                             \
-            extern unsigned char _binary_obj___user_##x##_out_start[],  \
-                _binary_obj___user_##x##_out_size[];                    \
-            __KERNEL_EXECVE(#x, _binary_obj___user_##x##_out_start,     \
-                            _binary_obj___user_##x##_out_size);         \
-        })
-
-#define __KERNEL_EXECVE2(x, xstart, xsize) ({                           \
-            extern unsigned char xstart[], xsize[];                     \
-            __KERNEL_EXECVE(#x, xstart, (size_t)xsize);                 \
-        })
+#define __KERNEL_EXECVE(name, binary, size) ({           \
+    cprintf("kernel_execve: pid = %d, name = \"%s\".\n", \
+            current->pid, name);                         \
+    kernel_execve(name, binary, (size_t)(size));         \
+})
+
+#define KERNEL_EXECVE(x) ({                                    \
+    extern unsigned char _binary_obj___user_##x##_out_start[], \
+        _binary_obj___user_##x##_out_size[];                   \
+    __KERNEL_EXECVE(#x, _binary_obj___user_##x##_out_start,    \
+                    _binary_obj___user_##x##_out_size);        \
+})
+
+#define __KERNEL_EXECVE2(x, xstart, xsize) ({   \
+    extern unsigned char xstart[], xsize[];     \
+    __KERNEL_EXECVE(#x, xstart, (size_t)xsize); \
+})
 
-#define KERNEL_EXECVE2(x, xstart, xsize)        __KERNEL_EXECVE2(x, xstart, xsize)
+#define KERNEL_EXECVE2(x, xstart, xsize) __KERNEL_EXECVE2(x, xstart, xsize)
 
 // user_main - kernel thread used to exec a user program
 static int
-user_main(void *arg) {
+user_main(void *arg)
+{
 #ifdef TEST
     KERNEL_EXECVE2(TEST, TESTSTART, TESTSIZE);
 #else
@@ -784,16 +941,19 @@
 
 // init_main - the second kernel thread used to create user_main kernel threads
 static int
-init_main(void *arg) {
+init_main(void *arg)
+{
     size_t nr_free_pages_store = nr_free_pages();
     size_t kernel_allocated_store = kallocated();
 
     int pid = kernel_thread(user_main, NULL, 0);
-    if (pid <= 0) {
+    if (pid <= 0)
+    {
         panic("create user_main failed.\n");
     }
 
-    while (do_wait(0, NULL) == 0) {
+    while (do_wait(0, NULL) == 0)
+    {
         schedule();
     }
 
@@ -807,18 +967,20 @@
     return 0;
 }
 
-// proc_init - set up the first kernel thread idleproc "idle" by itself and 
+// proc_init - set up the first kernel thread idleproc "idle" by itself and
 //           - create the second kernel thread init_main
-void
-proc_init(void) {
+void proc_init(void)
+{
     int i;
 
     list_init(&proc_list);
-    for (i = 0; i < HASH_LIST_SIZE; i ++) {
+    for (i = 0; i < HASH_LIST_SIZE; i++)
+    {
         list_init(hash_list + i);
     }
 
-    if ((idleproc = alloc_proc()) == NULL) {
+    if ((idleproc = alloc_proc()) == NULL)
+    {
         panic("cannot alloc idleproc.\n");
     }
 
@@ -827,12 +989,13 @@
     idleproc->kstack = (uintptr_t)bootstack;
     idleproc->need_resched = 1;
     set_proc_name(idleproc, "idle");
-    nr_process ++;
+    nr_process++;
 
     current = idleproc;
 
     int pid = kernel_thread(init_main, NULL, 0);
-    if (pid <= 0) {
+    if (pid <= 0)
+    {
         panic("create init_main failed.\n");
     }
 
@@ -844,12 +1007,13 @@
 }
 
 // cpu_idle - at the end of kern_init, the first kernel thread idleproc will do below works
-void
-cpu_idle(void) {
-    while (1) {
-        if (current->need_resched) {
+void cpu_idle(void)
+{
+    while (1)
+    {
+        if (current->need_resched)
+        {
             schedule();
         }
     }
 }
-
diff -ruP /home/xmh/origin/ucore_os_lab/labcodes/lab5/kern/trap/trap.c lab5/kern/trap/trap.c
--- /home/xmh/origin/ucore_os_lab/labcodes/lab5/kern/trap/trap.c	2020-05-24 07:28:36.518368873 +0000
+++ lab5/kern/trap/trap.c	2020-05-24 05:52:40.472948399 +0000
@@ -18,8 +18,9 @@
 
 #define TICK_NUM 100
 
-static void print_ticks() {
-    cprintf("%d ticks\n",TICK_NUM);
+static void print_ticks()
+{
+    cprintf("%d ticks\n", TICK_NUM);
 #ifdef DEBUG_GRADE
     cprintf("End of Test.\n");
     panic("EOT: kernel seems ok.");
@@ -35,14 +36,13 @@
 static struct gatedesc idt[256] = {{0}};
 
 static struct pseudodesc idt_pd = {
-    sizeof(idt) - 1, (uintptr_t)idt
-};
+    sizeof(idt) - 1, (uintptr_t)idt};
 
 /* idt_init - initialize IDT to each of the entry points in kern/trap/vectors.S */
-void
-idt_init(void) {
-     /* LAB1 YOUR CODE : STEP 2 */
-     /* (1) Where are the entry addrs of each Interrupt Service Routine (ISR)?
+void idt_init(void)
+{
+    /* LAB1 YOUR CODE : STEP 2 */
+    /* (1) Where are the entry addrs of each Interrupt Service Routine (ISR)?
       *     All ISR's entry addrs are stored in __vectors. where is uintptr_t __vectors[] ?
       *     __vectors[] is in kern/trap/vector.S which is produced by tools/vector.c
       *     (try "make" command in lab1, then you will find vector.S in kern/trap DIR)
@@ -53,14 +53,24 @@
       *     You don't know the meaning of this instruction? just google it! and check the libs/x86.h to know more.
       *     Notice: the argument of lidt is idt_pd. try to find it!
       */
-     /* LAB5 YOUR CODE */ 
-     //you should update your lab1 code (just add ONE or TWO lines of code), let user app to use syscall to get the service of ucore
-     //so you should setup the syscall interrupt gate in here
+    extern uintptr_t __vectors[];
+    int i;
+    for (i = 0; i < 256; i++)
+    {
+        SETGATE(idt[i], 0, GD_KTEXT, __vectors[i], DPL_KERNEL);
+    }
+    SETGATE(idt[T_SWITCH_TOK], 0, GD_KTEXT, __vectors[T_SWITCH_TOK], DPL_USER);
+    SETGATE(idt[T_SYSCALL], 1, GD_KTEXT, __vectors[T_SYSCALL], DPL_USER);
+    lidt(&idt_pd);
+    /* LAB5 YOUR CODE */
+    //you should update your lab1 code (just add ONE or TWO lines of code), let user app to use syscall to get the service of ucore
+    //so you should setup the syscall interrupt gate in here
 }
 
 static const char *
-trapname(int trapno) {
-    static const char * const excnames[] = {
+trapname(int trapno)
+{
+    static const char *const excnames[] = {
         "Divide error",
         "Debug",
         "Non-Maskable Interrupt",
@@ -80,32 +90,54 @@
         "x87 FPU Floating-Point Error",
         "Alignment Check",
         "Machine-Check",
-        "SIMD Floating-Point Exception"
-    };
+        "SIMD Floating-Point Exception"};
 
-    if (trapno < sizeof(excnames)/sizeof(const char * const)) {
+    if (trapno < sizeof(excnames) / sizeof(const char *const))
+    {
         return excnames[trapno];
     }
-    if (trapno >= IRQ_OFFSET && trapno < IRQ_OFFSET + 16) {
+    if (trapno >= IRQ_OFFSET && trapno < IRQ_OFFSET + 16)
+    {
         return "Hardware Interrupt";
     }
     return "(unknown trap)";
 }
 
 /* trap_in_kernel - test if trap happened in kernel */
-bool
-trap_in_kernel(struct trapframe *tf) {
+bool trap_in_kernel(struct trapframe *tf)
+{
     return (tf->tf_cs == (uint16_t)KERNEL_CS);
 }
 
 static const char *IA32flags[] = {
-    "CF", NULL, "PF", NULL, "AF", NULL, "ZF", "SF",
-    "TF", "IF", "DF", "OF", NULL, NULL, "NT", NULL,
-    "RF", "VM", "AC", "VIF", "VIP", "ID", NULL, NULL,
+    "CF",
+    NULL,
+    "PF",
+    NULL,
+    "AF",
+    NULL,
+    "ZF",
+    "SF",
+    "TF",
+    "IF",
+    "DF",
+    "OF",
+    NULL,
+    NULL,
+    "NT",
+    NULL,
+    "RF",
+    "VM",
+    "AC",
+    "VIF",
+    "VIP",
+    "ID",
+    NULL,
+    NULL,
 };
 
-void
-print_trapframe(struct trapframe *tf) {
+void print_trapframe(struct trapframe *tf)
+{
     cprintf("trapframe at %p\n", tf);
     print_regs(&tf->tf_regs);
     cprintf("  ds   0x----%04x\n", tf->tf_ds);
@@ -119,21 +151,24 @@
     cprintf("  flag 0x%08x ", tf->tf_eflags);
 
     int i, j;
-    for (i = 0, j = 1; i < sizeof(IA32flags) / sizeof(IA32flags[0]); i ++, j <<= 1) {
-        if ((tf->tf_eflags & j) && IA32flags[i] != NULL) {
+    for (i = 0, j = 1; i < sizeof(IA32flags) / sizeof(IA32flags[0]); i++, j <<= 1)
+    {
+        if ((tf->tf_eflags & j) && IA32flags[i] != NULL)
+        {
             cprintf("%s,", IA32flags[i]);
         }
     }
     cprintf("IOPL=%d\n", (tf->tf_eflags & FL_IOPL_MASK) >> 12);
 
-    if (!trap_in_kernel(tf)) {
+    if (!trap_in_kernel(tf))
+    {
         cprintf("  esp  0x%08x\n", tf->tf_esp);
         cprintf("  ss   0x----%04x\n", tf->tf_ss);
     }
 }
 
-void
-print_regs(struct pushregs *regs) {
+void print_regs(struct pushregs *regs)
+{
     cprintf("  edi  0x%08x\n", regs->reg_edi);
     cprintf("  esi  0x%08x\n", regs->reg_esi);
     cprintf("  ebp  0x%08x\n", regs->reg_ebp);
@@ -145,7 +180,8 @@
 }
 
 static inline void
-print_pgfault(struct trapframe *tf) {
+print_pgfault(struct trapframe *tf)
+{
     /* error_code:
      * bit 0 == 0 means no page found, 1 means protection fault
      * bit 1 == 0 means read, 1 means write
@@ -158,18 +194,23 @@
 }
 
 static int
-pgfault_handler(struct trapframe *tf) {
+pgfault_handler(struct trapframe *tf)
+{
     extern struct mm_struct *check_mm_struct;
-    if(check_mm_struct !=NULL) { //used for test check_swap
-            print_pgfault(tf);
-        }
+    if (check_mm_struct != NULL)
+    { //used for test check_swap
+        print_pgfault(tf);
+    }
     struct mm_struct *mm;
-    if (check_mm_struct != NULL) {
+    if (check_mm_struct != NULL)
+    {
         assert(current == idleproc);
         mm = check_mm_struct;
     }
-    else {
-        if (current == NULL) {
+    else
+    {
+        if (current == NULL)
+        {
             print_trapframe(tf);
             print_pgfault(tf);
             panic("unhandled page fault.\n");
@@ -182,25 +223,34 @@
 static volatile int in_swap_tick_event = 0;
 extern struct mm_struct *check_mm_struct;
 
+/* temporary trapframe or pointer to trapframe */
+struct trapframe switchk2u, *switchu2k;
+
 static void
-trap_dispatch(struct trapframe *tf) {
+trap_dispatch(struct trapframe *tf)
+{
     char c;
 
-    int ret=0;
+    int ret = 0;
 
-    switch (tf->tf_trapno) {
-    case T_PGFLT:  //page fault
-        if ((ret = pgfault_handler(tf)) != 0) {
+    switch (tf->tf_trapno)
+    {
+    case T_PGFLT: //page fault
+        if ((ret = pgfault_handler(tf)) != 0)
+        {
             print_trapframe(tf);
-            if (current == NULL) {
+            if (current == NULL)
+            {
                 panic("handle pgfault failed. ret=%d\n", ret);
             }
-            else {
-                if (trap_in_kernel(tf)) {
+            else
+            {
+                if (trap_in_kernel(tf))
+                {
                     panic("handle pgfault failed in kernel mode. ret=%d\n", ret);
                 }
                 cprintf("killed by kernel.\n");
-                panic("handle user mode pgfault failed. ret=%d\n", ret); 
+                panic("handle user mode pgfault failed. ret=%d\n", ret);
                 do_exit(-E_KILLED);
             }
         }
@@ -211,7 +261,7 @@
     case IRQ_OFFSET + IRQ_TIMER:
 #if 0
     LAB3 : If some page replacement algorithm(such as CLOCK PRA) need tick to change the priority of pages,
-    then you can add code here. 
+    then you can add code here.
 #endif
         /* LAB1 YOUR CODE : STEP 3 */
         /* handle the timer interrupt */
@@ -219,11 +269,18 @@
          * (2) Every TICK_NUM cycle, you can print some info using a funciton, such as print_ticks().
          * (3) Too Simple? Yes, I think so!
          */
+        ticks++;
+        if (ticks % TICK_NUM == 0)
+        {
+            // print_ticks();
+            assert(current != NULL);
+            current->need_resched = 1;
+        }
         /* LAB5 YOUR CODE */
         /* you should upate you lab1 code (just add ONE or TWO lines of code):
          *    Every TICK_NUM cycle, you should set current process's current->need_resched = 1
          */
-  
+
         break;
     case IRQ_OFFSET + IRQ_COM1:
         c = cons_getc();
@@ -235,8 +292,29 @@
         break;
     //LAB1 CHALLENGE 1 : YOUR CODE you should modify below codes.
     case T_SWITCH_TOU:
+        if (tf->tf_cs != USER_CS)
+        {
+            switchk2u = *tf;
+            switchk2u.tf_cs = USER_CS;
+            switchk2u.tf_ds = USER_DS;
+            switchk2u.tf_es = USER_DS;
+            switchk2u.tf_ss = USER_DS;
+            switchk2u.tf_esp = (uint32_t)tf + sizeof(struct trapframe) - 8;
+            switchk2u.tf_eflags |= FL_IOPL_MASK;
+            *((uint32_t *)tf - 1) = (uint32_t)&switchk2u;
+        }
+        break;
     case T_SWITCH_TOK:
-        panic("T_SWITCH_** ??\n");
+        if (tf->tf_cs != KERNEL_CS)
+        {
+            tf->tf_cs = KERNEL_CS;
+            tf->tf_ds = KERNEL_DS;
+            tf->tf_es = KERNEL_DS;
+            tf->tf_eflags &= ~FL_IOPL_MASK;
+            switchu2k = (struct trapframe *)(tf->tf_esp - (sizeof(struct trapframe) - 8));
+            memmove(switchu2k, tf, sizeof(struct trapframe) - 8);
+            *((uint32_t *)tf - 1) = (uint32_t)switchu2k;
+        }
         break;
     case IRQ_OFFSET + IRQ_IDE1:
     case IRQ_OFFSET + IRQ_IDE2:
@@ -244,13 +322,13 @@
         break;
     default:
         print_trapframe(tf);
-        if (current != NULL) {
+        if (current != NULL)
+        {
             cprintf("unhandled trap.\n");
             do_exit(-E_KILLED);
         }
         // in kernel, it must be a mistake
         panic("unexpected trap in kernel.\n");
-
     }
 }
 
@@ -259,31 +337,35 @@
  * the code in kern/trap/trapentry.S restores the old CPU state saved in the
  * trapframe and then uses the iret instruction to return from the exception.
  * */
-void
-trap(struct trapframe *tf) {
+void trap(struct trapframe *tf)
+{
     // dispatch based on what type of trap occurred
     // used for previous projects
-    if (current == NULL) {
+    if (current == NULL)
+    {
         trap_dispatch(tf);
     }
-    else {
+    else
+    {
         // keep a trapframe chain in stack
         struct trapframe *otf = current->tf;
         current->tf = tf;
-    
+
         bool in_kernel = trap_in_kernel(tf);
-    
+
         trap_dispatch(tf);
-    
+
         current->tf = otf;
-        if (!in_kernel) {
-            if (current->flags & PF_EXITING) {
+        if (!in_kernel)
+        {
+            if (current->flags & PF_EXITING)
+            {
                 do_exit(-E_KILLED);
             }
-            if (current->need_resched) {
+            if (current->need_resched)
+            {
                 schedule();
             }
         }
     }
 }
-
diff -ruP /home/xmh/origin/ucore_os_lab/labcodes/lab5/Makefile lab5/Makefile
--- /home/xmh/origin/ucore_os_lab/labcodes/lab5/Makefile	2020-05-24 07:28:36.514368823 +0000
+++ lab5/Makefile	2020-05-24 04:46:31.097918010 +0000
@@ -265,7 +265,7 @@
 
 .DEFAULT_GOAL := TARGETS
 
-QEMUOPTS = -hda $(UCOREIMG) -drive file=$(SWAPIMG),media=disk,cache=writeback
+QEMUOPTS = -hda $(UCOREIMG) -drive file=$(SWAPIMG),media=disk,cache=writeback -curses
 
 .PHONY: qemu qemu-nox debug debug-nox
 qemu-mon: $(UCOREIMG) $(SWAPIMG)
diff -ruP /home/xmh/origin/ucore_os_lab/labcodes/lab5/.pgdir.log lab5/.pgdir.log
--- /home/xmh/origin/ucore_os_lab/labcodes/lab5/.pgdir.log	1970-01-01 00:00:00.000000000 +0000
+++ lab5/.pgdir.log	2020-05-24 07:22:37.549997904 +0000
@@ -0,0 +1,128 @@
+(THU.CST) os is loading ...
+
+Special kernel symbols:
+  entry  0xc0100036 (phys)
+  etext  0xc010c002 (phys)
+  edata  0xc019f000 (phys)
+  end    0xc01a21b8 (phys)
+Kernel executable memory footprint: 649KB
+ebp:0xc012af38   eip:0xc0100ba9 arg :0x00010094 0x00010094 0xc012af68 0xc01000df
+    kern/debug/kdebug.c:351: print_stackframe+22
+ebp:0xc012af48   eip:0xc0100e9d arg :0x00000000 0x00000000 0x00000000 0xc012afb8
+    kern/debug/kmonitor.c:129: mon_backtrace+10
+ebp:0xc012af68   eip:0xc01000df arg :0x00000000 0xc012af90 0xffff0000 0xc012af94
+    kern/init/init.c:58: grade_backtrace2+33
+ebp:0xc012af88   eip:0xc0100109 arg :0x00000000 0xffff0000 0xc012afb4 0x0000002a
+    kern/init/init.c:63: grade_backtrace1+38
+ebp:0xc012afa8   eip:0xc0100128 arg :0x00000000 0xc0100036 0xffff0000 0x0000001d
+    kern/init/init.c:68: grade_backtrace0+23
+ebp:0xc012afc8   eip:0xc010014e arg :0xc010c03c 0xc010c020 0x000031b8 0x00000000
+    kern/init/init.c:73: grade_backtrace+34
+ebp:0xc012aff8   eip:0xc010008b arg :0xc010c234 0xc010c23c 0xc0100e25 0xc010c25b
+    kern/init/init.c:33: kern_init+84
+memory management: default_pmm_manager
+e820map:
+  memory: 0009fc00, [00000000, 0009fbff], type = 1.
+  memory: 00000400, [0009fc00, 0009ffff], type = 2.
+  memory: 00010000, [000f0000, 000fffff], type = 2.
+  memory: 07ee0000, [00100000, 07fdffff], type = 1.
+  memory: 00020000, [07fe0000, 07ffffff], type = 2.
+  memory: 00040000, [fffc0000, ffffffff], type = 2.
+check_alloc_page() succeeded!
+check_pgdir() succeeded!
+check_boot_pgdir() succeeded!
+-------------------- BEGIN --------------------
+PDE(0e0) c0000000-f8000000 38000000 urw
+  |-- PTE(38000) c0000000-f8000000 38000000 -rw
+PDE(001) fac00000-fb000000 00400000 -rw
+  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw
+  |-- PTE(00001) fafeb000-fafec000 00001000 -rw
+--------------------- END ---------------------
+use SLOB allocator
+kmalloc_init() succeeded!
+check_vma_struct() succeeded!
+page fault at 0x00000100: K/W [no page found].
+check_pgfault() succeeded!
+check_vmm() succeeded.
+ide 0:      10000(sectors), 'QEMU HARDDISK'.
+ide 1:     262144(sectors), 'QEMU HARDDISK'.
+SWAP: manager = fifo swap manager
+BEGIN check_swap: count 1, total 31835
+setup Page Table for vaddr 0X1000, so alloc a page
+setup Page Table vaddr 0~4MB OVER!
+set up init env for check_swap begin!
+page fault at 0x00001000: K/W [no page found].
+page fault at 0x00002000: K/W [no page found].
+page fault at 0x00003000: K/W [no page found].
+page fault at 0x00004000: K/W [no page found].
+set up init env for check_swap over!
+write Virt Page c in fifo_check_swap
+write Virt Page a in fifo_check_swap
+write Virt Page d in fifo_check_swap
+write Virt Page b in fifo_check_swap
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+write Virt Page b in fifo_check_swap
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+write Virt Page b in fifo_check_swap
+page fault at 0x00002000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x3000 to disk swap entry 4
+swap_in: load disk swap entry 3 with swap_page in vadr 0x2000
+write Virt Page c in fifo_check_swap
+page fault at 0x00003000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x4000 to disk swap entry 5
+swap_in: load disk swap entry 4 with swap_page in vadr 0x3000
+write Virt Page d in fifo_check_swap
+page fault at 0x00004000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x5000 to disk swap entry 6
+swap_in: load disk swap entry 5 with swap_page in vadr 0x4000
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+swap_in: load disk swap entry 6 with swap_page in vadr 0x5000
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/R [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+count is 0, total is 5
+check_swap() succeeded!
+++ setup timer interrupts
+kernel_execve: pid = 2, name = "pgdir".
+I am 2, print pgdir.
+-------------------- BEGIN --------------------
+PDE(001) 00000000-00400000 00400000 urw
+  |-- PTE(00004) 00200000-00204000 00004000 urw
+PDE(001) 00800000-00c00000 00400000 urw
+  |-- PTE(00002) 00800000-00802000 00002000 ur-
+  |-- PTE(00001) 00802000-00803000 00001000 urw
+PDE(001) afc00000-b0000000 00400000 urw
+  |-- PTE(00004) afffc000-b0000000 00004000 urw
+PDE(0e0) c0000000-f8000000 38000000 urw
+  |-- PTE(38000) c0000000-f8000000 38000000 -rw
+PDE(001) fac00000-fb000000 00400000 -rw
+  |-- PTE(00001) fac00000-fac01000 00001000 urw
+  |-- PTE(00001) fac02000-fac03000 00001000 urw
+  |-- PTE(00001) faebf000-faec0000 00001000 urw
+  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw
+  |-- PTE(00001) fafeb000-fafec000 00001000 -rw
+--------------------- END ---------------------
+pgdir pass.
+all user-mode processes have quit.
+init check memory pass.
+kernel panic at kern/process/proc.c:525:
+    initproc exit.
+
+stack trackback:
+ebp:0xc0384f88   eip:0xc0100ba9 arg :0xc010c0e8 0xc0384fcc 0x0000020d 0xc0384fb8
+    kern/debug/kdebug.c:351: print_stackframe+22
+ebp:0xc0384fb8   eip:0xc0100468 arg :0xc010e0cc 0x0000020d 0xc010e11e 0x00000000
+    kern/debug/panic.c:27: __panic+103
+ebp:0xc0384fe8   eip:0xc010a151 arg :0x00000000 0x00000000 0x00000000 0x00000010
+    kern/process/proc.c:525: do_exit+91
+Welcome to the kernel debug monitor!!
+Type 'help' for a list of commands.
+K> 
\ 文件尾没有换行符
diff -ruP /home/xmh/origin/ucore_os_lab/labcodes/lab5/.softint.log lab5/.softint.log
--- /home/xmh/origin/ucore_os_lab/labcodes/lab5/.softint.log	1970-01-01 00:00:00.000000000 +0000
+++ lab5/.softint.log	2020-05-24 07:22:28.305848780 +0000
@@ -0,0 +1,130 @@
+(THU.CST) os is loading ...
+
+Special kernel symbols:
+  entry  0xc0100036 (phys)
+  etext  0xc010c002 (phys)
+  edata  0xc019f000 (phys)
+  end    0xc01a21b8 (phys)
+Kernel executable memory footprint: 649KB
+ebp:0xc012af38   eip:0xc0100ba9 arg :0x00010094 0x00010094 0xc012af68 0xc01000df
+    kern/debug/kdebug.c:351: print_stackframe+22
+ebp:0xc012af48   eip:0xc0100e9d arg :0x00000000 0x00000000 0x00000000 0xc012afb8
+    kern/debug/kmonitor.c:129: mon_backtrace+10
+ebp:0xc012af68   eip:0xc01000df arg :0x00000000 0xc012af90 0xffff0000 0xc012af94
+    kern/init/init.c:58: grade_backtrace2+33
+ebp:0xc012af88   eip:0xc0100109 arg :0x00000000 0xffff0000 0xc012afb4 0x0000002a
+    kern/init/init.c:63: grade_backtrace1+38
+ebp:0xc012afa8   eip:0xc0100128 arg :0x00000000 0xc0100036 0xffff0000 0x0000001d
+    kern/init/init.c:68: grade_backtrace0+23
+ebp:0xc012afc8   eip:0xc010014e arg :0xc010c03c 0xc010c020 0x000031b8 0x00000000
+    kern/init/init.c:73: grade_backtrace+34
+ebp:0xc012aff8   eip:0xc010008b arg :0xc010c234 0xc010c23c 0xc0100e25 0xc010c25b
+    kern/init/init.c:33: kern_init+84
+memory management: default_pmm_manager
+e820map:
+  memory: 0009fc00, [00000000, 0009fbff], type = 1.
+  memory: 00000400, [0009fc00, 0009ffff], type = 2.
+  memory: 00010000, [000f0000, 000fffff], type = 2.
+  memory: 07ee0000, [00100000, 07fdffff], type = 1.
+  memory: 00020000, [07fe0000, 07ffffff], type = 2.
+  memory: 00040000, [fffc0000, ffffffff], type = 2.
+check_alloc_page() succeeded!
+check_pgdir() succeeded!
+check_boot_pgdir() succeeded!
+-------------------- BEGIN --------------------
+PDE(0e0) c0000000-f8000000 38000000 urw
+  |-- PTE(38000) c0000000-f8000000 38000000 -rw
+PDE(001) fac00000-fb000000 00400000 -rw
+  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw
+  |-- PTE(00001) fafeb000-fafec000 00001000 -rw
+--------------------- END ---------------------
+use SLOB allocator
+kmalloc_init() succeeded!
+check_vma_struct() succeeded!
+page fault at 0x00000100: K/W [no page found].
+check_pgfault() succeeded!
+check_vmm() succeeded.
+ide 0:      10000(sectors), 'QEMU HARDDISK'.
+ide 1:     262144(sectors), 'QEMU HARDDISK'.
+SWAP: manager = fifo swap manager
+BEGIN check_swap: count 1, total 31835
+setup Page Table for vaddr 0X1000, so alloc a page
+setup Page Table vaddr 0~4MB OVER!
+set up init env for check_swap begin!
+page fault at 0x00001000: K/W [no page found].
+page fault at 0x00002000: K/W [no page found].
+page fault at 0x00003000: K/W [no page found].
+page fault at 0x00004000: K/W [no page found].
+set up init env for check_swap over!
+write Virt Page c in fifo_check_swap
+write Virt Page a in fifo_check_swap
+write Virt Page d in fifo_check_swap
+write Virt Page b in fifo_check_swap
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+write Virt Page b in fifo_check_swap
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+write Virt Page b in fifo_check_swap
+page fault at 0x00002000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x3000 to disk swap entry 4
+swap_in: load disk swap entry 3 with swap_page in vadr 0x2000
+write Virt Page c in fifo_check_swap
+page fault at 0x00003000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x4000 to disk swap entry 5
+swap_in: load disk swap entry 4 with swap_page in vadr 0x3000
+write Virt Page d in fifo_check_swap
+page fault at 0x00004000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x5000 to disk swap entry 6
+swap_in: load disk swap entry 5 with swap_page in vadr 0x4000
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+swap_in: load disk swap entry 6 with swap_page in vadr 0x5000
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/R [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+count is 0, total is 5
+check_swap() succeeded!
+++ setup timer interrupts
+kernel_execve: pid = 2, name = "softint".
+trapframe at 0xc038bfb4
+  edi  0x00000000
+  esi  0x00000000
+  ebp  0xafffffa8
+  oesp 0xc038bfd4
+  ebx  0x00000000
+  edx  0x00000000
+  ecx  0x00000000
+  eax  0x00000000
+  ds   0x----0023
+  es   0x----0023
+  fs   0x----0000
+  gs   0x----0000
+  trap 0x0000000d General Protection
+  err  0x00000072
+  eip  0x00800f83
+  cs   0x----001b
+  flag 0x00000286 PF,SF,IF,IOPL=0
+  esp  0xafffff90
+  ss   0x----0023
+unhandled trap.
+all user-mode processes have quit.
+init check memory pass.
+kernel panic at kern/process/proc.c:525:
+    initproc exit.
+
+stack trackback:
+ebp:0xc0384f88   eip:0xc0100ba9 arg :0xc010c0e8 0xc0384fcc 0x0000020d 0xc0384fb8
+    kern/debug/kdebug.c:351: print_stackframe+22
+ebp:0xc0384fb8   eip:0xc0100468 arg :0xc010e0cc 0x0000020d 0xc010e11e 0x00000000
+    kern/debug/panic.c:27: __panic+103
+ebp:0xc0384fe8   eip:0xc010a151 arg :0x00000000 0x00000000 0x00000000 0x00000010
+    kern/process/proc.c:525: do_exit+91
+Welcome to the kernel debug monitor!!
+Type 'help' for a list of commands.
+K> 
\ 文件尾没有换行符
diff -ruP /home/xmh/origin/ucore_os_lab/labcodes/lab5/.spin.log lab5/.spin.log
--- /home/xmh/origin/ucore_os_lab/labcodes/lab5/.spin.log	1970-01-01 00:00:00.000000000 +0000
+++ lab5/.spin.log	2020-05-24 07:22:47.906164934 +0000
@@ -0,0 +1,116 @@
+(THU.CST) os is loading ...
+
+Special kernel symbols:
+  entry  0xc0100036 (phys)
+  etext  0xc010c002 (phys)
+  edata  0xc019f000 (phys)
+  end    0xc01a21b8 (phys)
+Kernel executable memory footprint: 649KB
+ebp:0xc012af38   eip:0xc0100ba9 arg :0x00010094 0x00010094 0xc012af68 0xc01000df
+    kern/debug/kdebug.c:351: print_stackframe+22
+ebp:0xc012af48   eip:0xc0100e9d arg :0x00000000 0x00000000 0x00000000 0xc012afb8
+    kern/debug/kmonitor.c:129: mon_backtrace+10
+ebp:0xc012af68   eip:0xc01000df arg :0x00000000 0xc012af90 0xffff0000 0xc012af94
+    kern/init/init.c:58: grade_backtrace2+33
+ebp:0xc012af88   eip:0xc0100109 arg :0x00000000 0xffff0000 0xc012afb4 0x0000002a
+    kern/init/init.c:63: grade_backtrace1+38
+ebp:0xc012afa8   eip:0xc0100128 arg :0x00000000 0xc0100036 0xffff0000 0x0000001d
+    kern/init/init.c:68: grade_backtrace0+23
+ebp:0xc012afc8   eip:0xc010014e arg :0xc010c03c 0xc010c020 0x000031b8 0x00000000
+    kern/init/init.c:73: grade_backtrace+34
+ebp:0xc012aff8   eip:0xc010008b arg :0xc010c234 0xc010c23c 0xc0100e25 0xc010c25b
+    kern/init/init.c:33: kern_init+84
+memory management: default_pmm_manager
+e820map:
+  memory: 0009fc00, [00000000, 0009fbff], type = 1.
+  memory: 00000400, [0009fc00, 0009ffff], type = 2.
+  memory: 00010000, [000f0000, 000fffff], type = 2.
+  memory: 07ee0000, [00100000, 07fdffff], type = 1.
+  memory: 00020000, [07fe0000, 07ffffff], type = 2.
+  memory: 00040000, [fffc0000, ffffffff], type = 2.
+check_alloc_page() succeeded!
+check_pgdir() succeeded!
+check_boot_pgdir() succeeded!
+-------------------- BEGIN --------------------
+PDE(0e0) c0000000-f8000000 38000000 urw
+  |-- PTE(38000) c0000000-f8000000 38000000 -rw
+PDE(001) fac00000-fb000000 00400000 -rw
+  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw
+  |-- PTE(00001) fafeb000-fafec000 00001000 -rw
+--------------------- END ---------------------
+use SLOB allocator
+kmalloc_init() succeeded!
+check_vma_struct() succeeded!
+page fault at 0x00000100: K/W [no page found].
+check_pgfault() succeeded!
+check_vmm() succeeded.
+ide 0:      10000(sectors), 'QEMU HARDDISK'.
+ide 1:     262144(sectors), 'QEMU HARDDISK'.
+SWAP: manager = fifo swap manager
+BEGIN check_swap: count 1, total 31835
+setup Page Table for vaddr 0X1000, so alloc a page
+setup Page Table vaddr 0~4MB OVER!
+set up init env for check_swap begin!
+page fault at 0x00001000: K/W [no page found].
+page fault at 0x00002000: K/W [no page found].
+page fault at 0x00003000: K/W [no page found].
+page fault at 0x00004000: K/W [no page found].
+set up init env for check_swap over!
+write Virt Page c in fifo_check_swap
+write Virt Page a in fifo_check_swap
+write Virt Page d in fifo_check_swap
+write Virt Page b in fifo_check_swap
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+write Virt Page b in fifo_check_swap
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+write Virt Page b in fifo_check_swap
+page fault at 0x00002000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x3000 to disk swap entry 4
+swap_in: load disk swap entry 3 with swap_page in vadr 0x2000
+write Virt Page c in fifo_check_swap
+page fault at 0x00003000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x4000 to disk swap entry 5
+swap_in: load disk swap entry 4 with swap_page in vadr 0x3000
+write Virt Page d in fifo_check_swap
+page fault at 0x00004000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x5000 to disk swap entry 6
+swap_in: load disk swap entry 5 with swap_page in vadr 0x4000
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+swap_in: load disk swap entry 6 with swap_page in vadr 0x5000
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/R [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+count is 0, total is 5
+check_swap() succeeded!
+++ setup timer interrupts
+kernel_execve: pid = 2, name = "spin".
+I am the parent. Forking the child...
+I am the parent. Running the child...
+I am the child. spinning ...
+I am the parent.  Killing the child...
+kill returns 0
+wait returns 0
+spin may pass.
+all user-mode processes have quit.
+init check memory pass.
+kernel panic at kern/process/proc.c:525:
+    initproc exit.
+
+stack trackback:
+ebp:0xc0384f88   eip:0xc0100ba9 arg :0xc010c0e8 0xc0384fcc 0x0000020d 0xc0384fb8
+    kern/debug/kdebug.c:351: print_stackframe+22
+ebp:0xc0384fb8   eip:0xc0100468 arg :0xc010e0cc 0x0000020d 0xc010e11e 0x00000000
+    kern/debug/panic.c:27: __panic+103
+ebp:0xc0384fe8   eip:0xc010a151 arg :0x00000000 0x00000000 0x00000000 0x00000010
+    kern/process/proc.c:525: do_exit+91
+Welcome to the kernel debug monitor!!
+Type 'help' for a list of commands.
+K> 
\ 文件尾没有换行符
diff -ruP /home/xmh/origin/ucore_os_lab/labcodes/lab5/.testbss.log lab5/.testbss.log
--- /home/xmh/origin/ucore_os_lab/labcodes/lab5/.testbss.log	1970-01-01 00:00:00.000000000 +0000
+++ lab5/.testbss.log	2020-05-24 07:22:35.701968096 +0000
@@ -0,0 +1,138 @@
+(THU.CST) os is loading ...
+
+Special kernel symbols:
+  entry  0xc0100036 (phys)
+  etext  0xc010c002 (phys)
+  edata  0xc019f000 (phys)
+  end    0xc01a21b8 (phys)
+Kernel executable memory footprint: 649KB
+ebp:0xc012af38   eip:0xc0100ba9 arg :0x00010094 0x00010094 0xc012af68 0xc01000df
+    kern/debug/kdebug.c:351: print_stackframe+22
+ebp:0xc012af48   eip:0xc0100e9d arg :0x00000000 0x00000000 0x00000000 0xc012afb8
+    kern/debug/kmonitor.c:129: mon_backtrace+10
+ebp:0xc012af68   eip:0xc01000df arg :0x00000000 0xc012af90 0xffff0000 0xc012af94
+    kern/init/init.c:58: grade_backtrace2+33
+ebp:0xc012af88   eip:0xc0100109 arg :0x00000000 0xffff0000 0xc012afb4 0x0000002a
+    kern/init/init.c:63: grade_backtrace1+38
+ebp:0xc012afa8   eip:0xc0100128 arg :0x00000000 0xc0100036 0xffff0000 0x0000001d
+    kern/init/init.c:68: grade_backtrace0+23
+ebp:0xc012afc8   eip:0xc010014e arg :0xc010c03c 0xc010c020 0x000031b8 0x00000000
+    kern/init/init.c:73: grade_backtrace+34
+ebp:0xc012aff8   eip:0xc010008b arg :0xc010c234 0xc010c23c 0xc0100e25 0xc010c25b
+    kern/init/init.c:33: kern_init+84
+memory management: default_pmm_manager
+e820map:
+  memory: 0009fc00, [00000000, 0009fbff], type = 1.
+  memory: 00000400, [0009fc00, 0009ffff], type = 2.
+  memory: 00010000, [000f0000, 000fffff], type = 2.
+  memory: 07ee0000, [00100000, 07fdffff], type = 1.
+  memory: 00020000, [07fe0000, 07ffffff], type = 2.
+  memory: 00040000, [fffc0000, ffffffff], type = 2.
+check_alloc_page() succeeded!
+check_pgdir() succeeded!
+check_boot_pgdir() succeeded!
+-------------------- BEGIN --------------------
+PDE(0e0) c0000000-f8000000 38000000 urw
+  |-- PTE(38000) c0000000-f8000000 38000000 -rw
+PDE(001) fac00000-fb000000 00400000 -rw
+  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw
+  |-- PTE(00001) fafeb000-fafec000 00001000 -rw
+--------------------- END ---------------------
+use SLOB allocator
+kmalloc_init() succeeded!
+check_vma_struct() succeeded!
+page fault at 0x00000100: K/W [no page found].
+check_pgfault() succeeded!
+check_vmm() succeeded.
+ide 0:      10000(sectors), 'QEMU HARDDISK'.
+ide 1:     262144(sectors), 'QEMU HARDDISK'.
+SWAP: manager = fifo swap manager
+BEGIN check_swap: count 1, total 31835
+setup Page Table for vaddr 0X1000, so alloc a page
+setup Page Table vaddr 0~4MB OVER!
+set up init env for check_swap begin!
+page fault at 0x00001000: K/W [no page found].
+page fault at 0x00002000: K/W [no page found].
+page fault at 0x00003000: K/W [no page found].
+page fault at 0x00004000: K/W [no page found].
+set up init env for check_swap over!
+write Virt Page c in fifo_check_swap
+write Virt Page a in fifo_check_swap
+write Virt Page d in fifo_check_swap
+write Virt Page b in fifo_check_swap
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+write Virt Page b in fifo_check_swap
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+write Virt Page b in fifo_check_swap
+page fault at 0x00002000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x3000 to disk swap entry 4
+swap_in: load disk swap entry 3 with swap_page in vadr 0x2000
+write Virt Page c in fifo_check_swap
+page fault at 0x00003000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x4000 to disk swap entry 5
+swap_in: load disk swap entry 4 with swap_page in vadr 0x3000
+write Virt Page d in fifo_check_swap
+page fault at 0x00004000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x5000 to disk swap entry 6
+swap_in: load disk swap entry 5 with swap_page in vadr 0x4000
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+swap_in: load disk swap entry 6 with swap_page in vadr 0x5000
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/R [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+count is 0, total is 5
+check_swap() succeeded!
+++ setup timer interrupts
+kernel_execve: pid = 2, name = "testbss".
+Making sure bss works right...
+Yes, good.  Now doing a wild write off the end...
+testbss may pass.
+not valid addr c03020, and  can not find it in vma
+trapframe at 0xc038bfb4
+  edi  0x00000000
+  esi  0x00000000
+  ebp  0xafffffa8
+  oesp 0xc038bfd4
+  ebx  0x00000000
+  edx  0x0080143a
+  ecx  0xaffffec8
+  eax  0x00000012
+  ds   0x----0023
+  es   0x----0023
+  fs   0x----0000
+  gs   0x----0000
+  trap 0x0000000e Page Fault
+  err  0x00000006
+  eip  0x00801068
+  cs   0x----001b
+  flag 0x00000282 SF,IF,IOPL=0
+  esp  0xafffff80
+  ss   0x----0023
+killed by kernel.
+kernel panic at kern/trap/trap.c:253:
+    handle user mode pgfault failed. ret=-3
+
+stack trackback:
+ebp:0xc038bf08   eip:0xc0100ba9 arg :0xc010c0e8 0xc038bf4c 0x000000fd 0x0080028d
+    kern/debug/kdebug.c:351: print_stackframe+22
+ebp:0xc038bf38   eip:0xc0100468 arg :0xc010c4ce 0x000000fd 0xc010c770 0xfffffffd
+    kern/debug/panic.c:27: __panic+103
+ebp:0xc038bf78   eip:0xc010293f arg :0xc038bfb4 0x00000000 0x0080026d 0x0000001b
+    kern/trap/trap.c:253: trap_dispatch+292
+ebp:0xc038bfa8   eip:0xc0102c12 arg :0xc038bfb4 0x00000000 0x00000000 0xafffffa8
+    kern/trap/trap.c:356: trap+74
+ebp:0xafffffa8   eip:0xc01036da arg :0x00000000 0x00000000 0x00000000 0x00000000
+    kern/trap/trapentry.S:24: <unknown>+0
+ebp:0xafffffd8   eip:0x00800350 arg :0x00000000 0x00000000 0x00000000 0x00000000
+    user/libs/umain.c:7: umain+10
+Welcome to the kernel debug monitor!!
+Type 'help' for a list of commands.
+K> 
\ 文件尾没有换行符
diff -ruP /home/xmh/origin/ucore_os_lab/labcodes/lab5/.waitkill.log lab5/.waitkill.log
--- /home/xmh/origin/ucore_os_lab/labcodes/lab5/.waitkill.log	1970-01-01 00:00:00.000000000 +0000
+++ lab5/.waitkill.log	2020-05-24 07:23:01.714387580 +0000
@@ -0,0 +1,114 @@
+(THU.CST) os is loading ...
+
+Special kernel symbols:
+  entry  0xc0100036 (phys)
+  etext  0xc010c002 (phys)
+  edata  0xc019f000 (phys)
+  end    0xc01a21b8 (phys)
+Kernel executable memory footprint: 649KB
+ebp:0xc012af38   eip:0xc0100ba9 arg :0x00010094 0x00010094 0xc012af68 0xc01000df
+    kern/debug/kdebug.c:351: print_stackframe+22
+ebp:0xc012af48   eip:0xc0100e9d arg :0x00000000 0x00000000 0x00000000 0xc012afb8
+    kern/debug/kmonitor.c:129: mon_backtrace+10
+ebp:0xc012af68   eip:0xc01000df arg :0x00000000 0xc012af90 0xffff0000 0xc012af94
+    kern/init/init.c:58: grade_backtrace2+33
+ebp:0xc012af88   eip:0xc0100109 arg :0x00000000 0xffff0000 0xc012afb4 0x0000002a
+    kern/init/init.c:63: grade_backtrace1+38
+ebp:0xc012afa8   eip:0xc0100128 arg :0x00000000 0xc0100036 0xffff0000 0x0000001d
+    kern/init/init.c:68: grade_backtrace0+23
+ebp:0xc012afc8   eip:0xc010014e arg :0xc010c03c 0xc010c020 0x000031b8 0x00000000
+    kern/init/init.c:73: grade_backtrace+34
+ebp:0xc012aff8   eip:0xc010008b arg :0xc010c234 0xc010c23c 0xc0100e25 0xc010c25b
+    kern/init/init.c:33: kern_init+84
+memory management: default_pmm_manager
+e820map:
+  memory: 0009fc00, [00000000, 0009fbff], type = 1.
+  memory: 00000400, [0009fc00, 0009ffff], type = 2.
+  memory: 00010000, [000f0000, 000fffff], type = 2.
+  memory: 07ee0000, [00100000, 07fdffff], type = 1.
+  memory: 00020000, [07fe0000, 07ffffff], type = 2.
+  memory: 00040000, [fffc0000, ffffffff], type = 2.
+check_alloc_page() succeeded!
+check_pgdir() succeeded!
+check_boot_pgdir() succeeded!
+-------------------- BEGIN --------------------
+PDE(0e0) c0000000-f8000000 38000000 urw
+  |-- PTE(38000) c0000000-f8000000 38000000 -rw
+PDE(001) fac00000-fb000000 00400000 -rw
+  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw
+  |-- PTE(00001) fafeb000-fafec000 00001000 -rw
+--------------------- END ---------------------
+use SLOB allocator
+kmalloc_init() succeeded!
+check_vma_struct() succeeded!
+page fault at 0x00000100: K/W [no page found].
+check_pgfault() succeeded!
+check_vmm() succeeded.
+ide 0:      10000(sectors), 'QEMU HARDDISK'.
+ide 1:     262144(sectors), 'QEMU HARDDISK'.
+SWAP: manager = fifo swap manager
+BEGIN check_swap: count 1, total 31835
+setup Page Table for vaddr 0X1000, so alloc a page
+setup Page Table vaddr 0~4MB OVER!
+set up init env for check_swap begin!
+page fault at 0x00001000: K/W [no page found].
+page fault at 0x00002000: K/W [no page found].
+page fault at 0x00003000: K/W [no page found].
+page fault at 0x00004000: K/W [no page found].
+set up init env for check_swap over!
+write Virt Page c in fifo_check_swap
+write Virt Page a in fifo_check_swap
+write Virt Page d in fifo_check_swap
+write Virt Page b in fifo_check_swap
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+write Virt Page b in fifo_check_swap
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+write Virt Page b in fifo_check_swap
+page fault at 0x00002000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x3000 to disk swap entry 4
+swap_in: load disk swap entry 3 with swap_page in vadr 0x2000
+write Virt Page c in fifo_check_swap
+page fault at 0x00003000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x4000 to disk swap entry 5
+swap_in: load disk swap entry 4 with swap_page in vadr 0x3000
+write Virt Page d in fifo_check_swap
+page fault at 0x00004000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x5000 to disk swap entry 6
+swap_in: load disk swap entry 5 with swap_page in vadr 0x4000
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+swap_in: load disk swap entry 6 with swap_page in vadr 0x5000
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/R [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+count is 0, total is 5
+check_swap() succeeded!
+++ setup timer interrupts
+kernel_execve: pid = 2, name = "waitkill".
+wait child 1.
+child 2.
+child 1.
+kill parent ok.
+kill child1 ok.
+all user-mode processes have quit.
+init check memory pass.
+kernel panic at kern/process/proc.c:525:
+    initproc exit.
+
+stack trackback:
+ebp:0xc0384f88   eip:0xc0100ba9 arg :0xc010c0e8 0xc0384fcc 0x0000020d 0xc0384fb8
+    kern/debug/kdebug.c:351: print_stackframe+22
+ebp:0xc0384fb8   eip:0xc0100468 arg :0xc010e0cc 0x0000020d 0xc010e11e 0x00000000
+    kern/debug/panic.c:27: __panic+103
+ebp:0xc0384fe8   eip:0xc010a151 arg :0x00000000 0x00000000 0x00000000 0x00000010
+    kern/process/proc.c:525: do_exit+91
+Welcome to the kernel debug monitor!!
+Type 'help' for a list of commands.
+K> 
\ 文件尾没有换行符
diff -ruP /home/xmh/origin/ucore_os_lab/labcodes/lab5/.yield.log lab5/.yield.log
--- /home/xmh/origin/ucore_os_lab/labcodes/lab5/.yield.log	1970-01-01 00:00:00.000000000 +0000
+++ lab5/.yield.log	2020-05-24 07:22:39.378027391 +0000
@@ -0,0 +1,117 @@
+(THU.CST) os is loading ...
+
+Special kernel symbols:
+  entry  0xc0100036 (phys)
+  etext  0xc010c002 (phys)
+  edata  0xc019f000 (phys)
+  end    0xc01a21b8 (phys)
+Kernel executable memory footprint: 649KB
+ebp:0xc012af38   eip:0xc0100ba9 arg :0x00010094 0x00010094 0xc012af68 0xc01000df
+    kern/debug/kdebug.c:351: print_stackframe+22
+ebp:0xc012af48   eip:0xc0100e9d arg :0x00000000 0x00000000 0x00000000 0xc012afb8
+    kern/debug/kmonitor.c:129: mon_backtrace+10
+ebp:0xc012af68   eip:0xc01000df arg :0x00000000 0xc012af90 0xffff0000 0xc012af94
+    kern/init/init.c:58: grade_backtrace2+33
+ebp:0xc012af88   eip:0xc0100109 arg :0x00000000 0xffff0000 0xc012afb4 0x0000002a
+    kern/init/init.c:63: grade_backtrace1+38
+ebp:0xc012afa8   eip:0xc0100128 arg :0x00000000 0xc0100036 0xffff0000 0x0000001d
+    kern/init/init.c:68: grade_backtrace0+23
+ebp:0xc012afc8   eip:0xc010014e arg :0xc010c03c 0xc010c020 0x000031b8 0x00000000
+    kern/init/init.c:73: grade_backtrace+34
+ebp:0xc012aff8   eip:0xc010008b arg :0xc010c234 0xc010c23c 0xc0100e25 0xc010c25b
+    kern/init/init.c:33: kern_init+84
+memory management: default_pmm_manager
+e820map:
+  memory: 0009fc00, [00000000, 0009fbff], type = 1.
+  memory: 00000400, [0009fc00, 0009ffff], type = 2.
+  memory: 00010000, [000f0000, 000fffff], type = 2.
+  memory: 07ee0000, [00100000, 07fdffff], type = 1.
+  memory: 00020000, [07fe0000, 07ffffff], type = 2.
+  memory: 00040000, [fffc0000, ffffffff], type = 2.
+check_alloc_page() succeeded!
+check_pgdir() succeeded!
+check_boot_pgdir() succeeded!
+-------------------- BEGIN --------------------
+PDE(0e0) c0000000-f8000000 38000000 urw
+  |-- PTE(38000) c0000000-f8000000 38000000 -rw
+PDE(001) fac00000-fb000000 00400000 -rw
+  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw
+  |-- PTE(00001) fafeb000-fafec000 00001000 -rw
+--------------------- END ---------------------
+use SLOB allocator
+kmalloc_init() succeeded!
+check_vma_struct() succeeded!
+page fault at 0x00000100: K/W [no page found].
+check_pgfault() succeeded!
+check_vmm() succeeded.
+ide 0:      10000(sectors), 'QEMU HARDDISK'.
+ide 1:     262144(sectors), 'QEMU HARDDISK'.
+SWAP: manager = fifo swap manager
+BEGIN check_swap: count 1, total 31835
+setup Page Table for vaddr 0X1000, so alloc a page
+setup Page Table vaddr 0~4MB OVER!
+set up init env for check_swap begin!
+page fault at 0x00001000: K/W [no page found].
+page fault at 0x00002000: K/W [no page found].
+page fault at 0x00003000: K/W [no page found].
+page fault at 0x00004000: K/W [no page found].
+set up init env for check_swap over!
+write Virt Page c in fifo_check_swap
+write Virt Page a in fifo_check_swap
+write Virt Page d in fifo_check_swap
+write Virt Page b in fifo_check_swap
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+write Virt Page b in fifo_check_swap
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+write Virt Page b in fifo_check_swap
+page fault at 0x00002000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x3000 to disk swap entry 4
+swap_in: load disk swap entry 3 with swap_page in vadr 0x2000
+write Virt Page c in fifo_check_swap
+page fault at 0x00003000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x4000 to disk swap entry 5
+swap_in: load disk swap entry 4 with swap_page in vadr 0x3000
+write Virt Page d in fifo_check_swap
+page fault at 0x00004000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x5000 to disk swap entry 6
+swap_in: load disk swap entry 5 with swap_page in vadr 0x4000
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+swap_in: load disk swap entry 6 with swap_page in vadr 0x5000
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/R [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+count is 0, total is 5
+check_swap() succeeded!
+++ setup timer interrupts
+kernel_execve: pid = 2, name = "yield".
+Hello, I am process 2.
+Back in process 2, iteration 0.
+Back in process 2, iteration 1.
+Back in process 2, iteration 2.
+Back in process 2, iteration 3.
+Back in process 2, iteration 4.
+All done in process 2.
+yield pass.
+all user-mode processes have quit.
+init check memory pass.
+kernel panic at kern/process/proc.c:525:
+    initproc exit.
+
+stack trackback:
+ebp:0xc0384f88   eip:0xc0100ba9 arg :0xc010c0e8 0xc0384fcc 0x0000020d 0xc0384fb8
+    kern/debug/kdebug.c:351: print_stackframe+22
+ebp:0xc0384fb8   eip:0xc0100468 arg :0xc010e0cc 0x0000020d 0xc010e11e 0x00000000
+    kern/debug/panic.c:27: __panic+103
+ebp:0xc0384fe8   eip:0xc010a151 arg :0x00000000 0x00000000 0x00000000 0x00000010
+    kern/process/proc.c:525: do_exit+91
+Welcome to the kernel debug monitor!!
+Type 'help' for a list of commands.
+K> 
\ 文件尾没有换行符
