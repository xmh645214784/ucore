diff -ruP /home/xmh/origin/ucore_os_lab/labcodes/lab7/kern/debug/kdebug.c lab7/kern/debug/kdebug.c
--- /home/xmh/origin/ucore_os_lab/labcodes/lab7/kern/debug/kdebug.c	2020-05-24 07:28:36.526368975 +0000
+++ lab7/kern/debug/kdebug.c	2020-05-24 09:18:16.207869398 +0000
@@ -347,5 +347,18 @@
       *           NOTICE: the calling funciton's return addr eip  = ss:[ebp+4]
       *                   the calling funciton's ebp = ss:[ebp]
       */
+    uint32_t ebp = read_ebp();
+    uint32_t eip = read_eip();
+    for (int i = 0; i < STACKFRAME_DEPTH && ebp != 0; i++)
+    {
+        cprintf("ebp:0x%08x   eip:0x%08x ", ebp, eip);
+        uint32_t *tmp = (uint32_t *)ebp + 2;
+        cprintf("arg :0x%08x 0x%08x 0x%08x 0x%08x", *(tmp + 0), *(tmp + 1), *(tmp + 2), *(tmp + 3));
+        cprintf("\n");
+        print_debuginfo(eip - 1);
+        eip = ((uint32_t *)ebp)[1];
+        ebp = ((uint32_t *)ebp)[0];
+    }
 }
 
+
diff -ruP /home/xmh/origin/ucore_os_lab/labcodes/lab7/kern/mm/default_pmm.c lab7/kern/mm/default_pmm.c
--- /home/xmh/origin/ucore_os_lab/labcodes/lab7/kern/mm/default_pmm.c	2020-05-24 07:28:36.526368975 +0000
+++ lab7/kern/mm/default_pmm.c	2020-05-24 09:18:16.207869398 +0000
@@ -99,16 +99,19 @@
 #define nr_free (free_area.nr_free)
 
 static void
-default_init(void) {
+default_init(void)
+{
     list_init(&free_list);
     nr_free = 0;
 }
 
 static void
-default_init_memmap(struct Page *base, size_t n) {
+default_init_memmap(struct Page *base, size_t n)
+{
     assert(n > 0);
     struct Page *p = base;
-    for (; p != base + n; p ++) {
+    for (; p != base + n; p++)
+    {
         assert(PageReserved(p));
         p->flags = p->property = 0;
         set_page_ref(p, 0);
@@ -120,27 +123,34 @@
 }
 
 static struct Page *
-default_alloc_pages(size_t n) {
+default_alloc_pages(size_t n)
+{
     assert(n > 0);
-    if (n > nr_free) {
+    if (n > nr_free)
+    {
         return NULL;
     }
     struct Page *page = NULL;
     list_entry_t *le = &free_list;
-    while ((le = list_next(le)) != &free_list) {
+    while ((le = list_next(le)) != &free_list)
+    {
         struct Page *p = le2page(le, page_link);
-        if (p->property >= n) {
+        if (p->property >= n)
+        {
             page = p;
             break;
         }
     }
-    if (page != NULL) {
-        list_del(&(page->page_link));
-        if (page->property > n) {
+    if (page != NULL)
+    {
+        if (page->property > n)
+        {
             struct Page *p = page + n;
             p->property = page->property - n;
-            list_add(&free_list, &(p->page_link));
-    }
+            SetPageProperty(p);
+            list_add_after(&(page->page_link), &(p->page_link));
+        }
+        list_del(&(page->page_link));
         nr_free -= n;
         ClearPageProperty(page);
     }
@@ -148,10 +158,12 @@
 }
 
 static void
-default_free_pages(struct Page *base, size_t n) {
+default_free_pages(struct Page *base, size_t n)
+{
     assert(n > 0);
     struct Page *p = base;
-    for (; p != base + n; p ++) {
+    for (; p != base + n; p++)
+    {
         assert(!PageReserved(p) && !PageProperty(p));
         p->flags = 0;
         set_page_ref(p, 0);
@@ -159,15 +171,18 @@
     base->property = n;
     SetPageProperty(base);
     list_entry_t *le = list_next(&free_list);
-    while (le != &free_list) {
+    while (le != &free_list)
+    {
         p = le2page(le, page_link);
         le = list_next(le);
-        if (base + base->property == p) {
+        if (base + base->property == p)
+        {
             base->property += p->property;
             ClearPageProperty(p);
             list_del(&(p->page_link));
         }
-        else if (p + p->property == base) {
+        else if (p + p->property == base)
+        {
             p->property += base->property;
             ClearPageProperty(base);
             base = p;
@@ -175,16 +190,24 @@
         }
     }
     nr_free += n;
-    list_add(&free_list, &(base->page_link));
+    for (le = list_next(&free_list); le != &free_list; le = list_next(le))
+    {
+        p = le2page(le, page_link);
+        if (base + base->property <= p)
+            break;
+    }
+    list_add_before(le, &(base->page_link));
 }
 
 static size_t
-default_nr_free_pages(void) {
+default_nr_free_pages(void)
+{
     return nr_free;
 }
 
 static void
-basic_check(void) {
+basic_check(void)
+{
     struct Page *p0, *p1, *p2;
     p0 = p1 = p2 = NULL;
     assert((p0 = alloc_page()) != NULL);
@@ -234,16 +257,18 @@
     free_page(p2);
 }
 
-// LAB2: below code is used to check the first fit allocation algorithm (your EXERCISE 1) 
+// LAB2: below code is used to check the first fit allocation algorithm (your EXERCISE 1)
 // NOTICE: You SHOULD NOT CHANGE basic_check, default_check functions!
 static void
-default_check(void) {
+default_check(void)
+{
     int count = 0, total = 0;
     list_entry_t *le = &free_list;
-    while ((le = list_next(le)) != &free_list) {
+    while ((le = list_next(le)) != &free_list)
+    {
         struct Page *p = le2page(le, page_link);
         assert(PageProperty(p));
-        count ++, total += p->property;
+        count++, total += p->property;
     }
     assert(total == nr_free_pages());
 
@@ -291,9 +316,10 @@
     free_pages(p0, 5);
 
     le = &free_list;
-    while ((le = list_next(le)) != &free_list) {
+    while ((le = list_next(le)) != &free_list)
+    {
         struct Page *p = le2page(le, page_link);
-        count --, total -= p->property;
+        count--, total -= p->property;
     }
     assert(count == 0);
     assert(total == 0);
@@ -308,4 +334,3 @@
     .nr_free_pages = default_nr_free_pages,
     .check = default_check,
 };
-
diff -ruP /home/xmh/origin/ucore_os_lab/labcodes/lab7/kern/mm/pmm.c lab7/kern/mm/pmm.c
--- /home/xmh/origin/ucore_os_lab/labcodes/lab7/kern/mm/pmm.c	2020-05-24 07:28:36.526368975 +0000
+++ lab7/kern/mm/pmm.c	2020-05-24 09:18:16.207869398 +0000
@@ -61,8 +61,8 @@
  * always available at virtual address PGADDR(PDX(VPT), PDX(VPT), 0), to which
  * vpd is set bellow.
  * */
-pte_t * const vpt = (pte_t *)VPT;
-pde_t * const vpd = (pde_t *)PGADDR(PDX(VPT), PDX(VPT), 0);
+pte_t *const vpt = (pte_t *)VPT;
+pde_t *const vpd = (pde_t *)PGADDR(PDX(VPT), PDX(VPT), 0);
 
 /* *
  * Global Descriptor Table:
@@ -83,12 +83,11 @@
     [SEG_KDATA] = SEG(STA_W, 0x0, 0xFFFFFFFF, DPL_KERNEL),
     [SEG_UTEXT] = SEG(STA_X | STA_R, 0x0, 0xFFFFFFFF, DPL_USER),
     [SEG_UDATA] = SEG(STA_W, 0x0, 0xFFFFFFFF, DPL_USER),
-    [SEG_TSS]   = SEG_NULL,
+    [SEG_TSS] = SEG_NULL,
 };
 
 static struct pseudodesc gdt_pd = {
-    sizeof(gdt) - 1, (uintptr_t)gdt
-};
+    sizeof(gdt) - 1, (uintptr_t)gdt};
 
 static void check_alloc_page(void);
 static void check_pgdir(void);
@@ -99,15 +98,16 @@
  * data/code segement registers for kernel.
  * */
 static inline void
-lgdt(struct pseudodesc *pd) {
-    asm volatile ("lgdt (%0)" :: "r" (pd));
-    asm volatile ("movw %%ax, %%gs" :: "a" (USER_DS));
-    asm volatile ("movw %%ax, %%fs" :: "a" (USER_DS));
-    asm volatile ("movw %%ax, %%es" :: "a" (KERNEL_DS));
-    asm volatile ("movw %%ax, %%ds" :: "a" (KERNEL_DS));
-    asm volatile ("movw %%ax, %%ss" :: "a" (KERNEL_DS));
+lgdt(struct pseudodesc *pd)
+{
+    asm volatile("lgdt (%0)" ::"r"(pd));
+    asm volatile("movw %%ax, %%gs" ::"a"(USER_DS));
+    asm volatile("movw %%ax, %%fs" ::"a"(USER_DS));
+    asm volatile("movw %%ax, %%es" ::"a"(KERNEL_DS));
+    asm volatile("movw %%ax, %%ds" ::"a"(KERNEL_DS));
+    asm volatile("movw %%ax, %%ss" ::"a"(KERNEL_DS));
     // reload cs
-    asm volatile ("ljmp %0, $1f\n 1:\n" :: "i" (KERNEL_CS));
+    asm volatile("ljmp %0, $1f\n 1:\n" ::"i"(KERNEL_CS));
 }
 
 /* *
@@ -115,14 +115,15 @@
  * so that we can use different kernel stack when we trap frame
  * user to kernel.
  * */
-void
-load_esp0(uintptr_t esp0) {
+void load_esp0(uintptr_t esp0)
+{
     ts.ts_esp0 = esp0;
 }
 
 /* gdt_init - initialize the default GDT and TSS */
 static void
-gdt_init(void) {
+gdt_init(void)
+{
     // set boot kernel stack and default SS0
     load_esp0((uintptr_t)bootstacktop);
     ts.ts_ss0 = KERNEL_DS;
@@ -139,45 +140,49 @@
 
 //init_pmm_manager - initialize a pmm_manager instance
 static void
-init_pmm_manager(void) {
+init_pmm_manager(void)
+{
     pmm_manager = &default_pmm_manager;
     cprintf("memory management: %s\n", pmm_manager->name);
     pmm_manager->init();
 }
 
-//init_memmap - call pmm->init_memmap to build Page struct for free memory  
+//init_memmap - call pmm->init_memmap to build Page struct for free memory
 static void
-init_memmap(struct Page *base, size_t n) {
+init_memmap(struct Page *base, size_t n)
+{
     pmm_manager->init_memmap(base, n);
 }
 
-//alloc_pages - call pmm->alloc_pages to allocate a continuous n*PAGESIZE memory 
+//alloc_pages - call pmm->alloc_pages to allocate a continuous n*PAGESIZE memory
 struct Page *
-alloc_pages(size_t n) {
-    struct Page *page=NULL;
+alloc_pages(size_t n)
+{
+    struct Page *page = NULL;
     bool intr_flag;
-    
+
     while (1)
     {
-         local_intr_save(intr_flag);
-         {
-              page = pmm_manager->alloc_pages(n);
-         }
-         local_intr_restore(intr_flag);
-
-         if (page != NULL || n > 1 || swap_init_ok == 0) break;
-         
-         extern struct mm_struct *check_mm_struct;
-         //cprintf("page %x, call swap_out in alloc_pages %d\n",page, n);
-         swap_out(check_mm_struct, n, 0);
+        local_intr_save(intr_flag);
+        {
+            page = pmm_manager->alloc_pages(n);
+        }
+        local_intr_restore(intr_flag);
+
+        if (page != NULL || n > 1 || swap_init_ok == 0)
+            break;
+
+        extern struct mm_struct *check_mm_struct;
+        //cprintf("page %x, call swap_out in alloc_pages %d\n",page, n);
+        swap_out(check_mm_struct, n, 0);
     }
     //cprintf("n %d,get page %x, No %d in alloc_pages\n",n,page,(page-pages));
     return page;
 }
 
-//free_pages - call pmm->free_pages to free a continuous n*PAGESIZE memory 
-void
-free_pages(struct Page *base, size_t n) {
+//free_pages - call pmm->free_pages to free a continuous n*PAGESIZE memory
+void free_pages(struct Page *base, size_t n)
+{
     bool intr_flag;
     local_intr_save(intr_flag);
     {
@@ -186,10 +191,11 @@
     local_intr_restore(intr_flag);
 }
 
-//nr_free_pages - call pmm->nr_free_pages to get the size (nr*PAGESIZE) 
+//nr_free_pages - call pmm->nr_free_pages to get the size (nr*PAGESIZE)
 //of current free memory
 size_t
-nr_free_pages(void) {
+nr_free_pages(void)
+{
     size_t ret;
     bool intr_flag;
     local_intr_save(intr_flag);
@@ -202,23 +208,28 @@
 
 /* pmm_init - initialize the physical memory management */
 static void
-page_init(void) {
+page_init(void)
+{
     struct e820map *memmap = (struct e820map *)(0x8000 + KERNBASE);
     uint64_t maxpa = 0;
 
     cprintf("e820map:\n");
     int i;
-    for (i = 0; i < memmap->nr_map; i ++) {
+    for (i = 0; i < memmap->nr_map; i++)
+    {
         uint64_t begin = memmap->map[i].addr, end = begin + memmap->map[i].size;
         cprintf("  memory: %08llx, [%08llx, %08llx], type = %d.\n",
                 memmap->map[i].size, begin, end - 1, memmap->map[i].type);
-        if (memmap->map[i].type == E820_ARM) {
-            if (maxpa < end && begin < KMEMSIZE) {
+        if (memmap->map[i].type == E820_ARM)
+        {
+            if (maxpa < end && begin < KMEMSIZE)
+            {
                 maxpa = end;
             }
         }
     }
-    if (maxpa > KMEMSIZE) {
+    if (maxpa > KMEMSIZE)
+    {
         maxpa = KMEMSIZE;
     }
 
@@ -227,25 +238,32 @@
     npage = maxpa / PGSIZE;
     pages = (struct Page *)ROUNDUP((void *)end, PGSIZE);
 
-    for (i = 0; i < npage; i ++) {
+    for (i = 0; i < npage; i++)
+    {
         SetPageReserved(pages + i);
     }
 
     uintptr_t freemem = PADDR((uintptr_t)pages + sizeof(struct Page) * npage);
 
-    for (i = 0; i < memmap->nr_map; i ++) {
+    for (i = 0; i < memmap->nr_map; i++)
+    {
         uint64_t begin = memmap->map[i].addr, end = begin + memmap->map[i].size;
-        if (memmap->map[i].type == E820_ARM) {
-            if (begin < freemem) {
+        if (memmap->map[i].type == E820_ARM)
+        {
+            if (begin < freemem)
+            {
                 begin = freemem;
             }
-            if (end > KMEMSIZE) {
+            if (end > KMEMSIZE)
+            {
                 end = KMEMSIZE;
             }
-            if (begin < end) {
+            if (begin < end)
+            {
                 begin = ROUNDUP(begin, PGSIZE);
                 end = ROUNDDOWN(end, PGSIZE);
-                if (begin < end) {
+                if (begin < end)
+                {
                     init_memmap(pa2page(begin), (end - begin) / PGSIZE);
                 }
             }
@@ -258,43 +276,47 @@
 //  la:   linear address of this memory need to map (after x86 segment map)
 //  size: memory size
 //  pa:   physical address of this memory
-//  perm: permission of this memory  
+//  perm: permission of this memory
 static void
-boot_map_segment(pde_t *pgdir, uintptr_t la, size_t size, uintptr_t pa, uint32_t perm) {
+boot_map_segment(pde_t *pgdir, uintptr_t la, size_t size, uintptr_t pa, uint32_t perm)
+{
     assert(PGOFF(la) == PGOFF(pa));
     size_t n = ROUNDUP(size + PGOFF(la), PGSIZE) / PGSIZE;
     la = ROUNDDOWN(la, PGSIZE);
     pa = ROUNDDOWN(pa, PGSIZE);
-    for (; n > 0; n --, la += PGSIZE, pa += PGSIZE) {
+    for (; n > 0; n--, la += PGSIZE, pa += PGSIZE)
+    {
         pte_t *ptep = get_pte(pgdir, la, 1);
         assert(ptep != NULL);
         *ptep = pa | PTE_P | perm;
     }
 }
 
-//boot_alloc_page - allocate one page using pmm->alloc_pages(1) 
+//boot_alloc_page - allocate one page using pmm->alloc_pages(1)
 // return value: the kernel virtual address of this allocated page
 //note: this function is used to get the memory for PDT(Page Directory Table)&PT(Page Table)
 static void *
-boot_alloc_page(void) {
+boot_alloc_page(void)
+{
     struct Page *p = alloc_page();
-    if (p == NULL) {
+    if (p == NULL)
+    {
         panic("boot_alloc_page failed.\n");
     }
     return page2kva(p);
 }
 
-//pmm_init - setup a pmm to manage physical memory, build PDT&PT to setup paging mechanism 
+//pmm_init - setup a pmm to manage physical memory, build PDT&PT to setup paging mechanism
 //         - check the correctness of pmm & paging mechanism, print PDT&PT
-void
-pmm_init(void) {
+void pmm_init(void)
+{
     // We've already enabled paging
     boot_cr3 = PADDR(boot_pgdir);
 
-    //We need to alloc/free the physical memory (granularity is 4KB or other size). 
+    //We need to alloc/free the physical memory (granularity is 4KB or other size).
     //So a framework of physical memory manager (struct pmm_manager)is defined in pmm.h
     //First we should init a physical memory manager(pmm) based on the framework.
-    //Then pmm can alloc/free the physical memory. 
+    //Then pmm can alloc/free the physical memory.
     //Now the first_fit/best_fit/worst_fit/buddy_system pmm are available.
     init_pmm_manager();
 
@@ -328,9 +350,8 @@
     check_boot_pgdir();
 
     print_pgdir();
-    
-    kmalloc_init();
 
+    kmalloc_init();
 }
 
 //get_pte - get pte and return the kernel virtual address of this pte for la
@@ -341,7 +362,8 @@
 //  create: a logical value to decide if alloc a page for PT
 // return vaule: the kernel virtual address of this pte
 pte_t *
-get_pte(pde_t *pgdir, uintptr_t la, bool create) {
+get_pte(pde_t *pgdir, uintptr_t la, bool create)
+{
     /* LAB2 EXERCISE 2: YOUR CODE
      *
      * If you need to visit a physical address, please use KADDR()
@@ -375,16 +397,33 @@
     }
     return NULL;          // (8) return page table entry
 #endif
+    pde_t *pdep = &pgdir[PDX(la)];
+    if (!(*pdep & PTE_P))
+    {
+        struct Page *page;
+        if (!create || (page = alloc_page()) == NULL)
+        {
+            return NULL;
+        }
+        set_page_ref(page, 1);
+        uintptr_t pa = page2pa(page);
+        memset(KADDR(pa), 0, PGSIZE);
+        *pdep = pa | PTE_U | PTE_W | PTE_P;
+    }
+    return &((pte_t *)KADDR(PDE_ADDR(*pdep)))[PTX(la)];
 }
 
 //get_page - get related Page struct for linear address la using PDT pgdir
 struct Page *
-get_page(pde_t *pgdir, uintptr_t la, pte_t **ptep_store) {
+get_page(pde_t *pgdir, uintptr_t la, pte_t **ptep_store)
+{
     pte_t *ptep = get_pte(pgdir, la, 0);
-    if (ptep_store != NULL) {
+    if (ptep_store != NULL)
+    {
         *ptep_store = ptep;
     }
-    if (ptep != NULL && *ptep & PTE_P) {
+    if (ptep != NULL && *ptep & PTE_P)
+    {
         return pte2page(*ptep);
     }
     return NULL;
@@ -392,9 +431,10 @@
 
 //page_remove_pte - free an Page sturct which is related linear address la
 //                - and clean(invalidate) pte which is related linear address la
-//note: PT is changed, so the TLB need to be invalidate 
+//note: PT is changed, so the TLB need to be invalidate
 static inline void
-page_remove_pte(pde_t *pgdir, uintptr_t la, pte_t *ptep) {
+page_remove_pte(pde_t *pgdir, uintptr_t la, pte_t *ptep)
+{
     /* LAB2 EXERCISE 3: YOUR CODE
      *
      * Please check if ptep is valid, and tlb must be manually updated if mapping is updated
@@ -420,35 +460,50 @@
                                   //(6) flush tlb
     }
 #endif
+    if (*ptep & PTE_P)
+    {
+        struct Page *page = pte2page(*ptep);
+        if (page_ref_dec(page) == 0)
+        {
+            free_page(page);
+        }
+        *ptep = 0;
+        tlb_invalidate(pgdir, la);
+    }
 }
 
-void
-unmap_range(pde_t *pgdir, uintptr_t start, uintptr_t end) {
+void unmap_range(pde_t *pgdir, uintptr_t start, uintptr_t end)
+{
     assert(start % PGSIZE == 0 && end % PGSIZE == 0);
     assert(USER_ACCESS(start, end));
 
-    do {
+    do
+    {
         pte_t *ptep = get_pte(pgdir, start, 0);
-        if (ptep == NULL) {
+        if (ptep == NULL)
+        {
             start = ROUNDDOWN(start + PTSIZE, PTSIZE);
-            continue ;
+            continue;
         }
-        if (*ptep != 0) {
+        if (*ptep != 0)
+        {
             page_remove_pte(pgdir, start, ptep);
         }
         start += PGSIZE;
     } while (start != 0 && start < end);
 }
 
-void
-exit_range(pde_t *pgdir, uintptr_t start, uintptr_t end) {
+void exit_range(pde_t *pgdir, uintptr_t start, uintptr_t end)
+{
     assert(start % PGSIZE == 0 && end % PGSIZE == 0);
     assert(USER_ACCESS(start, end));
 
     start = ROUNDDOWN(start, PTSIZE);
-    do {
+    do
+    {
         int pde_idx = PDX(start);
-        if (pgdir[pde_idx] & PTE_P) {
+        if (pgdir[pde_idx] & PTE_P)
+        {
             free_page(pde2page(pgdir[pde_idx]));
             pgdir[pde_idx] = 0;
         }
@@ -462,32 +517,36 @@
  *
  * CALL GRAPH: copy_mm-->dup_mmap-->copy_range
  */
-int
-copy_range(pde_t *to, pde_t *from, uintptr_t start, uintptr_t end, bool share) {
+int copy_range(pde_t *to, pde_t *from, uintptr_t start, uintptr_t end, bool share)
+{
     assert(start % PGSIZE == 0 && end % PGSIZE == 0);
     assert(USER_ACCESS(start, end));
     // copy content by page unit.
-    do {
+    do
+    {
         //call get_pte to find process A's pte according to the addr start
         pte_t *ptep = get_pte(from, start, 0), *nptep;
-        if (ptep == NULL) {
+        if (ptep == NULL)
+        {
             start = ROUNDDOWN(start + PTSIZE, PTSIZE);
-            continue ;
+            continue;
         }
         //call get_pte to find process B's pte according to the addr start. If pte is NULL, just alloc a PT
-        if (*ptep & PTE_P) {
-            if ((nptep = get_pte(to, start, 1)) == NULL) {
+        if (*ptep & PTE_P)
+        {
+            if ((nptep = get_pte(to, start, 1)) == NULL)
+            {
                 return -E_NO_MEM;
             }
-        uint32_t perm = (*ptep & PTE_USER);
-        //get page from ptep
-        struct Page *page = pte2page(*ptep);
-        // alloc a page for process B
-        struct Page *npage=alloc_page();
-        assert(page!=NULL);
-        assert(npage!=NULL);
-        int ret=0;
-        /* LAB5:EXERCISE2 YOUR CODE
+            uint32_t perm = (*ptep & PTE_USER);
+            //get page from ptep
+            struct Page *page = pte2page(*ptep);
+            // alloc a page for process B
+            struct Page *npage = alloc_page();
+            assert(page != NULL);
+            assert(npage != NULL);
+            int ret = 0;
+            /* LAB5:EXERCISE2 YOUR CODE
          * replicate content of page to npage, build the map of phy addr of nage with the linear addr start
          *
          * Some Useful MACROs and DEFINEs, you can use them in below implementation.
@@ -501,7 +560,9 @@
          * (3) memory copy from src_kvaddr to dst_kvaddr, size is PGSIZE
          * (4) build the map of phy addr of  nage with the linear addr start
          */
-        assert(ret == 0);
+            memcpy(page2kva(npage), page2kva(page), PGSIZE);
+            ret = page_insert(to, npage, start, perm);
+            assert(ret == 0);
         }
         start += PGSIZE;
     } while (start != 0 && start < end);
@@ -509,10 +570,11 @@
 }
 
 //page_remove - free an Page which is related linear address la and has an validated pte
-void
-page_remove(pde_t *pgdir, uintptr_t la) {
+void page_remove(pde_t *pgdir, uintptr_t la)
+{
     pte_t *ptep = get_pte(pgdir, la, 0);
-    if (ptep != NULL) {
+    if (ptep != NULL)
+    {
         page_remove_pte(pgdir, la, ptep);
     }
 }
@@ -524,20 +586,24 @@
 //  la:    the linear address need to map
 //  perm:  the permission of this Page which is setted in related pte
 // return value: always 0
-//note: PT is changed, so the TLB need to be invalidate 
-int
-page_insert(pde_t *pgdir, struct Page *page, uintptr_t la, uint32_t perm) {
+//note: PT is changed, so the TLB need to be invalidate
+int page_insert(pde_t *pgdir, struct Page *page, uintptr_t la, uint32_t perm)
+{
     pte_t *ptep = get_pte(pgdir, la, 1);
-    if (ptep == NULL) {
+    if (ptep == NULL)
+    {
         return -E_NO_MEM;
     }
     page_ref_inc(page);
-    if (*ptep & PTE_P) {
+    if (*ptep & PTE_P)
+    {
         struct Page *p = pte2page(*ptep);
-        if (p == page) {
+        if (p == page)
+        {
             page_ref_dec(page);
         }
-        else {
+        else
+        {
             page_remove_pte(pgdir, la, ptep);
         }
     }
@@ -548,52 +614,60 @@
 
 // invalidate a TLB entry, but only if the page tables being
 // edited are the ones currently in use by the processor.
-void
-tlb_invalidate(pde_t *pgdir, uintptr_t la) {
-    if (rcr3() == PADDR(pgdir)) {
+void tlb_invalidate(pde_t *pgdir, uintptr_t la)
+{
+    if (rcr3() == PADDR(pgdir))
+    {
         invlpg((void *)la);
     }
 }
 
-// pgdir_alloc_page - call alloc_page & page_insert functions to 
+// pgdir_alloc_page - call alloc_page & page_insert functions to
 //                  - allocate a page size memory & setup an addr map
 //                  - pa<->la with linear address la and the PDT pgdir
 struct Page *
-pgdir_alloc_page(pde_t *pgdir, uintptr_t la, uint32_t perm) {
+pgdir_alloc_page(pde_t *pgdir, uintptr_t la, uint32_t perm)
+{
     struct Page *page = alloc_page();
-    if (page != NULL) {
-        if (page_insert(pgdir, page, la, perm) != 0) {
+    if (page != NULL)
+    {
+        if (page_insert(pgdir, page, la, perm) != 0)
+        {
             free_page(page);
             return NULL;
         }
-        if (swap_init_ok){
-            if(check_mm_struct!=NULL) {
+        if (swap_init_ok)
+        {
+            if (check_mm_struct != NULL)
+            {
                 swap_map_swappable(check_mm_struct, la, page, 0);
-                page->pra_vaddr=la;
+                page->pra_vaddr = la;
                 assert(page_ref(page) == 1);
                 //cprintf("get No. %d  page: pra_vaddr %x, pra_link.prev %x, pra_link_next %x in pgdir_alloc_page\n", (page-pages), page->pra_vaddr,page->pra_page_link.prev, page->pra_page_link.next);
-            } 
-            else  {  //now current is existed, should fix it in the future
+            }
+            else
+            { //now current is existed, should fix it in the future
                 //swap_map_swappable(current->mm, la, page, 0);
                 //page->pra_vaddr=la;
                 //assert(page_ref(page) == 1);
                 //panic("pgdir_alloc_page: no pages. now current is existed, should fix it in the future\n");
             }
         }
-
     }
 
     return page;
 }
 
 static void
-check_alloc_page(void) {
+check_alloc_page(void)
+{
     pmm_manager->check();
     cprintf("check_alloc_page() succeeded!\n");
 }
 
 static void
-check_pgdir(void) {
+check_pgdir(void)
+{
     assert(npage <= KMEMSIZE / PGSIZE);
     assert(boot_pgdir != NULL && (uint32_t)PGOFF(boot_pgdir) == 0);
     assert(get_page(boot_pgdir, 0x0, NULL) == NULL);
@@ -641,10 +715,12 @@
 }
 
 static void
-check_boot_pgdir(void) {
+check_boot_pgdir(void)
+{
     pte_t *ptep;
     int i;
-    for (i = 0; i < npage; i += PGSIZE) {
+    for (i = 0; i < npage; i += PGSIZE)
+    {
         assert((ptep = get_pte(boot_pgdir, (uintptr_t)KADDR(i), 0)) != NULL);
         assert(PTE_ADDR(*ptep) == i);
     }
@@ -676,7 +752,8 @@
 
 //perm2str - use string 'u,r,w,-' to present the permission
 static const char *
-perm2str(int perm) {
+perm2str(int perm)
+{
     static char str[4];
     str[0] = (perm & PTE_U) ? 'u' : '-';
     str[1] = 'r';
@@ -695,24 +772,31 @@
 //  table:       the beginning addr of table
 //  left_store:  the pointer of the high side of table's next range
 //  right_store: the pointer of the low side of table's next range
-// return value: 0 - not a invalid item range, perm - a valid item range with perm permission 
+// return value: 0 - not a invalid item range, perm - a valid item range with perm permission
 static int
-get_pgtable_items(size_t left, size_t right, size_t start, uintptr_t *table, size_t *left_store, size_t *right_store) {
-    if (start >= right) {
+get_pgtable_items(size_t left, size_t right, size_t start, uintptr_t *table, size_t *left_store, size_t *right_store)
+{
+    if (start >= right)
+    {
         return 0;
     }
-    while (start < right && !(table[start] & PTE_P)) {
-        start ++;
+    while (start < right && !(table[start] & PTE_P))
+    {
+        start++;
     }
-    if (start < right) {
-        if (left_store != NULL) {
+    if (start < right)
+    {
+        if (left_store != NULL)
+        {
             *left_store = start;
         }
-        int perm = (table[start ++] & PTE_USER);
-        while (start < right && (table[start] & PTE_USER) == perm) {
-            start ++;
+        int perm = (table[start++] & PTE_USER);
+        while (start < right && (table[start] & PTE_USER) == perm)
+        {
+            start++;
         }
-        if (right_store != NULL) {
+        if (right_store != NULL)
+        {
             *right_store = start;
         }
         return perm;
@@ -721,15 +805,17 @@
 }
 
 //print_pgdir - print the PDT&PT
-void
-print_pgdir(void) {
+void print_pgdir(void)
+{
     cprintf("-------------------- BEGIN --------------------\n");
     size_t left, right = 0, perm;
-    while ((perm = get_pgtable_items(0, NPDEENTRY, right, vpd, &left, &right)) != 0) {
+    while ((perm = get_pgtable_items(0, NPDEENTRY, right, vpd, &left, &right)) != 0)
+    {
         cprintf("PDE(%03x) %08x-%08x %08x %s\n", right - left,
                 left * PTSIZE, right * PTSIZE, (right - left) * PTSIZE, perm2str(perm));
         size_t l, r = left * NPTEENTRY;
-        while ((perm = get_pgtable_items(left * NPTEENTRY, right * NPTEENTRY, r, vpt, &l, &r)) != 0) {
+        while ((perm = get_pgtable_items(left * NPTEENTRY, right * NPTEENTRY, r, vpt, &l, &r)) != 0)
+        {
             cprintf("  |-- PTE(%05x) %08x-%08x %08x %s\n", r - l,
                     l * PGSIZE, r * PGSIZE, (r - l) * PGSIZE, perm2str(perm));
         }
diff -ruP /home/xmh/origin/ucore_os_lab/labcodes/lab7/kern/mm/swap_fifo.c lab7/kern/mm/swap_fifo.c
--- /home/xmh/origin/ucore_os_lab/labcodes/lab7/kern/mm/swap_fifo.c	2020-05-24 07:28:36.526368975 +0000
+++ lab7/kern/mm/swap_fifo.c	2020-05-24 09:18:16.207869398 +0000
@@ -32,11 +32,11 @@
  */
 static int
 _fifo_init_mm(struct mm_struct *mm)
-{     
-     list_init(&pra_list_head);
-     mm->sm_priv = &pra_list_head;
-     //cprintf(" mm->sm_priv %x in fifo_init_mm\n",mm->sm_priv);
-     return 0;
+{
+    list_init(&pra_list_head);
+    mm->sm_priv = &pra_list_head;
+    //cprintf(" mm->sm_priv %x in fifo_init_mm\n",mm->sm_priv);
+    return 0;
 }
 /*
  * (3)_fifo_map_swappable: According FIFO PRA, we should link the most recent arrival page at the back of pra_list_head qeueue
@@ -44,13 +44,14 @@
 static int
 _fifo_map_swappable(struct mm_struct *mm, uintptr_t addr, struct Page *page, int swap_in)
 {
-    list_entry_t *head=(list_entry_t*) mm->sm_priv;
-    list_entry_t *entry=&(page->pra_page_link);
- 
+    list_entry_t *head = (list_entry_t *)mm->sm_priv;
+    list_entry_t *entry = &(page->pra_page_link);
+
     assert(entry != NULL && head != NULL);
     //record the page access situlation
-    /*LAB3 EXERCISE 2: YOUR CODE*/ 
+    /*LAB3 EXERCISE 2: YOUR CODE*/
     //(1)link the most recent arrival page at the back of the pra_list_head qeueue.
+    list_add(head, entry);
     return 0;
 }
 /*
@@ -58,61 +59,65 @@
  *                            then assign the value of *ptr_page to the addr of this page.
  */
 static int
-_fifo_swap_out_victim(struct mm_struct *mm, struct Page ** ptr_page, int in_tick)
+_fifo_swap_out_victim(struct mm_struct *mm, struct Page **ptr_page, int in_tick)
 {
-     list_entry_t *head=(list_entry_t*) mm->sm_priv;
-         assert(head != NULL);
-     assert(in_tick==0);
-     /* Select the victim */
-     /*LAB3 EXERCISE 2: YOUR CODE*/ 
-     //(1)  unlink the  earliest arrival page in front of pra_list_head qeueue
-     //(2)  assign the value of *ptr_page to the addr of this page
-     return 0;
+    list_entry_t *head = (list_entry_t *)mm->sm_priv;
+    assert(head != NULL);
+    assert(in_tick == 0);
+    /* Select the victim */
+    /*LAB3 EXERCISE 2: YOUR CODE*/
+    //(1)  unlink the  earliest arrival page in front of pra_list_head qeueue
+    //(2)  assign the value of *ptr_page to the addr of this page
+    list_entry_t *le = head->prev;
+    struct Page *p = le2page(le, pra_page_link);
+    list_del(le);
+    *ptr_page = p;
+    return 0;
 }
 
 static int
-_fifo_check_swap(void) {
+_fifo_check_swap(void)
+{
     cprintf("write Virt Page c in fifo_check_swap\n");
     *(unsigned char *)0x3000 = 0x0c;
-    assert(pgfault_num==4);
+    assert(pgfault_num == 4);
     cprintf("write Virt Page a in fifo_check_swap\n");
     *(unsigned char *)0x1000 = 0x0a;
-    assert(pgfault_num==4);
+    assert(pgfault_num == 4);
     cprintf("write Virt Page d in fifo_check_swap\n");
     *(unsigned char *)0x4000 = 0x0d;
-    assert(pgfault_num==4);
+    assert(pgfault_num == 4);
     cprintf("write Virt Page b in fifo_check_swap\n");
     *(unsigned char *)0x2000 = 0x0b;
-    assert(pgfault_num==4);
+    assert(pgfault_num == 4);
     cprintf("write Virt Page e in fifo_check_swap\n");
     *(unsigned char *)0x5000 = 0x0e;
-    assert(pgfault_num==5);
+    assert(pgfault_num == 5);
     cprintf("write Virt Page b in fifo_check_swap\n");
     *(unsigned char *)0x2000 = 0x0b;
-    assert(pgfault_num==5);
+    assert(pgfault_num == 5);
     cprintf("write Virt Page a in fifo_check_swap\n");
     *(unsigned char *)0x1000 = 0x0a;
-    assert(pgfault_num==6);
+    assert(pgfault_num == 6);
     cprintf("write Virt Page b in fifo_check_swap\n");
     *(unsigned char *)0x2000 = 0x0b;
-    assert(pgfault_num==7);
+    assert(pgfault_num == 7);
     cprintf("write Virt Page c in fifo_check_swap\n");
     *(unsigned char *)0x3000 = 0x0c;
-    assert(pgfault_num==8);
+    assert(pgfault_num == 8);
     cprintf("write Virt Page d in fifo_check_swap\n");
     *(unsigned char *)0x4000 = 0x0d;
-    assert(pgfault_num==9);
+    assert(pgfault_num == 9);
     cprintf("write Virt Page e in fifo_check_swap\n");
     *(unsigned char *)0x5000 = 0x0e;
-    assert(pgfault_num==10);
+    assert(pgfault_num == 10);
     cprintf("write Virt Page a in fifo_check_swap\n");
     assert(*(unsigned char *)0x1000 == 0x0a);
     *(unsigned char *)0x1000 = 0x0a;
-    assert(pgfault_num==11);
+    assert(pgfault_num == 11);
     return 0;
 }
 
-
 static int
 _fifo_init(void)
 {
@@ -127,17 +132,18 @@
 
 static int
 _fifo_tick_event(struct mm_struct *mm)
-{ return 0; }
-
+{
+    return 0;
+}
 
 struct swap_manager swap_manager_fifo =
-{
-     .name            = "fifo swap manager",
-     .init            = &_fifo_init,
-     .init_mm         = &_fifo_init_mm,
-     .tick_event      = &_fifo_tick_event,
-     .map_swappable   = &_fifo_map_swappable,
-     .set_unswappable = &_fifo_set_unswappable,
-     .swap_out_victim = &_fifo_swap_out_victim,
-     .check_swap      = &_fifo_check_swap,
+    {
+        .name = "fifo swap manager",
+        .init = &_fifo_init,
+        .init_mm = &_fifo_init_mm,
+        .tick_event = &_fifo_tick_event,
+        .map_swappable = &_fifo_map_swappable,
+        .set_unswappable = &_fifo_set_unswappable,
+        .swap_out_victim = &_fifo_swap_out_victim,
+        .check_swap = &_fifo_check_swap,
 };
diff -ruP /home/xmh/origin/ucore_os_lab/labcodes/lab7/kern/mm/vmm.c lab7/kern/mm/vmm.c
--- /home/xmh/origin/ucore_os_lab/labcodes/lab7/kern/mm/vmm.c	2020-05-24 07:28:36.526368975 +0000
+++ lab7/kern/mm/vmm.c	2020-05-24 09:18:16.207869398 +0000
@@ -72,95 +72,106 @@
     return vma;
 }
 
-
 // find_vma - find a vma  (vma->vm_start <= addr <= vma_vm_end)
 struct vma_struct *
-find_vma(struct mm_struct *mm, uintptr_t addr) {
+find_vma(struct mm_struct *mm, uintptr_t addr)
+{
     struct vma_struct *vma = NULL;
-    if (mm != NULL) {
+    if (mm != NULL)
+    {
         vma = mm->mmap_cache;
-        if (!(vma != NULL && vma->vm_start <= addr && vma->vm_end > addr)) {
-                bool found = 0;
-                list_entry_t *list = &(mm->mmap_list), *le = list;
-                while ((le = list_next(le)) != list) {
-                    vma = le2vma(le, list_link);
-                    if (vma->vm_start<=addr && addr < vma->vm_end) {
-                        found = 1;
-                        break;
-                    }
-                }
-                if (!found) {
-                    vma = NULL;
+        if (!(vma != NULL && vma->vm_start <= addr && vma->vm_end > addr))
+        {
+            bool found = 0;
+            list_entry_t *list = &(mm->mmap_list), *le = list;
+            while ((le = list_next(le)) != list)
+            {
+                vma = le2vma(le, list_link);
+                if (vma->vm_start <= addr && addr < vma->vm_end)
+                {
+                    found = 1;
+                    break;
                 }
+            }
+            if (!found)
+            {
+                vma = NULL;
+            }
         }
-        if (vma != NULL) {
+        if (vma != NULL)
+        {
             mm->mmap_cache = vma;
         }
     }
     return vma;
 }
 
-
 // check_vma_overlap - check if vma1 overlaps vma2 ?
 static inline void
-check_vma_overlap(struct vma_struct *prev, struct vma_struct *next) {
+check_vma_overlap(struct vma_struct *prev, struct vma_struct *next)
+{
     assert(prev->vm_start < prev->vm_end);
     assert(prev->vm_end <= next->vm_start);
     assert(next->vm_start < next->vm_end);
 }
 
-
 // insert_vma_struct -insert vma in mm's list link
-void
-insert_vma_struct(struct mm_struct *mm, struct vma_struct *vma) {
+void insert_vma_struct(struct mm_struct *mm, struct vma_struct *vma)
+{
     assert(vma->vm_start < vma->vm_end);
     list_entry_t *list = &(mm->mmap_list);
     list_entry_t *le_prev = list, *le_next;
 
-        list_entry_t *le = list;
-        while ((le = list_next(le)) != list) {
-            struct vma_struct *mmap_prev = le2vma(le, list_link);
-            if (mmap_prev->vm_start > vma->vm_start) {
-                break;
-            }
-            le_prev = le;
+    list_entry_t *le = list;
+    while ((le = list_next(le)) != list)
+    {
+        struct vma_struct *mmap_prev = le2vma(le, list_link);
+        if (mmap_prev->vm_start > vma->vm_start)
+        {
+            break;
         }
+        le_prev = le;
+    }
 
     le_next = list_next(le_prev);
 
     /* check overlap */
-    if (le_prev != list) {
+    if (le_prev != list)
+    {
         check_vma_overlap(le2vma(le_prev, list_link), vma);
     }
-    if (le_next != list) {
+    if (le_next != list)
+    {
         check_vma_overlap(vma, le2vma(le_next, list_link));
     }
 
     vma->vm_mm = mm;
     list_add_after(le_prev, &(vma->list_link));
 
-    mm->map_count ++;
+    mm->map_count++;
 }
 
 // mm_destroy - free mm and mm internal fields
-void
-mm_destroy(struct mm_struct *mm) {
+void mm_destroy(struct mm_struct *mm)
+{
     assert(mm_count(mm) == 0);
 
     list_entry_t *list = &(mm->mmap_list), *le;
-    while ((le = list_next(list)) != list) {
+    while ((le = list_next(list)) != list)
+    {
         list_del(le);
-        kfree(le2vma(le, list_link));  //kfree vma        
+        kfree(le2vma(le, list_link)); //kfree vma
     }
     kfree(mm); //kfree mm
-    mm=NULL;
+    mm = NULL;
 }
 
-int
-mm_map(struct mm_struct *mm, uintptr_t addr, size_t len, uint32_t vm_flags,
-       struct vma_struct **vma_store) {
+int mm_map(struct mm_struct *mm, uintptr_t addr, size_t len, uint32_t vm_flags,
+           struct vma_struct **vma_store)
+{
     uintptr_t start = ROUNDDOWN(addr, PGSIZE), end = ROUNDUP(addr + len, PGSIZE);
-    if (!USER_ACCESS(start, end)) {
+    if (!USER_ACCESS(start, end))
+    {
         return -E_INVAL;
     }
 
@@ -169,16 +180,19 @@
     int ret = -E_INVAL;
 
     struct vma_struct *vma;
-    if ((vma = find_vma(mm, start)) != NULL && end > vma->vm_start) {
+    if ((vma = find_vma(mm, start)) != NULL && end > vma->vm_start)
+    {
         goto out;
     }
     ret = -E_NO_MEM;
 
-    if ((vma = vma_create(start, end, vm_flags)) == NULL) {
+    if ((vma = vma_create(start, end, vm_flags)) == NULL)
+    {
         goto out;
     }
     insert_vma_struct(mm, vma);
-    if (vma_store != NULL) {
+    if (vma_store != NULL)
+    {
         *vma_store = vma;
     }
     ret = 0;
@@ -187,55 +201,62 @@
     return ret;
 }
 
-int
-dup_mmap(struct mm_struct *to, struct mm_struct *from) {
+int dup_mmap(struct mm_struct *to, struct mm_struct *from)
+{
     assert(to != NULL && from != NULL);
     list_entry_t *list = &(from->mmap_list), *le = list;
-    while ((le = list_prev(le)) != list) {
+    while ((le = list_prev(le)) != list)
+    {
         struct vma_struct *vma, *nvma;
         vma = le2vma(le, list_link);
         nvma = vma_create(vma->vm_start, vma->vm_end, vma->vm_flags);
-        if (nvma == NULL) {
+        if (nvma == NULL)
+        {
             return -E_NO_MEM;
         }
 
         insert_vma_struct(to, nvma);
 
         bool share = 0;
-        if (copy_range(to->pgdir, from->pgdir, vma->vm_start, vma->vm_end, share) != 0) {
+        if (copy_range(to->pgdir, from->pgdir, vma->vm_start, vma->vm_end, share) != 0)
+        {
             return -E_NO_MEM;
         }
     }
     return 0;
 }
 
-void
-exit_mmap(struct mm_struct *mm) {
+void exit_mmap(struct mm_struct *mm)
+{
     assert(mm != NULL && mm_count(mm) == 0);
     pde_t *pgdir = mm->pgdir;
     list_entry_t *list = &(mm->mmap_list), *le = list;
-    while ((le = list_next(le)) != list) {
+    while ((le = list_next(le)) != list)
+    {
         struct vma_struct *vma = le2vma(le, list_link);
         unmap_range(pgdir, vma->vm_start, vma->vm_end);
     }
-    while ((le = list_next(le)) != list) {
+    while ((le = list_next(le)) != list)
+    {
         struct vma_struct *vma = le2vma(le, list_link);
         exit_range(pgdir, vma->vm_start, vma->vm_end);
     }
 }
 
-bool
-copy_from_user(struct mm_struct *mm, void *dst, const void *src, size_t len, bool writable) {
-    if (!user_mem_check(mm, (uintptr_t)src, len, writable)) {
+bool copy_from_user(struct mm_struct *mm, void *dst, const void *src, size_t len, bool writable)
+{
+    if (!user_mem_check(mm, (uintptr_t)src, len, writable))
+    {
         return 0;
     }
     memcpy(dst, src, len);
     return 1;
 }
 
-bool
-copy_to_user(struct mm_struct *mm, void *dst, const void *src, size_t len) {
-    if (!user_mem_check(mm, (uintptr_t)dst, len, 1)) {
+bool copy_to_user(struct mm_struct *mm, void *dst, const void *src, size_t len)
+{
+    if (!user_mem_check(mm, (uintptr_t)dst, len, 1))
+    {
         return 0;
     }
     memcpy(dst, src, len);
@@ -244,16 +265,17 @@
 
 // vmm_init - initialize virtual memory management
 //          - now just call check_vmm to check correctness of vmm
-void
-vmm_init(void) {
+void vmm_init(void)
+{
     check_vmm();
 }
 
 // check_vmm - check correctness of vmm
 static void
-check_vmm(void) {
+check_vmm(void)
+{
     size_t nr_free_pages_store = nr_free_pages();
-    
+
     check_vma_struct();
     check_pgfault();
 
@@ -261,7 +283,8 @@
 }
 
 static void
-check_vma_struct(void) {
+check_vma_struct(void)
+{
     size_t nr_free_pages_store = nr_free_pages();
 
     struct mm_struct *mm = mm_create();
@@ -270,13 +293,15 @@
     int step1 = 10, step2 = step1 * 10;
 
     int i;
-    for (i = step1; i >= 1; i --) {
+    for (i = step1; i >= 1; i--)
+    {
         struct vma_struct *vma = vma_create(i * 5, i * 5 + 2, 0);
         assert(vma != NULL);
         insert_vma_struct(mm, vma);
     }
 
-    for (i = step1 + 1; i <= step2; i ++) {
+    for (i = step1 + 1; i <= step2; i++)
+    {
         struct vma_struct *vma = vma_create(i * 5, i * 5 + 2, 0);
         assert(vma != NULL);
         insert_vma_struct(mm, vma);
@@ -284,33 +309,37 @@
 
     list_entry_t *le = list_next(&(mm->mmap_list));
 
-    for (i = 1; i <= step2; i ++) {
+    for (i = 1; i <= step2; i++)
+    {
         assert(le != &(mm->mmap_list));
         struct vma_struct *mmap = le2vma(le, list_link);
         assert(mmap->vm_start == i * 5 && mmap->vm_end == i * 5 + 2);
         le = list_next(le);
     }
 
-    for (i = 5; i <= 5 * step2; i +=5) {
+    for (i = 5; i <= 5 * step2; i += 5)
+    {
         struct vma_struct *vma1 = find_vma(mm, i);
         assert(vma1 != NULL);
-        struct vma_struct *vma2 = find_vma(mm, i+1);
+        struct vma_struct *vma2 = find_vma(mm, i + 1);
         assert(vma2 != NULL);
-        struct vma_struct *vma3 = find_vma(mm, i+2);
+        struct vma_struct *vma3 = find_vma(mm, i + 2);
         assert(vma3 == NULL);
-        struct vma_struct *vma4 = find_vma(mm, i+3);
+        struct vma_struct *vma4 = find_vma(mm, i + 3);
         assert(vma4 == NULL);
-        struct vma_struct *vma5 = find_vma(mm, i+4);
+        struct vma_struct *vma5 = find_vma(mm, i + 4);
         assert(vma5 == NULL);
 
-        assert(vma1->vm_start == i  && vma1->vm_end == i  + 2);
-        assert(vma2->vm_start == i  && vma2->vm_end == i  + 2);
+        assert(vma1->vm_start == i && vma1->vm_end == i + 2);
+        assert(vma2->vm_start == i && vma2->vm_end == i + 2);
     }
 
-    for (i =4; i>=0; i--) {
-        struct vma_struct *vma_below_5= find_vma(mm,i);
-        if (vma_below_5 != NULL ) {
-           cprintf("vma_below_5: i %x, start %x, end %x\n",i, vma_below_5->vm_start, vma_below_5->vm_end); 
+    for (i = 4; i >= 0; i--)
+    {
+        struct vma_struct *vma_below_5 = find_vma(mm, i);
+        if (vma_below_5 != NULL)
+        {
+            cprintf("vma_below_5: i %x, start %x, end %x\n", i, vma_below_5->vm_start, vma_below_5->vm_end);
         }
         assert(vma_below_5 == NULL);
     }
@@ -324,7 +353,8 @@
 
 // check_pgfault - check correctness of pgfault handler
 static void
-check_pgfault(void) {
+check_pgfault(void)
+{
     size_t nr_free_pages_store = nr_free_pages();
 
     check_mm_struct = mm_create();
@@ -343,11 +373,13 @@
     assert(find_vma(mm, addr) == vma);
 
     int i, sum = 0;
-    for (i = 0; i < 100; i ++) {
+    for (i = 0; i < 100; i++)
+    {
         *(char *)(addr + i) = i;
         sum += i;
     }
-    for (i = 0; i < 100; i ++) {
+    for (i = 0; i < 100; i++)
+    {
         sum -= *(char *)(addr + i);
     }
     assert(sum == 0);
@@ -365,7 +397,7 @@
     cprintf("check_pgfault() succeeded!\n");
 }
 //page fault number
-volatile unsigned int pgfault_num=0;
+volatile unsigned int pgfault_num = 0;
 
 /* do_pgfault - interrupt handler to process the page fault execption
  * @mm         : the control struct for a set of vma using the same PDT
@@ -388,24 +420,27 @@
  *         -- The U/S flag (bit 2) indicates whether the processor was executing at user mode (1)
  *            or supervisor mode (0) at the time of the exception.
  */
-int
-do_pgfault(struct mm_struct *mm, uint32_t error_code, uintptr_t addr) {
+int do_pgfault(struct mm_struct *mm, uint32_t error_code, uintptr_t addr)
+{
     int ret = -E_INVAL;
     //try to find a vma which include addr
     struct vma_struct *vma = find_vma(mm, addr);
 
     pgfault_num++;
     //If the addr is in the range of a mm's vma?
-    if (vma == NULL || vma->vm_start > addr) {
+    if (vma == NULL || vma->vm_start > addr)
+    {
         cprintf("not valid addr %x, and  can not find it in vma\n", addr);
         goto failed;
     }
     //check the error_code
-    switch (error_code & 3) {
+    switch (error_code & 3)
+    {
     default:
-            /* error code flag : default is 3 ( W/R=1, P=1): write, present */
+        /* error code flag : default is 3 ( W/R=1, P=1): write, present */
     case 2: /* error code flag : (W/R=1, P=0): write, not present */
-        if (!(vma->vm_flags & VM_WRITE)) {
+        if (!(vma->vm_flags & VM_WRITE))
+        {
             cprintf("do_pgfault failed: error code flag = write AND not present, but the addr's vma cannot write\n");
             goto failed;
         }
@@ -414,7 +449,8 @@
         cprintf("do_pgfault failed: error code flag = read AND present\n");
         goto failed;
     case 0: /* error code flag : (W/R=0, P=0): read, not present */
-        if (!(vma->vm_flags & (VM_READ | VM_EXEC))) {
+        if (!(vma->vm_flags & (VM_READ | VM_EXEC)))
+        {
             cprintf("do_pgfault failed: error code flag = read AND not present, but the addr's vma cannot read or exec\n");
             goto failed;
         }
@@ -426,14 +462,15 @@
      *    continue process
      */
     uint32_t perm = PTE_U;
-    if (vma->vm_flags & VM_WRITE) {
+    if (vma->vm_flags & VM_WRITE)
+    {
         perm |= PTE_W;
     }
     addr = ROUNDDOWN(addr, PGSIZE);
 
     ret = -E_NO_MEM;
 
-    pte_t *ptep=NULL;
+    pte_t *ptep = NULL;
     /*LAB3 EXERCISE 1: YOUR CODE
     * Maybe you want help comment, BELOW comments can help you finish the code
     *
@@ -493,28 +530,71 @@
         }
    }
 #endif
-   ret = 0;
+    ptep = get_pte(mm->pgdir, addr, 1);
+    if (ptep == NULL)
+    {
+        cprintf("get_pte failed\n");
+        goto failed;
+    }
+
+    if (*ptep == 0)
+    {
+        struct Page *page = pgdir_alloc_page(mm->pgdir, addr, perm);
+        if (page == NULL)
+        {
+            cprintf("pgdir_alloc_page failed\n");
+            goto failed;
+        }
+    }
+    else
+    {
+        if (swap_init_ok)
+        {
+            struct Page *page = NULL;
+            if ((ret = swap_in(mm, addr, &page)) != 0)
+            {
+                cprintf("swap_in failed\n");
+                goto failed;
+            }
+            page_insert(mm->pgdir, page, addr, perm);
+            swap_map_swappable(mm, addr, page, 1);
+            page->pra_vaddr = addr;
+        }
+        else
+        {
+            cprintf("no swap_init_ok but ptep is %x, failed\n", *ptep);
+            goto failed;
+        }
+    }
+    ret = 0;
 failed:
     return ret;
 }
 
-bool
-user_mem_check(struct mm_struct *mm, uintptr_t addr, size_t len, bool write) {
-    if (mm != NULL) {
-        if (!USER_ACCESS(addr, addr + len)) {
+bool user_mem_check(struct mm_struct *mm, uintptr_t addr, size_t len, bool write)
+{
+    if (mm != NULL)
+    {
+        if (!USER_ACCESS(addr, addr + len))
+        {
             return 0;
         }
         struct vma_struct *vma;
         uintptr_t start = addr, end = addr + len;
-        while (start < end) {
-            if ((vma = find_vma(mm, start)) == NULL || start < vma->vm_start) {
+        while (start < end)
+        {
+            if ((vma = find_vma(mm, start)) == NULL || start < vma->vm_start)
+            {
                 return 0;
             }
-            if (!(vma->vm_flags & ((write) ? VM_WRITE : VM_READ))) {
+            if (!(vma->vm_flags & ((write) ? VM_WRITE : VM_READ)))
+            {
                 return 0;
             }
-            if (write && (vma->vm_flags & VM_STACK)) {
-                if (start < vma->vm_start + PGSIZE) { //check stack start & size
+            if (write && (vma->vm_flags & VM_STACK))
+            {
+                if (start < vma->vm_start + PGSIZE)
+                { //check stack start & size
                     return 0;
                 }
             }
@@ -524,4 +604,3 @@
     }
     return KERN_ACCESS(addr, addr + len);
 }
-
diff -ruP /home/xmh/origin/ucore_os_lab/labcodes/lab7/kern/process/proc.c lab7/kern/process/proc.c
--- /home/xmh/origin/ucore_os_lab/labcodes/lab7/kern/process/proc.c	2020-05-24 07:28:36.526368975 +0000
+++ lab7/kern/process/proc.c	2020-05-24 14:00:45.502491970 +0000
@@ -59,12 +59,23 @@
 
 */
 
+#define __Lock(lock)                            \
+    do                                          \
+    {                                           \
+        if (__sync_lock_test_and_set(&lock, 1)) \
+            continue;
+
+#define __UnLock(lock)             \
+    __sync_lock_release(&lock, 0); \
+    }                              \
+    while (0)
+
 // the process set's list
 list_entry_t proc_list;
 
-#define HASH_SHIFT          10
-#define HASH_LIST_SIZE      (1 << HASH_SHIFT)
-#define pid_hashfn(x)       (hash32(x, HASH_SHIFT))
+#define HASH_SHIFT 10
+#define HASH_LIST_SIZE (1 << HASH_SHIFT)
+#define pid_hashfn(x) (hash32(x, HASH_SHIFT))
 
 // has list for process set based on pid
 static list_entry_t hash_list[HASH_LIST_SIZE];
@@ -84,11 +95,13 @@
 
 // alloc_proc - alloc a proc_struct and init all fields of proc_struct
 static struct proc_struct *
-alloc_proc(void) {
+alloc_proc(void)
+{
     struct proc_struct *proc = kmalloc(sizeof(struct proc_struct));
-    if (proc != NULL) {
-    //LAB4:EXERCISE1 YOUR CODE
-    /*
+    if (proc != NULL)
+    {
+        //LAB4:EXERCISE1 YOUR CODE
+        /*
      * below fields in proc_struct need to be initialized
      *       enum proc_state state;                      // Process state
      *       int pid;                                    // Process ID
@@ -103,14 +116,30 @@
      *       uint32_t flags;                             // Process flag
      *       char name[PROC_NAME_LEN + 1];               // Process name
      */
-     //LAB5 YOUR CODE : (update LAB4 steps)
-    /*
+        proc->state = PROC_UNINIT;
+        proc->pid = -1;
+        proc->runs = 0;
+        proc->kstack = 0;
+        proc->need_resched = 0;
+        proc->parent = NULL;
+        proc->mm = NULL;
+        memset(&(proc->context), 0, sizeof(struct context));
+        proc->tf = NULL;
+        proc->cr3 = boot_cr3;
+        proc->flags = 0;
+        memset(proc->name, 0, PROC_NAME_LEN);
+        //LAB5 YOUR CODE : (update LAB4 steps)
+        /*
      * below fields(add in LAB5) in proc_struct need to be initialized	
      *       uint32_t wait_state;                        // waiting state
      *       struct proc_struct *cptr, *yptr, *optr;     // relations between processes
 	 */
-     //LAB6 YOUR CODE : (update LAB5 steps)
-    /*
+        proc->wait_state = 0;
+        proc->cptr = NULL;
+        proc->optr = NULL;
+        proc->yptr = NULL;
+        //LAB6 YOUR CODE : (update LAB5 steps)
+        /*
      * below fields(add in LAB6) in proc_struct need to be initialized
      *     struct run_queue *rq;                       // running queue contains Process
      *     list_entry_t run_link;                      // the entry linked in run queue
@@ -119,20 +148,28 @@
      *     uint32_t lab6_stride;                       // FOR LAB6 ONLY: the current stride of the process
      *     uint32_t lab6_priority;                     // FOR LAB6 ONLY: the priority of process, set by lab6_set_priority(uint32_t)
      */
+        proc->rq = NULL;
+        list_init(&(proc->run_link));
+        proc->time_slice = 0;
+        proc->lab6_run_pool.left = proc->lab6_run_pool.right = proc->lab6_run_pool.parent = NULL;
+        proc->lab6_priority = 0;
+        proc->lab6_stride = 0;
     }
     return proc;
 }
 
 // set_proc_name - set the name of proc
 char *
-set_proc_name(struct proc_struct *proc, const char *name) {
+set_proc_name(struct proc_struct *proc, const char *name)
+{
     memset(proc->name, 0, sizeof(proc->name));
     return memcpy(proc->name, name, PROC_NAME_LEN);
 }
 
 // get_proc_name - get the name of proc
 char *
-get_proc_name(struct proc_struct *proc) {
+get_proc_name(struct proc_struct *proc)
+{
     static char name[PROC_NAME_LEN + 1];
     memset(name, 0, sizeof(name));
     return memcpy(name, proc->name, PROC_NAME_LEN);
@@ -140,60 +177,74 @@
 
 // set_links - set the relation links of process
 static void
-set_links(struct proc_struct *proc) {
+set_links(struct proc_struct *proc)
+{
     list_add(&proc_list, &(proc->list_link));
     proc->yptr = NULL;
-    if ((proc->optr = proc->parent->cptr) != NULL) {
+    if ((proc->optr = proc->parent->cptr) != NULL)
+    {
         proc->optr->yptr = proc;
     }
     proc->parent->cptr = proc;
-    nr_process ++;
+    nr_process++;
 }
 
 // remove_links - clean the relation links of process
 static void
-remove_links(struct proc_struct *proc) {
+remove_links(struct proc_struct *proc)
+{
     list_del(&(proc->list_link));
-    if (proc->optr != NULL) {
+    if (proc->optr != NULL)
+    {
         proc->optr->yptr = proc->yptr;
     }
-    if (proc->yptr != NULL) {
+    if (proc->yptr != NULL)
+    {
         proc->yptr->optr = proc->optr;
     }
-    else {
-       proc->parent->cptr = proc->optr;
+    else
+    {
+        proc->parent->cptr = proc->optr;
     }
-    nr_process --;
+    nr_process--;
 }
 
 // get_pid - alloc a unique pid for process
 static int
-get_pid(void) {
+get_pid(void)
+{
     static_assert(MAX_PID > MAX_PROCESS);
     struct proc_struct *proc;
     list_entry_t *list = &proc_list, *le;
     static int next_safe = MAX_PID, last_pid = MAX_PID;
-    if (++ last_pid >= MAX_PID) {
+    if (++last_pid >= MAX_PID)
+    {
         last_pid = 1;
         goto inside;
     }
-    if (last_pid >= next_safe) {
+    if (last_pid >= next_safe)
+    {
     inside:
         next_safe = MAX_PID;
     repeat:
         le = list;
-        while ((le = list_next(le)) != list) {
+        while ((le = list_next(le)) != list)
+        {
             proc = le2proc(le, list_link);
-            if (proc->pid == last_pid) {
-                if (++ last_pid >= next_safe) {
-                    if (last_pid >= MAX_PID) {
+            if (proc->pid == last_pid)
+            {
+                if (++last_pid >= next_safe)
+                {
+                    if (last_pid >= MAX_PID)
+                    {
                         last_pid = 1;
                     }
                     next_safe = MAX_PID;
                     goto repeat;
                 }
             }
-            else if (proc->pid > last_pid && next_safe > proc->pid) {
+            else if (proc->pid > last_pid && next_safe > proc->pid)
+            {
                 next_safe = proc->pid;
             }
         }
@@ -203,9 +254,10 @@
 
 // proc_run - make process "proc" running on cpu
 // NOTE: before call switch_to, should load  base addr of "proc"'s new PDT
-void
-proc_run(struct proc_struct *proc) {
-    if (proc != current) {
+void proc_run(struct proc_struct *proc)
+{
+    if (proc != current)
+    {
         bool intr_flag;
         struct proc_struct *prev = current, *next = proc;
         local_intr_save(intr_flag);
@@ -223,30 +275,37 @@
 // NOTE: the addr of forkret is setted in copy_thread function
 //       after switch_to, the current proc will execute here.
 static void
-forkret(void) {
+forkret(void)
+{
     forkrets(current->tf);
 }
 
 // hash_proc - add proc into proc hash_list
 static void
-hash_proc(struct proc_struct *proc) {
+hash_proc(struct proc_struct *proc)
+{
     list_add(hash_list + pid_hashfn(proc->pid), &(proc->hash_link));
 }
 
 // unhash_proc - delete proc from proc hash_list
 static void
-unhash_proc(struct proc_struct *proc) {
+unhash_proc(struct proc_struct *proc)
+{
     list_del(&(proc->hash_link));
 }
 
 // find_proc - find proc frome proc hash_list according to pid
 struct proc_struct *
-find_proc(int pid) {
-    if (0 < pid && pid < MAX_PID) {
+find_proc(int pid)
+{
+    if (0 < pid && pid < MAX_PID)
+    {
         list_entry_t *list = hash_list + pid_hashfn(pid), *le = list;
-        while ((le = list_next(le)) != list) {
+        while ((le = list_next(le)) != list)
+        {
             struct proc_struct *proc = le2proc(le, hash_link);
-            if (proc->pid == pid) {
+            if (proc->pid == pid)
+            {
                 return proc;
             }
         }
@@ -255,10 +314,10 @@
 }
 
 // kernel_thread - create a kernel thread using "fn" function
-// NOTE: the contents of temp trapframe tf will be copied to 
+// NOTE: the contents of temp trapframe tf will be copied to
 //       proc->tf in do_fork-->copy_thread function
-int
-kernel_thread(int (*fn)(void *), void *arg, uint32_t clone_flags) {
+int kernel_thread(int (*fn)(void *), void *arg, uint32_t clone_flags)
+{
     struct trapframe tf;
     memset(&tf, 0, sizeof(struct trapframe));
     tf.tf_cs = KERNEL_CS;
@@ -271,9 +330,11 @@
 
 // setup_kstack - alloc pages with size KSTACKPAGE as process kernel stack
 static int
-setup_kstack(struct proc_struct *proc) {
+setup_kstack(struct proc_struct *proc)
+{
     struct Page *page = alloc_pages(KSTACKPAGE);
-    if (page != NULL) {
+    if (page != NULL)
+    {
         proc->kstack = (uintptr_t)page2kva(page);
         return 0;
     }
@@ -282,15 +343,18 @@
 
 // put_kstack - free the memory space of process kernel stack
 static void
-put_kstack(struct proc_struct *proc) {
+put_kstack(struct proc_struct *proc)
+{
     free_pages(kva2page((void *)(proc->kstack)), KSTACKPAGE);
 }
 
 // setup_pgdir - alloc one page as PDT
 static int
-setup_pgdir(struct mm_struct *mm) {
+setup_pgdir(struct mm_struct *mm)
+{
     struct Page *page;
-    if ((page = alloc_page()) == NULL) {
+    if ((page = alloc_page()) == NULL)
+    {
         return -E_NO_MEM;
     }
     pde_t *pgdir = page2kva(page);
@@ -302,30 +366,36 @@
 
 // put_pgdir - free the memory space of PDT
 static void
-put_pgdir(struct mm_struct *mm) {
+put_pgdir(struct mm_struct *mm)
+{
     free_page(kva2page(mm->pgdir));
 }
 
 // copy_mm - process "proc" duplicate OR share process "current"'s mm according clone_flags
 //         - if clone_flags & CLONE_VM, then "share" ; else "duplicate"
 static int
-copy_mm(uint32_t clone_flags, struct proc_struct *proc) {
+copy_mm(uint32_t clone_flags, struct proc_struct *proc)
+{
     struct mm_struct *mm, *oldmm = current->mm;
 
     /* current is a kernel thread */
-    if (oldmm == NULL) {
+    if (oldmm == NULL)
+    {
         return 0;
     }
-    if (clone_flags & CLONE_VM) {
+    if (clone_flags & CLONE_VM)
+    {
         mm = oldmm;
         goto good_mm;
     }
 
     int ret = -E_NO_MEM;
-    if ((mm = mm_create()) == NULL) {
+    if ((mm = mm_create()) == NULL)
+    {
         goto bad_mm;
     }
-    if (setup_pgdir(mm) != 0) {
+    if (setup_pgdir(mm) != 0)
+    {
         goto bad_pgdir_cleanup_mm;
     }
 
@@ -335,7 +405,8 @@
     }
     unlock_mm(oldmm);
 
-    if (ret != 0) {
+    if (ret != 0)
+    {
         goto bad_dup_cleanup_mmap;
     }
 
@@ -356,7 +427,8 @@
 // copy_thread - setup the trapframe on the  process's kernel stack top and
 //             - setup the kernel entry point and stack of process
 static void
-copy_thread(struct proc_struct *proc, uintptr_t esp, struct trapframe *tf) {
+copy_thread(struct proc_struct *proc, uintptr_t esp, struct trapframe *tf)
+{
     proc->tf = (struct trapframe *)(proc->kstack + KSTACKSIZE) - 1;
     *(proc->tf) = *tf;
     proc->tf->tf_regs.reg_eax = 0;
@@ -372,11 +444,12 @@
  * @stack:       the parent's user stack pointer. if stack==0, It means to fork a kernel thread.
  * @tf:          the trapframe info, which will be copied to child process's proc->tf
  */
-int
-do_fork(uint32_t clone_flags, uintptr_t stack, struct trapframe *tf) {
+int do_fork(uint32_t clone_flags, uintptr_t stack, struct trapframe *tf)
+{
     int ret = -E_NO_FREE_PROC;
     struct proc_struct *proc;
-    if (nr_process >= MAX_PROCESS) {
+    if (nr_process >= MAX_PROCESS)
+    {
         goto fork_out;
     }
     ret = -E_NO_MEM;
@@ -405,15 +478,44 @@
     //    5. insert proc_struct into hash_list && proc_list
     //    6. call wakeup_proc to make the new child process RUNNABLE
     //    7. set ret vaule using child proc's pid
+    if ((proc = alloc_proc()) == NULL)
+    {
+        goto fork_out;
+    }
+    proc->parent = current;
+    // *    update step 1: set child proc's parent to current process, make sure current process's wait_state is 0
+    assert(current->wait_state == 0);
+    if (setup_kstack(proc) != 0)
+    {
+        goto bad_fork_cleanup_proc;
+    }
+    if (copy_mm(clone_flags, proc) != 0)
+    {
+        goto bad_fork_cleanup_kstack;
+    }
+    copy_thread(proc, stack, tf);
+
+    bool intr_flag;
+    local_intr_save(intr_flag);
+    static int lock = 0;
+    // __Lock(lock);
+    {
+        proc->pid = get_pid();
+        hash_proc(proc);
+        // *    update step 5: insert proc_struct into hash_list && proc_list, set the relation links of process
+        set_links(proc);
+    }
+    // __UnLock(lock);
+    local_intr_restore(intr_flag);
+    wakeup_proc(proc);
+    ret = proc->pid;
 
-	//LAB5 YOUR CODE : (update LAB4 steps)
-   /* Some Functions
+    //LAB5 YOUR CODE : (update LAB4 steps)
+    /* Some Functions
     *    set_links:  set the relation links of process.  ALSO SEE: remove_links:  lean the relation links of process 
     *    -------------------
-	*    update step 1: set child proc's parent to current process, make sure current process's wait_state is 0
-	*    update step 5: insert proc_struct into hash_list && proc_list, set the relation links of process
     */
-	
+
 fork_out:
     return ret;
 
@@ -428,19 +530,23 @@
 //   1. call exit_mmap & put_pgdir & mm_destroy to free the almost all memory space of process
 //   2. set process' state as PROC_ZOMBIE, then call wakeup_proc(parent) to ask parent reclaim itself.
 //   3. call scheduler to switch to other process
-int
-do_exit(int error_code) {
-    if (current == idleproc) {
+int do_exit(int error_code)
+{
+    if (current == idleproc)
+    {
         panic("idleproc exit.\n");
     }
-    if (current == initproc) {
+    if (current == initproc)
+    {
         panic("initproc exit.\n");
     }
-    
+
     struct mm_struct *mm = current->mm;
-    if (mm != NULL) {
+    if (mm != NULL)
+    {
         lcr3(boot_cr3);
-        if (mm_count_dec(mm) == 0) {
+        if (mm_count_dec(mm) == 0)
+        {
             exit_mmap(mm);
             put_pgdir(mm);
             mm_destroy(mm);
@@ -449,34 +555,39 @@
     }
     current->state = PROC_ZOMBIE;
     current->exit_code = error_code;
-    
+
     bool intr_flag;
     struct proc_struct *proc;
     local_intr_save(intr_flag);
     {
         proc = current->parent;
-        if (proc->wait_state == WT_CHILD) {
+        if (proc->wait_state == WT_CHILD)
+        {
             wakeup_proc(proc);
         }
-        while (current->cptr != NULL) {
+        while (current->cptr != NULL)
+        {
             proc = current->cptr;
             current->cptr = proc->optr;
-    
+
             proc->yptr = NULL;
-            if ((proc->optr = initproc->cptr) != NULL) {
+            if ((proc->optr = initproc->cptr) != NULL)
+            {
                 initproc->cptr->yptr = proc;
             }
             proc->parent = initproc;
             initproc->cptr = proc;
-            if (proc->state == PROC_ZOMBIE) {
-                if (initproc->wait_state == WT_CHILD) {
+            if (proc->state == PROC_ZOMBIE)
+            {
+                if (initproc->wait_state == WT_CHILD)
+                {
                     wakeup_proc(initproc);
                 }
             }
         }
     }
     local_intr_restore(intr_flag);
-    
+
     schedule();
     panic("do_exit will not return!! %d.\n", current->pid);
 }
@@ -486,19 +597,23 @@
  * @size:  the size of the content of binary program
  */
 static int
-load_icode(unsigned char *binary, size_t size) {
-    if (current->mm != NULL) {
+load_icode(unsigned char *binary, size_t size)
+{
+    if (current->mm != NULL)
+    {
         panic("load_icode: current->mm must be empty.\n");
     }
 
     int ret = -E_NO_MEM;
     struct mm_struct *mm;
     //(1) create a new mm for current process
-    if ((mm = mm_create()) == NULL) {
+    if ((mm = mm_create()) == NULL)
+    {
         goto bad_mm;
     }
     //(2) create a new PDT, and mm->pgdir= kernel virtual addr of PDT
-    if (setup_pgdir(mm) != 0) {
+    if (setup_pgdir(mm) != 0)
+    {
         goto bad_pgdir_cleanup_mm;
     }
     //(3) copy TEXT/DATA section, build BSS parts in binary to memory space of process
@@ -508,32 +623,42 @@
     //(3.2) get the entry of the program section headers of the bianry program (ELF format)
     struct proghdr *ph = (struct proghdr *)(binary + elf->e_phoff);
     //(3.3) This program is valid?
-    if (elf->e_magic != ELF_MAGIC) {
+    if (elf->e_magic != ELF_MAGIC)
+    {
         ret = -E_INVAL_ELF;
         goto bad_elf_cleanup_pgdir;
     }
 
     uint32_t vm_flags, perm;
     struct proghdr *ph_end = ph + elf->e_phnum;
-    for (; ph < ph_end; ph ++) {
-    //(3.4) find every program section headers
-        if (ph->p_type != ELF_PT_LOAD) {
-            continue ;
+    for (; ph < ph_end; ph++)
+    {
+        //(3.4) find every program section headers
+        if (ph->p_type != ELF_PT_LOAD)
+        {
+            continue;
         }
-        if (ph->p_filesz > ph->p_memsz) {
+        if (ph->p_filesz > ph->p_memsz)
+        {
             ret = -E_INVAL_ELF;
             goto bad_cleanup_mmap;
         }
-        if (ph->p_filesz == 0) {
-            continue ;
+        if (ph->p_filesz == 0)
+        {
+            continue;
         }
-    //(3.5) call mm_map fun to setup the new vma ( ph->p_va, ph->p_memsz)
+        //(3.5) call mm_map fun to setup the new vma ( ph->p_va, ph->p_memsz)
         vm_flags = 0, perm = PTE_U;
-        if (ph->p_flags & ELF_PF_X) vm_flags |= VM_EXEC;
-        if (ph->p_flags & ELF_PF_W) vm_flags |= VM_WRITE;
-        if (ph->p_flags & ELF_PF_R) vm_flags |= VM_READ;
-        if (vm_flags & VM_WRITE) perm |= PTE_W;
-        if ((ret = mm_map(mm, ph->p_va, ph->p_memsz, vm_flags, NULL)) != 0) {
+        if (ph->p_flags & ELF_PF_X)
+            vm_flags |= VM_EXEC;
+        if (ph->p_flags & ELF_PF_W)
+            vm_flags |= VM_WRITE;
+        if (ph->p_flags & ELF_PF_R)
+            vm_flags |= VM_READ;
+        if (vm_flags & VM_WRITE)
+            perm |= PTE_W;
+        if ((ret = mm_map(mm, ph->p_va, ph->p_memsz, vm_flags, NULL)) != 0)
+        {
             goto bad_cleanup_mmap;
         }
         unsigned char *from = binary + ph->p_offset;
@@ -542,42 +667,51 @@
 
         ret = -E_NO_MEM;
 
-     //(3.6) alloc memory, and  copy the contents of every program section (from, from+end) to process's memory (la, la+end)
+        //(3.6) alloc memory, and  copy the contents of every program section (from, from+end) to process's memory (la, la+end)
         end = ph->p_va + ph->p_filesz;
-     //(3.6.1) copy TEXT/DATA section of bianry program
-        while (start < end) {
-            if ((page = pgdir_alloc_page(mm->pgdir, la, perm)) == NULL) {
+        //(3.6.1) copy TEXT/DATA section of bianry program
+        while (start < end)
+        {
+            if ((page = pgdir_alloc_page(mm->pgdir, la, perm)) == NULL)
+            {
                 goto bad_cleanup_mmap;
             }
             off = start - la, size = PGSIZE - off, la += PGSIZE;
-            if (end < la) {
+            if (end < la)
+            {
                 size -= la - end;
             }
             memcpy(page2kva(page) + off, from, size);
             start += size, from += size;
         }
 
-      //(3.6.2) build BSS section of binary program
+        //(3.6.2) build BSS section of binary program
         end = ph->p_va + ph->p_memsz;
-        if (start < la) {
+        if (start < la)
+        {
             /* ph->p_memsz == ph->p_filesz */
-            if (start == end) {
-                continue ;
+            if (start == end)
+            {
+                continue;
             }
             off = start + PGSIZE - la, size = PGSIZE - off;
-            if (end < la) {
+            if (end < la)
+            {
                 size -= la - end;
             }
             memset(page2kva(page) + off, 0, size);
             start += size;
             assert((end < la && start == end) || (end >= la && start == la));
         }
-        while (start < end) {
-            if ((page = pgdir_alloc_page(mm->pgdir, la, perm)) == NULL) {
+        while (start < end)
+        {
+            if ((page = pgdir_alloc_page(mm->pgdir, la, perm)) == NULL)
+            {
                 goto bad_cleanup_mmap;
             }
             off = start - la, size = PGSIZE - off, la += PGSIZE;
-            if (end < la) {
+            if (end < la)
+            {
                 size -= la - end;
             }
             memset(page2kva(page) + off, 0, size);
@@ -586,14 +720,15 @@
     }
     //(4) build user stack memory
     vm_flags = VM_READ | VM_WRITE | VM_STACK;
-    if ((ret = mm_map(mm, USTACKTOP - USTACKSIZE, USTACKSIZE, vm_flags, NULL)) != 0) {
+    if ((ret = mm_map(mm, USTACKTOP - USTACKSIZE, USTACKSIZE, vm_flags, NULL)) != 0)
+    {
         goto bad_cleanup_mmap;
     }
-    assert(pgdir_alloc_page(mm->pgdir, USTACKTOP-PGSIZE , PTE_USER) != NULL);
-    assert(pgdir_alloc_page(mm->pgdir, USTACKTOP-2*PGSIZE , PTE_USER) != NULL);
-    assert(pgdir_alloc_page(mm->pgdir, USTACKTOP-3*PGSIZE , PTE_USER) != NULL);
-    assert(pgdir_alloc_page(mm->pgdir, USTACKTOP-4*PGSIZE , PTE_USER) != NULL);
-    
+    assert(pgdir_alloc_page(mm->pgdir, USTACKTOP - PGSIZE, PTE_USER) != NULL);
+    assert(pgdir_alloc_page(mm->pgdir, USTACKTOP - 2 * PGSIZE, PTE_USER) != NULL);
+    assert(pgdir_alloc_page(mm->pgdir, USTACKTOP - 3 * PGSIZE, PTE_USER) != NULL);
+    assert(pgdir_alloc_page(mm->pgdir, USTACKTOP - 4 * PGSIZE, PTE_USER) != NULL);
+
     //(5) set current process's mm, sr3, and set CR3 reg = physical addr of Page Directory
     mm_count_inc(mm);
     current->mm = mm;
@@ -612,6 +747,12 @@
      *          tf_eip should be the entry point of this binary program (elf->e_entry)
      *          tf_eflags should be set to enable computer to produce Interrupt
      */
+    tf->tf_cs = USER_CS;
+    tf->tf_ds = tf->tf_es = tf->tf_ss = USER_DS;
+    tf->tf_esp = USTACKTOP;
+    tf->tf_eip = elf->e_entry;
+    tf->tf_eflags |= FL_IF;
+    tf->tf_eflags |= 0x2;
     ret = 0;
 out:
     return ret;
@@ -627,13 +768,15 @@
 
 // do_execve - call exit_mmap(mm)&put_pgdir(mm) to reclaim memory space of current process
 //           - call load_icode to setup new memory space accroding binary prog.
-int
-do_execve(const char *name, size_t len, unsigned char *binary, size_t size) {
+int do_execve(const char *name, size_t len, unsigned char *binary, size_t size)
+{
     struct mm_struct *mm = current->mm;
-    if (!user_mem_check(mm, (uintptr_t)name, len, 0)) {
+    if (!user_mem_check(mm, (uintptr_t)name, len, 0))
+    {
         return -E_INVAL;
     }
-    if (len > PROC_NAME_LEN) {
+    if (len > PROC_NAME_LEN)
+    {
         len = PROC_NAME_LEN;
     }
 
@@ -641,9 +784,11 @@
     memset(local_name, 0, sizeof(local_name));
     memcpy(local_name, name, len);
 
-    if (mm != NULL) {
+    if (mm != NULL)
+    {
         lcr3(boot_cr3);
-        if (mm_count_dec(mm) == 0) {
+        if (mm_count_dec(mm) == 0)
+        {
             exit_mmap(mm);
             put_pgdir(mm);
             mm_destroy(mm);
@@ -651,7 +796,8 @@
         current->mm = NULL;
     }
     int ret;
-    if ((ret = load_icode(binary, size)) != 0) {
+    if ((ret = load_icode(binary, size)) != 0)
+    {
         goto execve_exit;
     }
     set_proc_name(current, local_name);
@@ -663,8 +809,8 @@
 }
 
 // do_yield - ask the scheduler to reschedule
-int
-do_yield(void) {
+int do_yield(void)
+{
     current->need_resched = 1;
     return 0;
 }
@@ -672,11 +818,13 @@
 // do_wait - wait one OR any children with PROC_ZOMBIE state, and free memory space of kernel stack
 //         - proc struct of this child.
 // NOTE: only after do_wait function, all resources of the child proces are free.
-int
-do_wait(int pid, int *code_store) {
+int do_wait(int pid, int *code_store)
+{
     struct mm_struct *mm = current->mm;
-    if (code_store != NULL) {
-        if (!user_mem_check(mm, (uintptr_t)code_store, sizeof(int), 1)) {
+    if (code_store != NULL)
+    {
+        if (!user_mem_check(mm, (uintptr_t)code_store, sizeof(int), 1))
+        {
             return -E_INVAL;
         }
     }
@@ -685,29 +833,37 @@
     bool intr_flag, haskid;
 repeat:
     haskid = 0;
-    if (pid != 0) {
+    if (pid != 0)
+    {
         proc = find_proc(pid);
-        if (proc != NULL && proc->parent == current) {
+        if (proc != NULL && proc->parent == current)
+        {
             haskid = 1;
-            if (proc->state == PROC_ZOMBIE) {
+            if (proc->state == PROC_ZOMBIE)
+            {
                 goto found;
             }
         }
     }
-    else {
+    else
+    {
         proc = current->cptr;
-        for (; proc != NULL; proc = proc->optr) {
+        for (; proc != NULL; proc = proc->optr)
+        {
             haskid = 1;
-            if (proc->state == PROC_ZOMBIE) {
+            if (proc->state == PROC_ZOMBIE)
+            {
                 goto found;
             }
         }
     }
-    if (haskid) {
+    if (haskid)
+    {
         current->state = PROC_SLEEPING;
         current->wait_state = WT_CHILD;
         schedule();
-        if (current->flags & PF_EXITING) {
+        if (current->flags & PF_EXITING)
+        {
             do_exit(-E_KILLED);
         }
         goto repeat;
@@ -715,10 +871,12 @@
     return -E_BAD_PROC;
 
 found:
-    if (proc == idleproc || proc == initproc) {
+    if (proc == idleproc || proc == initproc)
+    {
         panic("wait idleproc or initproc.\n");
     }
-    if (code_store != NULL) {
+    if (code_store != NULL)
+    {
         *code_store = proc->exit_code;
     }
     local_intr_save(intr_flag);
@@ -733,13 +891,16 @@
 }
 
 // do_kill - kill process with pid by set this process's flags with PF_EXITING
-int
-do_kill(int pid) {
+int do_kill(int pid)
+{
     struct proc_struct *proc;
-    if ((proc = find_proc(pid)) != NULL) {
-        if (!(proc->flags & PF_EXITING)) {
+    if ((proc = find_proc(pid)) != NULL)
+    {
+        if (!(proc->flags & PF_EXITING))
+        {
             proc->flags |= PF_EXITING;
-            if (proc->wait_state & WT_INTERRUPTED) {
+            if (proc->wait_state & WT_INTERRUPTED)
+            {
                 wakeup_proc(proc);
             }
             return 0;
@@ -751,39 +912,41 @@
 
 // kernel_execve - do SYS_exec syscall to exec a user program called by user_main kernel_thread
 static int
-kernel_execve(const char *name, unsigned char *binary, size_t size) {
+kernel_execve(const char *name, unsigned char *binary, size_t size)
+{
     int ret, len = strlen(name);
-    asm volatile (
+    asm volatile(
         "int %1;"
-        : "=a" (ret)
-        : "i" (T_SYSCALL), "0" (SYS_exec), "d" (name), "c" (len), "b" (binary), "D" (size)
+        : "=a"(ret)
+        : "i"(T_SYSCALL), "0"(SYS_exec), "d"(name), "c"(len), "b"(binary), "D"(size)
         : "memory");
     return ret;
 }
 
-#define __KERNEL_EXECVE(name, binary, size) ({                          \
-            cprintf("kernel_execve: pid = %d, name = \"%s\".\n",        \
-                    current->pid, name);                                \
-            kernel_execve(name, binary, (size_t)(size));                \
-        })
-
-#define KERNEL_EXECVE(x) ({                                             \
-            extern unsigned char _binary_obj___user_##x##_out_start[],  \
-                _binary_obj___user_##x##_out_size[];                    \
-            __KERNEL_EXECVE(#x, _binary_obj___user_##x##_out_start,     \
-                            _binary_obj___user_##x##_out_size);         \
-        })
-
-#define __KERNEL_EXECVE2(x, xstart, xsize) ({                           \
-            extern unsigned char xstart[], xsize[];                     \
-            __KERNEL_EXECVE(#x, xstart, (size_t)xsize);                 \
-        })
+#define __KERNEL_EXECVE(name, binary, size) ({           \
+    cprintf("kernel_execve: pid = %d, name = \"%s\".\n", \
+            current->pid, name);                         \
+    kernel_execve(name, binary, (size_t)(size));         \
+})
+
+#define KERNEL_EXECVE(x) ({                                    \
+    extern unsigned char _binary_obj___user_##x##_out_start[], \
+        _binary_obj___user_##x##_out_size[];                   \
+    __KERNEL_EXECVE(#x, _binary_obj___user_##x##_out_start,    \
+                    _binary_obj___user_##x##_out_size);        \
+})
+
+#define __KERNEL_EXECVE2(x, xstart, xsize) ({   \
+    extern unsigned char xstart[], xsize[];     \
+    __KERNEL_EXECVE(#x, xstart, (size_t)xsize); \
+})
 
-#define KERNEL_EXECVE2(x, xstart, xsize)        __KERNEL_EXECVE2(x, xstart, xsize)
+#define KERNEL_EXECVE2(x, xstart, xsize) __KERNEL_EXECVE2(x, xstart, xsize)
 
 // user_main - kernel thread used to exec a user program
 static int
-user_main(void *arg) {
+user_main(void *arg)
+{
 #ifdef TEST
     KERNEL_EXECVE2(TEST, TESTSTART, TESTSIZE);
 #else
@@ -819,18 +982,20 @@
     return 0;
 }
 
-// proc_init - set up the first kernel thread idleproc "idle" by itself and 
+// proc_init - set up the first kernel thread idleproc "idle" by itself and
 //           - create the second kernel thread init_main
-void
-proc_init(void) {
+void proc_init(void)
+{
     int i;
 
     list_init(&proc_list);
-    for (i = 0; i < HASH_LIST_SIZE; i ++) {
+    for (i = 0; i < HASH_LIST_SIZE; i++)
+    {
         list_init(hash_list + i);
     }
 
-    if ((idleproc = alloc_proc()) == NULL) {
+    if ((idleproc = alloc_proc()) == NULL)
+    {
         panic("cannot alloc idleproc.\n");
     }
 
@@ -839,12 +1004,13 @@
     idleproc->kstack = (uintptr_t)bootstack;
     idleproc->need_resched = 1;
     set_proc_name(idleproc, "idle");
-    nr_process ++;
+    nr_process++;
 
     current = idleproc;
 
     int pid = kernel_thread(init_main, NULL, 0);
-    if (pid <= 0) {
+    if (pid <= 0)
+    {
         panic("create init_main failed.\n");
     }
 
@@ -856,22 +1022,24 @@
 }
 
 // cpu_idle - at the end of kern_init, the first kernel thread idleproc will do below works
-void
-cpu_idle(void) {
-    while (1) {
-        if (current->need_resched) {
+void cpu_idle(void)
+{
+    while (1)
+    {
+        if (current->need_resched)
+        {
             schedule();
         }
     }
 }
 
-//FOR LAB6, set the process's priority (bigger value will get more CPU time) 
-void
-lab6_set_priority(uint32_t priority)
+//FOR LAB6, set the process's priority (bigger value will get more CPU time)
+void lab6_set_priority(uint32_t priority)
 {
     if (priority == 0)
         current->lab6_priority = 1;
-    else current->lab6_priority = priority;
+    else
+        current->lab6_priority = priority;
 }
 
 // do_sleep - set current process state to sleep and add timer with "time"
diff -ruP /home/xmh/origin/ucore_os_lab/labcodes/lab7/kern/schedule/default_sched.c lab7/kern/schedule/default_sched.c
--- /home/xmh/origin/ucore_os_lab/labcodes/lab7/kern/schedule/default_sched.c	2020-05-24 07:28:36.526368975 +0000
+++ lab7/kern/schedule/default_sched.c	2020-05-24 09:18:16.211869442 +0000
@@ -47,12 +47,12 @@
     }
 }
 
-struct sched_class default_sched_class = {
-    .name = "RR_scheduler",
-    .init = RR_init,
-    .enqueue = RR_enqueue,
-    .dequeue = RR_dequeue,
-    .pick_next = RR_pick_next,
-    .proc_tick = RR_proc_tick,
-};
+// struct sched_class default_sched_class = {
+//     .name = "RR_scheduler",
+//     .init = RR_init,
+//     .enqueue = RR_enqueue,
+//     .dequeue = RR_dequeue,
+//     .pick_next = RR_pick_next,
+//     .proc_tick = RR_proc_tick,
+// };
 
只在 /home/xmh/origin/ucore_os_lab/labcodes/lab7/kern/schedule 存在：default_sched_stride_c
diff -ruP /home/xmh/origin/ucore_os_lab/labcodes/lab7/kern/schedule/default_sched_stride.c lab7/kern/schedule/default_sched_stride.c
--- /home/xmh/origin/ucore_os_lab/labcodes/lab7/kern/schedule/default_sched_stride.c	1970-01-01 00:00:00.000000000 +0000
+++ lab7/kern/schedule/default_sched_stride.c	2020-05-24 09:18:16.211869442 +0000
@@ -0,0 +1,165 @@
+#include <defs.h>
+#include <list.h>
+#include <proc.h>
+#include <assert.h>
+#include <default_sched.h>
+
+/* You should define the BigStride constant here*/
+/* LAB6: YOUR CODE */
+#define BIG_STRIDE (0x7FFFFFFF) /* you should give a value, and is ??? */
+
+/* The compare function for two skew_heap_node_t's and the
+ * corresponding procs*/
+static int
+proc_stride_comp_f(void *a, void *b)
+{
+     struct proc_struct *p = le2proc(a, lab6_run_pool);
+     struct proc_struct *q = le2proc(b, lab6_run_pool);
+     int32_t c = p->lab6_stride - q->lab6_stride;
+     if (c > 0)
+          return 1;
+     else if (c == 0)
+          return 0;
+     else
+          return -1;
+}
+
+/*
+ * stride_init initializes the run-queue rq with correct assignment for
+ * member variables, including:
+ *
+ *   - run_list: should be a empty list after initialization.
+ *   - lab6_run_pool: NULL
+ *   - proc_num: 0
+ *   - max_time_slice: no need here, the variable would be assigned by the caller.
+ *
+ * hint: see libs/list.h for routines of the list structures.
+ */
+static void
+stride_init(struct run_queue *rq)
+{
+     /* LAB6: YOUR CODE 
+      * (1) init the ready process list: rq->run_list
+      * (2) init the run pool: rq->lab6_run_pool
+      * (3) set number of process: rq->proc_num to 0       
+      */
+     list_init(&(rq->run_list));
+     rq->lab6_run_pool = NULL;
+     rq->proc_num = 0;
+}
+
+/*
+ * stride_enqueue inserts the process ``proc'' into the run-queue
+ * ``rq''. The procedure should verify/initialize the relevant members
+ * of ``proc'', and then put the ``lab6_run_pool'' node into the
+ * queue(since we use priority queue here). The procedure should also
+ * update the meta date in ``rq'' structure.
+ *
+ * proc->time_slice denotes the time slices allocation for the
+ * process, which should set to rq->max_time_slice.
+ * 
+ * hint: see libs/skew_heap.h for routines of the priority
+ * queue structures.
+ */
+static void
+stride_enqueue(struct run_queue *rq, struct proc_struct *proc)
+{
+     /* LAB6: YOUR CODE 
+      * (1) insert the proc into rq correctly
+      * NOTICE: you can use skew_heap or list. Important functions
+      *         skew_heap_insert: insert a entry into skew_heap
+      *         list_add_before: insert  a entry into the last of list   
+      * (2) recalculate proc->time_slice
+      * (3) set proc->rq pointer to rq
+      * (4) increase rq->proc_num
+      */
+     rq->lab6_run_pool = skew_heap_insert(
+         rq->lab6_run_pool, &(proc->lab6_run_pool), proc_stride_comp_f);
+     if (proc->time_slice == 0 || proc->time_slice > rq->max_time_slice)
+     {
+          proc->time_slice = rq->max_time_slice;
+     }
+     proc->rq = rq;
+     rq->proc_num++;
+}
+
+/*
+ * stride_dequeue removes the process ``proc'' from the run-queue
+ * ``rq'', the operation would be finished by the skew_heap_remove
+ * operations. Remember to update the ``rq'' structure.
+ *
+ * hint: see libs/skew_heap.h for routines of the priority
+ * queue structures.
+ */
+static void
+stride_dequeue(struct run_queue *rq, struct proc_struct *proc)
+{
+     /* LAB6: YOUR CODE 
+      * (1) remove the proc from rq correctly
+      * NOTICE: you can use skew_heap or list. Important functions
+      *         skew_heap_remove: remove a entry from skew_heap
+      *         list_del_init: remove a entry from the  list
+      */
+     rq->lab6_run_pool = skew_heap_remove(
+         rq->lab6_run_pool, &(proc->lab6_run_pool), proc_stride_comp_f);
+     rq->proc_num--;
+}
+/*
+ * stride_pick_next pick the element from the ``run-queue'', with the
+ * minimum value of stride, and returns the corresponding process
+ * pointer. The process pointer would be calculated by macro le2proc,
+ * see kern/process/proc.h for definition. Return NULL if
+ * there is no process in the queue.
+ *
+ * When one proc structure is selected, remember to update the stride
+ * property of the proc. (stride += BIG_STRIDE / priority)
+ *
+ * hint: see libs/skew_heap.h for routines of the priority
+ * queue structures.
+ */
+static struct proc_struct *
+stride_pick_next(struct run_queue *rq)
+{
+     /* LAB6: YOUR CODE 
+      * (1) get a  proc_struct pointer p  with the minimum value of stride
+             (1.1) If using skew_heap, we can use le2proc get the p from rq->lab6_run_poll
+             (1.2) If using list, we have to search list to find the p with minimum stride value
+      * (2) update p;s stride value: p->lab6_stride
+      * (3) return p
+      */
+     if (rq->lab6_run_pool == NULL)
+          return NULL;
+     struct proc_struct *p = le2proc(rq->lab6_run_pool, lab6_run_pool);
+     if (p->lab6_priority == 0)
+          p->lab6_stride += BIG_STRIDE;
+     else
+          p->lab6_stride += BIG_STRIDE / p->lab6_priority;
+     return p;
+}
+
+/*
+ * stride_proc_tick works with the tick event of current process. You
+ * should check whether the time slices for current process is
+ * exhausted and update the proc struct ``proc''. proc->time_slice
+ * denotes the time slices left for current
+ * process. proc->need_resched is the flag variable for process
+ * switching.
+ */
+static void
+stride_proc_tick(struct run_queue *rq, struct proc_struct *proc)
+{
+     /* LAB6: YOUR CODE */
+     if (proc->time_slice > 0)
+          proc->time_slice--;
+     if (proc->time_slice == 0)
+          proc->need_resched = 1;
+}
+
+struct sched_class default_sched_class = {
+    .name = "stride_scheduler",
+    .init = stride_init,
+    .enqueue = stride_enqueue,
+    .dequeue = stride_dequeue,
+    .pick_next = stride_pick_next,
+    .proc_tick = stride_proc_tick,
+};
diff -ruP /home/xmh/origin/ucore_os_lab/labcodes/lab7/kern/sync/check_sync.c lab7/kern/sync/check_sync.c
--- /home/xmh/origin/ucore_os_lab/labcodes/lab7/kern/sync/check_sync.c	2020-05-24 07:28:36.526368975 +0000
+++ lab7/kern/sync/check_sync.c	2020-05-24 13:50:47.924729210 +0000
@@ -4,13 +4,13 @@
 #include <monitor.h>
 #include <assert.h>
 
-#define N 5 /* 哲学家数目 */
-#define LEFT (i-1+N)%N /* i的左邻号码 */
-#define RIGHT (i+1)%N /* i的右邻号码 */
-#define THINKING 0 /* 哲学家正在思考 */
-#define HUNGRY 1 /* 哲学家想取得叉子 */
-#define EATING 2 /* 哲学家正在吃面 */
-#define TIMES  4 /* 吃4次饭 */
+#define N 5                  /* 哲学家数目 */
+#define LEFT (i - 1 + N) % N /* i的左邻号码 */
+#define RIGHT (i + 1) % N    /* i的右邻号码 */
+#define THINKING 0           /* 哲学家正在思考 */
+#define HUNGRY 1             /* 哲学家想取得叉子 */
+#define EATING 2             /* 哲学家正在吃面 */
+#define TIMES 4              /* 吃4次饭 */
 #define SLEEP_TIME 10
 
 //-----------------philosopher problem using monitor ------------
@@ -77,56 +77,55 @@
 int state_sema[N]; /* 记录每个人状态的数组 */
 /* 信号量是一个特殊的整型变量 */
 semaphore_t mutex; /* 临界区互斥 */
-semaphore_t s[N]; /* 每个哲学家一个信号量 */
+semaphore_t s[N];  /* 每个哲学家一个信号量 */
 
 struct proc_struct *philosopher_proc_sema[N];
 
 void phi_test_sema(i) /* i：哲学家号码从0到N-1 */
-{ 
-    if(state_sema[i]==HUNGRY&&state_sema[LEFT]!=EATING
-            &&state_sema[RIGHT]!=EATING)
+{
+    if (state_sema[i] == HUNGRY && state_sema[LEFT] != EATING && state_sema[RIGHT] != EATING)
     {
-        state_sema[i]=EATING;
+        state_sema[i] = EATING;
         up(&s[i]);
     }
 }
 
 void phi_take_forks_sema(int i) /* i：哲学家号码从0到N-1 */
-{ 
-        down(&mutex); /* 进入临界区 */
-        state_sema[i]=HUNGRY; /* 记录下哲学家i饥饿的事实 */
-        phi_test_sema(i); /* 试图得到两只叉子 */
-        up(&mutex); /* 离开临界区 */
-        down(&s[i]); /* 如果得不到叉子就阻塞 */
+{
+    down(&mutex);           /* 进入临界区 */
+    state_sema[i] = HUNGRY; /* 记录下哲学家i饥饿的事实 */
+    phi_test_sema(i);       /* 试图得到两只叉子 */
+    up(&mutex);             /* 离开临界区 */
+    down(&s[i]);            /* 如果得不到叉子就阻塞 */
 }
 
 void phi_put_forks_sema(int i) /* i：哲学家号码从0到N-1 */
-{ 
-        down(&mutex); /* 进入临界区 */
-        state_sema[i]=THINKING; /* 哲学家进餐结束 */
-        phi_test_sema(LEFT); /* 看一下左邻居现在是否能进餐 */
-        phi_test_sema(RIGHT); /* 看一下右邻居现在是否能进餐 */
-        up(&mutex); /* 离开临界区 */
-}
-
-int philosopher_using_semaphore(void * arg) /* i：哲学家号码，从0到N-1 */
-{
-    int i, iter=0;
-    i=(int)arg;
-    cprintf("I am No.%d philosopher_sema\n",i);
-    while(iter++<TIMES)
-    { /* 无限循环 */
-        cprintf("Iter %d, No.%d philosopher_sema is thinking\n",iter,i); /* 哲学家正在思考 */
+{
+    down(&mutex);             /* 进入临界区 */
+    state_sema[i] = THINKING; /* 哲学家进餐结束 */
+    phi_test_sema(LEFT);      /* 看一下左邻居现在是否能进餐 */
+    phi_test_sema(RIGHT);     /* 看一下右邻居现在是否能进餐 */
+    up(&mutex);               /* 离开临界区 */
+}
+
+int philosopher_using_semaphore(void *arg) /* i：哲学家号码，从0到N-1 */
+{
+    int i, iter = 0;
+    i = (int)arg;
+    cprintf("I am No.%d philosopher_sema\n", i);
+    while (iter++ < TIMES)
+    {                                                                      /* 无限循环 */
+        cprintf("Iter %d, No.%d philosopher_sema is thinking\n", iter, i); /* 哲学家正在思考 */
         do_sleep(SLEEP_TIME);
-        phi_take_forks_sema(i); 
+        phi_take_forks_sema(i);
         /* 需要两只叉子，或者阻塞 */
-        cprintf("Iter %d, No.%d philosopher_sema is eating\n",iter,i); /* 进餐 */
+        cprintf("Iter %d, No.%d philosopher_sema is eating\n", iter, i); /* 进餐 */
         do_sleep(SLEEP_TIME);
-        phi_put_forks_sema(i); 
+        phi_put_forks_sema(i);
         /* 把两把叉子同时放回桌子 */
     }
-    cprintf("No.%d philosopher_sema quit\n",i);
-    return 0;    
+    cprintf("No.%d philosopher_sema quit\n", i);
+    return 0;
 }
 
 //-----------------philosopher problem using monitor ------------
@@ -164,78 +163,94 @@
  */
 
 struct proc_struct *philosopher_proc_condvar[N]; // N philosopher
-int state_condvar[N];                            // the philosopher's state: EATING, HUNGARY, THINKING  
-monitor_t mt, *mtp=&mt;                          // monitor
+int state_condvar[N];                            // the philosopher's state: EATING, HUNGARY, THINKING
+monitor_t mt, *mtp = &mt;                        // monitor
+
+void phi_test_condvar(i)
+{
+    if (state_condvar[i] == HUNGRY && state_condvar[LEFT] != EATING && state_condvar[RIGHT] != EATING)
+    {
+        cprintf("phi_test_condvar: state_condvar[%d] will eating\n", i);
+        state_condvar[i] = EATING;
+        cprintf("phi_test_condvar: signal self_cv[%d] \n", i);
+        cond_signal(&mtp->cv[i]);
+    }
+}
 
-void phi_test_condvar (i) { 
-    if(state_condvar[i]==HUNGRY&&state_condvar[LEFT]!=EATING
-            &&state_condvar[RIGHT]!=EATING) {
-        cprintf("phi_test_condvar: state_condvar[%d] will eating\n",i);
-        state_condvar[i] = EATING ;
-        cprintf("phi_test_condvar: signal self_cv[%d] \n",i);
-        cond_signal(&mtp->cv[i]) ;
+void phi_take_forks_condvar(int i)
+{
+    down(&(mtp->mutex));
+    //--------into routine in monitor--------------
+    // LAB7 EXERCISE1: YOUR CODE
+    // I am hungry
+    state_condvar[i] = HUNGRY;
+    // try to get fork
+    phi_test_condvar(i);
+    if (state_condvar[i] != EATING)
+    {
+        cprintf("phi_take_forks_condvar: %d didn't get fork and will wait\n", i);
+        cond_wait(&mtp->cv[i]);
     }
+    //--------leave routine in monitor--------------
+    if (mtp->next_count > 0)
+        up(&(mtp->next));
+    else
+        up(&(mtp->mutex));
 }
 
+void phi_put_forks_condvar(int i)
+{
+    down(&(mtp->mutex));
 
-void phi_take_forks_condvar(int i) {
-     down(&(mtp->mutex));
-//--------into routine in monitor--------------
-     // LAB7 EXERCISE1: YOUR CODE
-     // I am hungry
-     // try to get fork
-//--------leave routine in monitor--------------
-      if(mtp->next_count>0)
-         up(&(mtp->next));
-      else
-         up(&(mtp->mutex));
-}
-
-void phi_put_forks_condvar(int i) {
-     down(&(mtp->mutex));
-
-//--------into routine in monitor--------------
-     // LAB7 EXERCISE1: YOUR CODE
-     // I ate over
-     // test left and right neighbors
-//--------leave routine in monitor--------------
-     if(mtp->next_count>0)
+    //--------into routine in monitor--------------
+    // LAB7 EXERCISE1: YOUR CODE
+    // I ate over
+    state_condvar[i] = THINKING;
+    // test left and right neighbors
+    phi_test_condvar(LEFT);
+    phi_test_condvar(RIGHT);
+    //--------leave routine in monitor--------------
+    if (mtp->next_count > 0)
         up(&(mtp->next));
-     else
+    else
         up(&(mtp->mutex));
 }
 
 //---------- philosophers using monitor (condition variable) ----------------------
-int philosopher_using_condvar(void * arg) { /* arg is the No. of philosopher 0~N-1*/
-  
-    int i, iter=0;
-    i=(int)arg;
-    cprintf("I am No.%d philosopher_condvar\n",i);
-    while(iter++<TIMES)
-    { /* iterate*/
-        cprintf("Iter %d, No.%d philosopher_condvar is thinking\n",iter,i); /* thinking*/
+int philosopher_using_condvar(void *arg)
+{ /* arg is the No. of philosopher 0~N-1*/
+
+    int i, iter = 0;
+    i = (int)arg;
+    cprintf("I am No.%d philosopher_condvar\n", i);
+    while (iter++ < TIMES)
+    {                                                                         /* iterate*/
+        cprintf("Iter %d, No.%d philosopher_condvar is thinking\n", iter, i); /* thinking*/
         do_sleep(SLEEP_TIME);
-        phi_take_forks_condvar(i); 
+        phi_take_forks_condvar(i);
         /* need two forks, maybe blocked */
-        cprintf("Iter %d, No.%d philosopher_condvar is eating\n",iter,i); /* eating*/
+        cprintf("Iter %d, No.%d philosopher_condvar is eating\n", iter, i); /* eating*/
         do_sleep(SLEEP_TIME);
-        phi_put_forks_condvar(i); 
+        phi_put_forks_condvar(i);
         /* return two forks back*/
     }
-    cprintf("No.%d philosopher_condvar quit\n",i);
-    return 0;    
+    cprintf("No.%d philosopher_condvar quit\n", i);
+    return 0;
 }
 
-void check_sync(void){
+void check_sync(void)
+{
 
     int i;
 
     //check semaphore
     sem_init(&mutex, 1);
-    for(i=0;i<N;i++){
+    for (i = 0; i < N; i++)
+    {
         sem_init(&s[i], 0);
         int pid = kernel_thread(philosopher_using_semaphore, (void *)i, 0);
-        if (pid <= 0) {
+        if (pid <= 0)
+        {
             panic("create No.%d philosopher_using_semaphore failed.\n");
         }
         philosopher_proc_sema[i] = find_proc(pid);
@@ -244,10 +259,12 @@
 
     //check condition variable
     monitor_init(&mt, N);
-    for(i=0;i<N;i++){
-        state_condvar[i]=THINKING;
+    for (i = 0; i < N; i++)
+    {
+        state_condvar[i] = THINKING;
         int pid = kernel_thread(philosopher_using_condvar, (void *)i, 0);
-        if (pid <= 0) {
+        if (pid <= 0)
+        {
             panic("create No.%d philosopher_using_condvar failed.\n");
         }
         philosopher_proc_condvar[i] = find_proc(pid);
diff -ruP /home/xmh/origin/ucore_os_lab/labcodes/lab7/kern/sync/monitor.c lab7/kern/sync/monitor.c
--- /home/xmh/origin/ucore_os_lab/labcodes/lab7/kern/sync/monitor.c	2020-05-24 07:28:36.526368975 +0000
+++ lab7/kern/sync/monitor.c	2020-05-24 11:23:48.969161698 +0000
@@ -3,31 +3,31 @@
 #include <kmalloc.h>
 #include <assert.h>
 
-
 // Initialize monitor.
-void     
-monitor_init (monitor_t * mtp, size_t num_cv) {
+void monitor_init(monitor_t *mtp, size_t num_cv)
+{
     int i;
-    assert(num_cv>0);
+    assert(num_cv > 0);
     mtp->next_count = 0;
     mtp->cv = NULL;
     sem_init(&(mtp->mutex), 1); //unlocked
     sem_init(&(mtp->next), 0);
-    mtp->cv =(condvar_t *) kmalloc(sizeof(condvar_t)*num_cv);
-    assert(mtp->cv!=NULL);
-    for(i=0; i<num_cv; i++){
-        mtp->cv[i].count=0;
-        sem_init(&(mtp->cv[i].sem),0);
-        mtp->cv[i].owner=mtp;
+    mtp->cv = (condvar_t *)kmalloc(sizeof(condvar_t) * num_cv);
+    assert(mtp->cv != NULL);
+    for (i = 0; i < num_cv; i++)
+    {
+        mtp->cv[i].count = 0;
+        sem_init(&(mtp->cv[i].sem), 0);
+        mtp->cv[i].owner = mtp;
     }
 }
 
-// Unlock one of threads waiting on the condition variable. 
-void 
-cond_signal (condvar_t *cvp) {
-   //LAB7 EXERCISE1: YOUR CODE
-   cprintf("cond_signal begin: cvp %x, cvp->count %d, cvp->owner->next_count %d\n", cvp, cvp->count, cvp->owner->next_count);  
-  /*
+// Unlock one of threads waiting on the condition variable.
+void cond_signal(condvar_t *cvp)
+{
+    //LAB7 EXERCISE1: YOUR CODE
+    cprintf("cond_signal begin: cvp %x, cvp->count %d, cvp->owner->next_count %d\n", cvp, cvp->count, cvp->owner->next_count);
+    /*
    *      cond_signal(cv) {
    *          if(cv.count>0) {
    *             mt.next_count ++;
@@ -37,16 +37,24 @@
    *          }
    *       }
    */
-   cprintf("cond_signal end: cvp %x, cvp->count %d, cvp->owner->next_count %d\n", cvp, cvp->count, cvp->owner->next_count);
+    if (cvp->count > 0)
+    {
+        monitor_t *mt = cvp->owner;
+        mt->next_count++;
+        up(&(cvp->sem));
+        down(&(mt->next));
+        mt->next_count--;
+    }
+    cprintf("cond_signal end: cvp %x, cvp->count %d, cvp->owner->next_count %d\n", cvp, cvp->count, cvp->owner->next_count);
 }
 
-// Suspend calling thread on a condition variable waiting for condition Atomically unlocks 
+// Suspend calling thread on a condition variable waiting for condition Atomically unlocks
 // mutex and suspends calling thread on conditional variable after waking up locks mutex. Notice: mp is mutex semaphore for monitor's procedures
-void
-cond_wait (condvar_t *cvp) {
+void cond_wait(condvar_t *cvp)
+{
     //LAB7 EXERCISE1: YOUR CODE
     cprintf("cond_wait begin:  cvp %x, cvp->count %d, cvp->owner->next_count %d\n", cvp, cvp->count, cvp->owner->next_count);
-   /*
+    /*
     *         cv.count ++;
     *         if(mt.next_count>0)
     *            signal(mt.next)
@@ -55,5 +63,13 @@
     *         wait(cv.sem);
     *         cv.count --;
     */
+    cvp->count++;
+    monitor_t *mt = cvp->owner;
+    if (mt->next_count > 0)
+        up(&(mt->next));
+    else
+        up(&(mt->mutex));
+    down(&(cvp->sem));
+    cvp->count--;
     cprintf("cond_wait end:  cvp %x, cvp->count %d, cvp->owner->next_count %d\n", cvp, cvp->count, cvp->owner->next_count);
 }
diff -ruP /home/xmh/origin/ucore_os_lab/labcodes/lab7/kern/trap/trap.c lab7/kern/trap/trap.c
--- /home/xmh/origin/ucore_os_lab/labcodes/lab7/kern/trap/trap.c	2020-05-24 07:28:36.526368975 +0000
+++ lab7/kern/trap/trap.c	2020-05-24 11:10:49.278139732 +0000
@@ -16,11 +16,13 @@
 #include <sched.h>
 #include <sync.h>
 #include <proc.h>
+#include <sched.h>
 
 #define TICK_NUM 100
 
-static void print_ticks() {
-    cprintf("%d ticks\n",TICK_NUM);
+static void print_ticks()
+{
+    cprintf("%d ticks\n", TICK_NUM);
 #ifdef DEBUG_GRADE
     cprintf("End of Test.\n");
     panic("EOT: kernel seems ok.");
@@ -36,14 +38,13 @@
 static struct gatedesc idt[256] = {{0}};
 
 static struct pseudodesc idt_pd = {
-    sizeof(idt) - 1, (uintptr_t)idt
-};
+    sizeof(idt) - 1, (uintptr_t)idt};
 
 /* idt_init - initialize IDT to each of the entry points in kern/trap/vectors.S */
-void
-idt_init(void) {
-     /* LAB1 YOUR CODE : STEP 2 */
-     /* (1) Where are the entry addrs of each Interrupt Service Routine (ISR)?
+void idt_init(void)
+{
+    /* LAB1 YOUR CODE : STEP 2 */
+    /* (1) Where are the entry addrs of each Interrupt Service Routine (ISR)?
       *     All ISR's entry addrs are stored in __vectors. where is uintptr_t __vectors[] ?
       *     __vectors[] is in kern/trap/vector.S which is produced by tools/vector.c
       *     (try "make" command in lab1, then you will find vector.S in kern/trap DIR)
@@ -54,14 +55,24 @@
       *     You don't know the meaning of this instruction? just google it! and check the libs/x86.h to know more.
       *     Notice: the argument of lidt is idt_pd. try to find it!
       */
-     /* LAB5 YOUR CODE */ 
-     //you should update your lab1 code (just add ONE or TWO lines of code), let user app to use syscall to get the service of ucore
-     //so you should setup the syscall interrupt gate in here
+    extern uintptr_t __vectors[];
+    int i;
+    for (i = 0; i < 256; i++)
+    {
+        SETGATE(idt[i], 0, GD_KTEXT, __vectors[i], DPL_KERNEL);
+    }
+    SETGATE(idt[T_SWITCH_TOK], 0, GD_KTEXT, __vectors[T_SWITCH_TOK], DPL_USER);
+    SETGATE(idt[T_SYSCALL], 1, GD_KTEXT, __vectors[T_SYSCALL], DPL_USER);
+    lidt(&idt_pd);
+    /* LAB5 YOUR CODE */
+    //you should update your lab1 code (just add ONE or TWO lines of code), let user app to use syscall to get the service of ucore
+    //so you should setup the syscall interrupt gate in here
 }
 
 static const char *
-trapname(int trapno) {
-    static const char * const excnames[] = {
+trapname(int trapno)
+{
+    static const char *const excnames[] = {
         "Divide error",
         "Debug",
         "Non-Maskable Interrupt",
@@ -81,32 +92,54 @@
         "x87 FPU Floating-Point Error",
         "Alignment Check",
         "Machine-Check",
-        "SIMD Floating-Point Exception"
-    };
+        "SIMD Floating-Point Exception"};
 
-    if (trapno < sizeof(excnames)/sizeof(const char * const)) {
+    if (trapno < sizeof(excnames) / sizeof(const char *const))
+    {
         return excnames[trapno];
     }
-    if (trapno >= IRQ_OFFSET && trapno < IRQ_OFFSET + 16) {
+    if (trapno >= IRQ_OFFSET && trapno < IRQ_OFFSET + 16)
+    {
         return "Hardware Interrupt";
     }
     return "(unknown trap)";
 }
 
 /* trap_in_kernel - test if trap happened in kernel */
-bool
-trap_in_kernel(struct trapframe *tf) {
+bool trap_in_kernel(struct trapframe *tf)
+{
     return (tf->tf_cs == (uint16_t)KERNEL_CS);
 }
 
 static const char *IA32flags[] = {
-    "CF", NULL, "PF", NULL, "AF", NULL, "ZF", "SF",
-    "TF", "IF", "DF", "OF", NULL, NULL, "NT", NULL,
-    "RF", "VM", "AC", "VIF", "VIP", "ID", NULL, NULL,
+    "CF",
+    NULL,
+    "PF",
+    NULL,
+    "AF",
+    NULL,
+    "ZF",
+    "SF",
+    "TF",
+    "IF",
+    "DF",
+    "OF",
+    NULL,
+    NULL,
+    "NT",
+    NULL,
+    "RF",
+    "VM",
+    "AC",
+    "VIF",
+    "VIP",
+    "ID",
+    NULL,
+    NULL,
 };
 
-void
-print_trapframe(struct trapframe *tf) {
+void print_trapframe(struct trapframe *tf)
+{
     cprintf("trapframe at %p\n", tf);
     print_regs(&tf->tf_regs);
     cprintf("  ds   0x----%04x\n", tf->tf_ds);
@@ -120,21 +153,24 @@
     cprintf("  flag 0x%08x ", tf->tf_eflags);
 
     int i, j;
-    for (i = 0, j = 1; i < sizeof(IA32flags) / sizeof(IA32flags[0]); i ++, j <<= 1) {
-        if ((tf->tf_eflags & j) && IA32flags[i] != NULL) {
+    for (i = 0, j = 1; i < sizeof(IA32flags) / sizeof(IA32flags[0]); i++, j <<= 1)
+    {
+        if ((tf->tf_eflags & j) && IA32flags[i] != NULL)
+        {
             cprintf("%s,", IA32flags[i]);
         }
     }
     cprintf("IOPL=%d\n", (tf->tf_eflags & FL_IOPL_MASK) >> 12);
 
-    if (!trap_in_kernel(tf)) {
+    if (!trap_in_kernel(tf))
+    {
         cprintf("  esp  0x%08x\n", tf->tf_esp);
         cprintf("  ss   0x----%04x\n", tf->tf_ss);
     }
 }
 
-void
-print_regs(struct pushregs *regs) {
+void print_regs(struct pushregs *regs)
+{
     cprintf("  edi  0x%08x\n", regs->reg_edi);
     cprintf("  esi  0x%08x\n", regs->reg_esi);
     cprintf("  ebp  0x%08x\n", regs->reg_ebp);
@@ -146,7 +182,8 @@
 }
 
 static inline void
-print_pgfault(struct trapframe *tf) {
+print_pgfault(struct trapframe *tf)
+{
     /* error_code:
      * bit 0 == 0 means no page found, 1 means protection fault
      * bit 1 == 0 means read, 1 means write
@@ -159,18 +196,23 @@
 }
 
 static int
-pgfault_handler(struct trapframe *tf) {
+pgfault_handler(struct trapframe *tf)
+{
     extern struct mm_struct *check_mm_struct;
-    if(check_mm_struct !=NULL) { //used for test check_swap
-            print_pgfault(tf);
-        }
+    if (check_mm_struct != NULL)
+    { //used for test check_swap
+        print_pgfault(tf);
+    }
     struct mm_struct *mm;
-    if (check_mm_struct != NULL) {
+    if (check_mm_struct != NULL)
+    {
         assert(current == idleproc);
         mm = check_mm_struct;
     }
-    else {
-        if (current == NULL) {
+    else
+    {
+        if (current == NULL)
+        {
             print_trapframe(tf);
             print_pgfault(tf);
             panic("unhandled page fault.\n");
@@ -183,25 +225,34 @@
 static volatile int in_swap_tick_event = 0;
 extern struct mm_struct *check_mm_struct;
 
+/* temporary trapframe or pointer to trapframe */
+struct trapframe switchk2u, *switchu2k;
+
 static void
-trap_dispatch(struct trapframe *tf) {
+trap_dispatch(struct trapframe *tf)
+{
     char c;
 
-    int ret=0;
+    int ret = 0;
 
-    switch (tf->tf_trapno) {
-    case T_PGFLT:  //page fault
-        if ((ret = pgfault_handler(tf)) != 0) {
+    switch (tf->tf_trapno)
+    {
+    case T_PGFLT: //page fault
+        if ((ret = pgfault_handler(tf)) != 0)
+        {
             print_trapframe(tf);
-            if (current == NULL) {
+            if (current == NULL)
+            {
                 panic("handle pgfault failed. ret=%d\n", ret);
             }
-            else {
-                if (trap_in_kernel(tf)) {
+            else
+            {
+                if (trap_in_kernel(tf))
+                {
                     panic("handle pgfault failed in kernel mode. ret=%d\n", ret);
                 }
                 cprintf("killed by kernel.\n");
-                panic("handle user mode pgfault failed. ret=%d\n", ret); 
+                panic("handle user mode pgfault failed. ret=%d\n", ret);
                 do_exit(-E_KILLED);
             }
         }
@@ -212,7 +263,7 @@
     case IRQ_OFFSET + IRQ_TIMER:
 #if 0
     LAB3 : If some page replacement algorithm(such as CLOCK PRA) need tick to change the priority of pages,
-    then you can add code here. 
+    then you can add code here.
 #endif
         /* LAB1 YOUR CODE : STEP 3 */
         /* handle the timer interrupt */
@@ -224,16 +275,20 @@
         /* you should upate you lab1 code (just add ONE or TWO lines of code):
          *    Every TICK_NUM cycle, you should set current process's current->need_resched = 1
          */
+        ticks++;
+        assert(current != NULL);
         /* LAB6 YOUR CODE */
         /* you should upate you lab5 code
          * IMPORTANT FUNCTIONS:
 	     * sched_class_proc_tick
          */         
+        // sched_class_proc_tick(current);
         /* LAB7 YOUR CODE */
         /* you should upate you lab6 code
          * IMPORTANT FUNCTIONS:
 	     * run_timer_list
          */
+        run_timer_list();
         break;
     case IRQ_OFFSET + IRQ_COM1:
         c = cons_getc();
@@ -245,8 +300,29 @@
         break;
     //LAB1 CHALLENGE 1 : YOUR CODE you should modify below codes.
     case T_SWITCH_TOU:
+        if (tf->tf_cs != USER_CS)
+        {
+            switchk2u = *tf;
+            switchk2u.tf_cs = USER_CS;
+            switchk2u.tf_ds = USER_DS;
+            switchk2u.tf_es = USER_DS;
+            switchk2u.tf_ss = USER_DS;
+            switchk2u.tf_esp = (uint32_t)tf + sizeof(struct trapframe) - 8;
+            switchk2u.tf_eflags |= FL_IOPL_MASK;
+            *((uint32_t *)tf - 1) = (uint32_t)&switchk2u;
+        }
+        break;
     case T_SWITCH_TOK:
-        panic("T_SWITCH_** ??\n");
+        if (tf->tf_cs != KERNEL_CS)
+        {
+            tf->tf_cs = KERNEL_CS;
+            tf->tf_ds = KERNEL_DS;
+            tf->tf_es = KERNEL_DS;
+            tf->tf_eflags &= ~FL_IOPL_MASK;
+            switchu2k = (struct trapframe *)(tf->tf_esp - (sizeof(struct trapframe) - 8));
+            memmove(switchu2k, tf, sizeof(struct trapframe) - 8);
+            *((uint32_t *)tf - 1) = (uint32_t)switchu2k;
+        }
         break;
     case IRQ_OFFSET + IRQ_IDE1:
     case IRQ_OFFSET + IRQ_IDE2:
@@ -254,13 +330,13 @@
         break;
     default:
         print_trapframe(tf);
-        if (current != NULL) {
+        if (current != NULL)
+        {
             cprintf("unhandled trap.\n");
             do_exit(-E_KILLED);
         }
         // in kernel, it must be a mistake
         panic("unexpected trap in kernel.\n");
-
     }
 }
 
@@ -269,31 +345,35 @@
  * the code in kern/trap/trapentry.S restores the old CPU state saved in the
  * trapframe and then uses the iret instruction to return from the exception.
  * */
-void
-trap(struct trapframe *tf) {
+void trap(struct trapframe *tf)
+{
     // dispatch based on what type of trap occurred
     // used for previous projects
-    if (current == NULL) {
+    if (current == NULL)
+    {
         trap_dispatch(tf);
     }
-    else {
+    else
+    {
         // keep a trapframe chain in stack
         struct trapframe *otf = current->tf;
         current->tf = tf;
-    
+
         bool in_kernel = trap_in_kernel(tf);
-    
+
         trap_dispatch(tf);
-    
+
         current->tf = otf;
-        if (!in_kernel) {
-            if (current->flags & PF_EXITING) {
+        if (!in_kernel)
+        {
+            if (current->flags & PF_EXITING)
+            {
                 do_exit(-E_KILLED);
             }
-            if (current->need_resched) {
+            if (current->need_resched)
+            {
                 schedule();
             }
         }
     }
 }
-
diff -ruP /home/xmh/origin/ucore_os_lab/labcodes/lab7/Makefile lab7/Makefile
--- /home/xmh/origin/ucore_os_lab/labcodes/lab7/Makefile	2020-05-24 07:28:36.522368925 +0000
+++ lab7/Makefile	2020-05-24 09:18:16.211869442 +0000
@@ -265,7 +265,7 @@
 
 .DEFAULT_GOAL := TARGETS
 
-QEMUOPTS = -hda $(UCOREIMG) -drive file=$(SWAPIMG),media=disk,cache=writeback
+QEMUOPTS = -hda $(UCOREIMG) -drive file=$(SWAPIMG),media=disk,cache=writeback -curses
 
 .PHONY: qemu qemu-nox debug debug-nox
 qemu-mon: $(UCOREIMG)  $(SWAPIMG)
